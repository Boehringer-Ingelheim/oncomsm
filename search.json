[{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contribution Guidelines","title":"Contribution Guidelines","text":"üôè Thank taking time contribute! input deeply valued, whether issue, pull request, even feedback, regardless size, content scope.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"table-of-contents","dir":"","previous_headings":"","what":"Table of contents","title":"Contribution Guidelines","text":"üóÉ License üìú Issues üö© Pull requests üëó Style guide üèÜ Recognition model ‚ùì Questions","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Contribution Guidelines","text":"contributions covered project‚Äôs license.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"Contribution Guidelines","text":"use GitHub track issues, feature requests, bugs. submitting new issue, please check issue already reported. issue already exists, please upvote existing issue üëç. reporting bug, please try specific possible describing provide minimal reproducible example (possible). new feature requests, please elaborate context benefit feature users, developers, relevant personas.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"proposing-changes-to-the-code","dir":"","previous_headings":"","what":"Proposing changes to the code","title":"Contribution Guidelines","text":"repository uses Github flow model collaboration. submit pull request: Create branch. Please see branch naming convention . don‚Äôt write access repository, please fork . Make changes. Make sure code: passes checks imposed GitHub Actions well documented well tested unit tests sufficiently covering changes introduced Create pull request (PR). pull request description, please link relevant issue (), provide detailed description change, include assumptions. Address review comments, (let reviewer know). Receive approval. Merge PR write access. Otherwise, reviewer merge PR behalf. Pat back. Congratulations! üéâ now official contributor project! grateful contribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"style-guide","dir":"","previous_headings":"","what":"Style guide","title":"Contribution Guidelines","text":"repository follows standard tidyverse style guide uses lintr lint checks. Customized lint configurations available repository‚Äôs .lintr file.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"recognition-model","dir":"","previous_headings":"","what":"Recognition model","title":"Contribution Guidelines","text":"currently formal recognition model place. expect recognition certain kind contribution, make sure clarify package maintainer starting work issue.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"questions","dir":"","previous_headings":"","what":"Questions","title":"Contribution Guidelines","text":"questions regarding contribution guidelines, please contact package/repository maintainer.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/application-to-probability-of-success.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Application to Probability of Success Calculation","text":"general introduction multi-state approach used throughout package, see vignette Multi-state Models Early Oncology. fully generative multi-state model, future trial data can sampled prior predictive distribution (data available) posterior predictive distribution conditioning data accrues. can used evaluate decision criterion determine trial success thus compute Probability Success.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/application-to-probability-of-success.html","id":"decision-criterion","dir":"Articles","previous_headings":"Background","what":"Decision criterion","title":"Application to Probability of Success Calculation","text":"Assume sample size (follow-) trial randomization scheme fixed upfront. Let \\(D_t \\\\mathbb{D}\\) observed (visit) data time point \\(t\\) start trial. Let \\(\\tau\\) stopping time trial (\\(n\\) individuals recruited minimal follow-reached) final decision whether trial considered success can modeled function \\(\\phi: \\mathbb{D} \\\\{0,1\\}\\) \\[\\phi(D_\\tau)=1 :\\Leftrightarrow D_\\tau\\ \\text{considered success}\\ . \\] can sample data \\(D_\\tau|\\theta\\) given generative model parameters \\(\\theta\\), can evaluate Probability Success \\[ \\operatorname{PoS} = \\int \\phi(D_\\tau) \\cdot f(\\theta) \\operatorname{d}\\theta \\] \\(f(\\theta)\\) prior model parameters using MCMC integration simulating forward form predictive distribution. data \\(D_t=d_t\\) observed \\(t\\leq\\tau\\), one can update PoS using Bayes Theorem \\[ \\operatorname{PoS}\\,|\\, (D_t=d_t \\ ) = \\int \\phi(D_\\tau\\,|\\,D_t=d_t) \\cdot f(\\theta\\,|\\,D_t=d_t) \\operatorname{d}\\theta \\ . \\] Examples decision rules ‚Ä¶ quantile posterior distribution response rate certain relevance threshold, quantile posterior distribution PFS6 rate certain relevance threshold, quantile posterior distribution PFS certain threshold, combination .","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/application-to-probability-of-success.html","id":"prior-specification","dir":"Articles","previous_headings":"Example","what":"Prior specification","title":"Application to Probability of Success Calculation","text":"Assume following prior multi-state model . can now sample prior visualize .  induced prior PFS rates 3, 6, 12, 18 months ","code":"mdl <- create_srp_model(     # names of the arms/groups     group_id = c(\"A\", \"B\", \"C\"),     # per-group logodds of response|stable     logodds_mean =  c(logodds(.20), logodds(.3), logodds(.3)),     logodds_sd = c(.5, .5, .5),     # m[i,j] is the median time to next event for group i and transition j     median_time_to_next_event = matrix(c(       3, 2, 6,       2, 8, 9,       2, 6, 24      ), byrow = TRUE,  nrow = 3, ncol = 3),     # fixed standard deviation of the prior for all median times     median_time_to_next_event_sd = matrix(        1, byrow = TRUE,  nrow = 3, ncol = 3     ),     # uniform prior over the shape parameter, difficult to identify,      # better keep it tight to avoid issues with the sampler     shape_min = matrix(        .75, byrow = TRUE,  nrow = 3, ncol = 3     ),     shape_max = matrix(        2, byrow = TRUE,  nrow = 3, ncol = 3     ),     # the visit interval     visit_spacing = c(1.2, 1.2, 1.2)   ) smpl_prior <- sample_prior(mdl, warmup = 500, nsim = 2000, seed = 6835L)  plot(mdl, dt = c(0, 36), sample = smpl_prior) tbl_pfs_rates <- sample_pfs_rate(mdl, c(3, 6, 12, 18), sample = smpl_prior) %>%    mutate(t = factor(t))    ggplot(tbl_pfs_rates) +   geom_boxplot(aes(x = t, y = pfs, color = group_id)) +   scale_color_discrete(\"\") +   labs(x = \"t\", y = \"Pr[no death or progression before t]\")"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/application-to-probability-of-success.html","id":"definition-of-success-criterion","dir":"Articles","previous_headings":"Example","what":"Definition of success criterion","title":"Application to Probability of Success Calculation","text":"Let us consider two success criteria per arm: \\(\\phi_1^(D_\\tau) = 0.25 \\ \\text{posterior quantile response greater } \\ 0.3\\) \\(\\phi_2^(D_\\tau) = 0.25 \\ \\text{posterior quantile PFS12 rate greater } \\ 0.5\\)","code":"# the simulation number is only chosen so small for demonstration purposes # we compute both phi_1 and phi_2 jointly to reuse the same posterior sample eval_phi <- function(data, prob = 0.25, nsim = 250) {   smpl <- sample_posterior(mdl, data = data, seed = 38497, warmup = 150L, nsim = nsim)   mtx_p <- rstan::extract(smpl, \"p\")$p   p <- apply(mtx_p, 2, function(x) quantile(x, .25))   res <- sample_pfs_rate(mdl, 12, smpl) %>%      group_by(group_id) %>%      summarize(pfs12 = quantile(pfs, .25)) %>%      mutate(       p = p,       phi_1 = p >= 0.3,       phi_2 = pfs12 >= 0.5     ) %>%      select(group_id, phi_1, phi_2)   return(res) } tbl_prior_predictive <- sample_predictive(     mdl,     n_per_group = rep(30L, 3),     sample = smpl_prior,     nsim = 100L, # same, here, only for demonstration purposes     seed = 34930L   ) %>%    group_by(iter) %>%    tidyr::nest() plan(multisession) # instruct future how to run in parallel  # it is a good idea to cache long running simulation ;) tbl_results <- xfun::cache_rds({       tbl_prior_predictive %>%     ungroup() %>%      mutate(       res = furrr::future_map(         data, eval_phi,         .options = furrr::furrr_options(seed = TRUE, scheduling = 5L)       )     ) %>%      select(-data)    }, dir = \".cache/\", file = \"sim_results.rds\") # end caching tbl_results %>%    tidyr::unnest(res) %>%    group_by(group_id) %>%    summarize(     pos_phi_1 = mean(phi_1),     pos_phi_2 = mean(phi_2)   ) #> # A tibble: 3 √ó 3 #>   group_id pos_phi_1 pos_phi_2 #>   <chr>        <dbl>     <dbl> #> 1 A             0.04      0    #> 2 B             0.21      0    #> 3 C             0.35      0.01"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/application-to-probability-of-success.html","id":"advanced-decision-boundaries-connection-with-bhmbasket","dir":"Articles","previous_headings":"Example","what":"Advanced decision boundaries: connection with bhmbasket","title":"Application to Probability of Success Calculation","text":"bhmbasket package implements dynamic borrowing arms basket trials via Bayesian hierarchical models (BHMs). , demonstrate prior predictive sample generated earlier can used conjunction shrinkage estimator compute PoS decision based BHM. use ‚ÄúBerry‚Äù type model analysis response data use posterior \\(0.25\\) quantile response rate \\(0.3\\) declare success (\\(\\phi_3^\\)).","code":"prms_berry <- bhmbasket::setPriorParametersBerry(   mu_mean   = bhmbasket::logit(0.25),   mu_sd     = 1,   tau_scale = 1 )  data_to_bhmbasket_trial <- function(data) {   data %>%      group_by(group_id, subject_id) %>%      summarize(responder = any(to == \"response\")) %>%      summarize(r = sum(responder), n = n()) %>%      {bhmbasket::createTrial(.$n, .$r)} %>%      return() }  eval_phi_3 <- function(data, nsim = 250) {   prob = 0.25 # needs to be hard coded   set.seed(2340239L)   res <- suppressMessages(bhmbasket::performAnalyses(       scenario_list         = data_to_bhmbasket_trial(data),       method_names          = \"berry\",       evidence_levels       = 1 - prob,       prior_parameters_list = prms_berry,       target_rates          = c(.2, .3, .3),       n_mcmc_iterations     = nsim,       verbose               = FALSE     ))   return(tibble(     group_id = attr(mdl, \"group_id\"),     phi_3 = res$scenario_1$quantiles_list$berry[[1]][5, 2:4] >= .3   )) } # it is a good idea to cache long running simulation ;) tbl_results_bhmbasket <- xfun::cache_rds({       tbl_prior_predictive %>%     ungroup() %>%      mutate(       res = furrr::future_map(         data, eval_phi_3,         .options = furrr::furrr_options(seed = TRUE)       )     ) %>%      select(-data)    }, dir = \".cache/\", file = \"sim_results_bhmbasket.rds\") # end caching tbl_results_bhmbasket %>%    tidyr::unnest(res) %>%    group_by(group_id) %>%    summarize(     pos_phi_3 = mean(phi_3)   ) %>%    left_join(     tbl_results %>%        tidyr::unnest(res) %>%        group_by(group_id) %>%        summarize(         pos_phi_1 = mean(phi_1),         pos_phi_2 = mean(phi_2)       ),      by = \"group_id\"   ) #> # A tibble: 3 √ó 4 #>   group_id pos_phi_3 pos_phi_1 pos_phi_2 #>   <chr>        <dbl>     <dbl>     <dbl> #> 1 A             0.06      0.04      0    #> 2 B             0.22      0.21      0    #> 3 C             0.31      0.35      0.01"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/application-to-probability-of-success.html","id":"computing-dynamic-probability-of-success","dir":"Articles","previous_headings":"","what":"Computing dynamic Probability of Success","title":"Application to Probability of Success Calculation","text":"todo.","code":"recruitment_rate_overall <- 3  # sample from predictive and then reduce to t = 10 tbl_interim <- sample_predictive(     mdl,      sample = smpl_prior,     n_per_group = c(30L, 30L, 30L),      nsim = 250,      seed = 3423423   ) %>%    filter(iter == 1) %>%    select(-t_sot) %>%    {left_join(     .,     select(., subject_id, group_id) %>%        distinct() %>%        arrange(runif(n())) %>% # permute groups       mutate(         t_sot = cumsum(rexp(n = n(), rate = recruitment_rate_overall)), # poisson recruitment process       ),     by = c(\"subject_id\", \"group_id\")   )} %>%    mutate(     t_min = t_min + t_sot,     t_max = t_max + t_sot   ) %>%    mstate_to_visits(mdl, .) %>%    filter(t <= 10) %>%    visits_to_mstate(     start_state = \"stable\",      absorbing_states = \"progression\",      now = 10   ) #> 'mstate_to_visits.srp_model' is experimental  tbl_interim_sample_sizes <- tbl_interim %>%    select(group_id, subject_id) %>%    distinct() %>%    group_by(group_id) %>%    summarize(n = n())  # posterior inference based on the interim data smpl_posterior <- sample_posterior(   mdl,    tbl_interim,    nsim = 2000, warmup = 250, seed = 76947 )  # need to create initial visits for to-be-recruited individuals tbl_to_be_recruited <- tibble(     group_id = tbl_interim_sample_sizes$group_id,     n_to_be_recruited = 30 - tbl_interim_sample_sizes$n     ) %>%    mutate(     tmp = purrr::map(       n_to_be_recruited,        ~tibble(         # use unique identifiers to avoid clashing between groups         subject_id = uuid::UUIDgenerate(n = .),         # sample recruitment times per group using half the overall          # recruitment rate         t_sot = cumsum(rexp(n = ., rate = recruitment_rate_overall/2))       )     )   ) %>%    select(-n_to_be_recruited) %>%    tidyr::unnest(tmp) %>%    # add information on starting state etc to expand to full mstate table   mutate(     from = \"stable\",     to = NA_character_,     t_min = t_sot + 1/30, # preclude events on the day of recruitment     t_max = Inf # right censored   )  # combine data tbl_mstate_interim_forward <- bind_rows(tbl_interim, tbl_to_be_recruited)  # MI using interim posterior tbl_posterior_predictive <- impute_predictive(     mdl,     data = tbl_mstate_interim_forward,      sample = smpl_posterior,     nsim = 250   ) %>%    group_by(iter) %>%    tidyr::nest()  tbl_pos <- xfun::cache_rds({       tbl_posterior_predictive %>%     ungroup() %>%      mutate(       res = furrr::future_map(         data, eval_phi_3,         .options = furrr::furrr_options(seed = TRUE)       )     ) %>%      select(-data) %>%      tidyr::unnest(res) %>%      group_by(group_id) %>%      summarize(pos = mean(phi_3))    }, dir = \".cache/\", file = \"sim_pos.rds\") # end caching   tbl_pos #> # A tibble: 3 √ó 2 #>   group_id   pos #>   <chr>    <dbl> #> 1 A        0.356 #> 2 B        0.12  #> 3 C        0.468"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Multi-State Models for Oncology","text":"tl;dr: Tumor response data often treated binary endpoint early oncology trials (objective response progression free survival x months). ignores fact time--event endpoints. Instead, multi-state characteristics data can exploited reduce bias interim analyses drive event prediction probability success calculations. early oncology trials, (objective tumor) response based RECIST criteria often used primary endpoint establish activity treatment. Response often treated binary variable although delayed event endpoint. final analysis, simplification little concern since individuals tend followed long enough justify assumption non-responders unlikely still become responders. approach often plausible since individuals tumors responding treatment ultimately progress. However, continuously monitoring trial, assumption sufficient follow-longer fulfilled simple binary analysis may biased. vignette, problem addressed extending statistic binary response model three-state model ‚Äústable‚Äù, ‚Äúresponse‚Äù, ‚Äúprogression death‚Äù. respective transition numbers given graph . someone becomes responder, model allows transition combined progression death state. means progression death modeled competing events simplifies analysis greatly model like one : Coming back simpler model, still competing event issue starting ‚Äòstable‚Äô. Often, convenient hazard-based approach used model multi-state situations like . hazard-based approach intuitive, especially considering non-parametric estimation, co variate inclusion well-understood. However, hazard-based approach several disadvantages: hazard scale difficult interpret since momentary risk, probability. leads problems prior specification Bayesian setting. Bayesian approach , however, particularly useful early development process since allows augment data prior opinion evidence thus improve accuracy. hazard based, non-Markov multi-state model leads intractable expressions implicitly given transition probabilities. Hence need calculated simulation makes model less convenient work transition probabilities primary interest. Since (objective) response rate often plays important role analysis early oncology trials, disadvantage. alternative framework model multi-state data mixture models. details, see Jackson et al. (2022) Jackson (2022). , describe concrete application simplified ‚Äústable‚Äù, ‚Äúresponse‚Äù, ‚Äúprogression‚Äù model. approach similar Aubel et al. (2021). Assuming transition process can described semi-Markov process one way rendering modeling tractable. means time next transition depends time already spent state, prior jumps. Additionally, assumed transition times states conditional originating target state can described Weibull distributions. parametric family encompasses exponential distribution constant transition rates special cases also allows increasing decreasing hazards time. Let \\(\\tau_{S}\\) transition time ‚Äústable‚Äù state \\(\\tau_{R}\\) transition tome ‚Äúresponse‚Äù state (also ‚Äúsojourn‚Äù times). Let \\(R\\) binary random variable \\(R=1\\) response occurs, model can specified : \\[ \\begin{align} R &\\sim \\operatorname{Bernoulli}(p) \\\\ \\tau_{S} \\,|\\, R = 1 &\\sim \\operatorname{Weibull}(k[1], \\lambda[1]) \\\\ \\tau_{S} \\,|\\, R = 0 &\\sim \\operatorname{Weibull}(k[2], \\lambda[2]) \\\\ \\tau_{R}             &\\sim \\operatorname{Weibull}(k[3], \\lambda[3]) \\end{align} \\] \\(k\\) vector shape- \\(\\lambda\\) vector scale parameters. Let \\(f_i(t)\\) PDF Weibull distribution transition \\(\\\\{1,2,3\\}\\) indicated figure let \\(F_i(t)\\) corresponding CDF. model implies \\[ \\operatorname{Pr}\\big[\\,\\tau_{S} > t \\,\\big]  = p\\cdot(1 - F_1(t))  + (1 - p)\\cdot(1 - F_2(t))\\\\ \\] hence, can seen mixture model. median Weibull-distributed random variable directly related shape scale parameters. Since former convenient interpret, Weibull distributions parameterized directly via shape median. scale parameter can recovered via relationship \\[ \\operatorname{scale} = \\frac{\\operatorname{median}}{\\log(2)^{1/\\operatorname{shape}}} .  \\] following priors used: normal prior log-odds response \\(\\operatorname{logit}(p) \\sim \\mathcal{N}(\\mu_p,\\sigma_p^2)\\) truncated normal prior median transition \\(\\operatorname{median}_{\\,} \\sim \\mathcal{N}(\\mu_i,\\sigma_i^2)[\\,0,\\infty)\\) flat prior shape transition \\(\\operatorname{shape}_{\\,} \\sim \\operatorname{Uniform}(a_i, b_i)\\) assumed observation process (visit spacing) fixed, e.g.¬†every 6 weeks. irrelevant inference, important sampling forward model since assumed transition times observed exactly regular visits. treat recruitment times independent outcome. can modeled separately required.","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"specifying-the-model","dir":"Articles","previous_headings":"Example","what":"Specifying the model","title":"Multi-State Models for Oncology","text":"assume time-scale months.","code":"mdl <- create_srp_model(     # names of the arms/groups     group_id = c(\"control\", \"intervention\"),     # per-group logodds of response|stable     logodds_mean =  c(logodds(.25), logodds(.5)),     logodds_sd = c(.75, .75),     # m[i,j] is the median time to next event for group i and transition j     median_time_to_next_event = matrix(c(       3, 2, 6,       2, 8, 12     ), byrow = TRUE,  nrow = 2, ncol = 3),     # fixed standard deviation of the prior for all median times     median_time_to_next_event_sd = matrix(        1, byrow = TRUE,  nrow = 2, ncol = 3     ),     # uniform prior over the shape parameter, difficult to identify,      # better keep it tight to avoid issues with the sampler     shape_min = matrix(        .75, byrow = TRUE,  nrow = 2, ncol = 3     ),     shape_max = matrix(        2, byrow = TRUE,  nrow = 2, ncol = 3     ),     # the visit interval     visit_spacing = c(1.2, 1.2)   ) # TODO: implement a nice summary / print function here"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"prior-checks","dir":"Articles","previous_headings":"Example","what":"Prior checks","title":"Multi-State Models for Oncology","text":"First, plot cumulative distribution functions (CDF) time--next-event first 36 (months) CDF response probabilities per group. based sample drawn prior distribution model. can re-use parameter sample sampling prior-predictive distribution separating sampling plotting steps. parameter sample provided plotting function samples automatically. Often, rate progression free survival (PFS) particular time point interest. quantity direct function model parameters. Since simplified model distinguish progression death, denote combined endpoint ‚Äúprogression‚Äù. \\[ \\begin{align} \\operatorname{PFS}(t) :&= \\operatorname{Pr}\\big[\\,\\text{progression } t\\,\\big] \\\\   &= 1 - \\operatorname{Pr}\\big[\\,\\text{progression } t\\,] \\\\   &= 1 - \\operatorname{Pr}\\big[\\,\\text{progression } t\\,|\\, \\text{response}\\,]\\cdot\\operatorname{Pr}\\big[\\,\\text{response}\\,] \\\\   &\\qquad- \\operatorname{Pr}\\big[\\,\\text{progression } t\\,|\\, \\text{response}\\,]\\cdot\\operatorname{Pr}\\big[\\,\\text{response}\\,] \\\\   &= 1 - p\\cdot\\int_0^t f_1(u) \\cdot F_2(t - u) \\operatorname{d}u - (1 - p)\\cdot F_3(t) \\ . \\end{align} \\] integral arises need reflect uncertainty state change ‚Äústable‚Äù ‚Äúresponse‚Äù way ‚Äúprogression‚Äù. parameter sample thus also induces sample PFS rate given time point curve PFS rate time corresponds survival function ‚Äúprogression death‚Äù event.","code":"smpl_prior <- sample_prior(mdl, warmup = 500, nsim = 2000, seed = 36L)  plot(mdl, dt = c(0, 36), sample = smpl_prior)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"sampling-from-the-prior-predictive-distribution","dir":"Articles","previous_headings":"Example > Prior checks","what":"Sampling from the prior-predictive distribution","title":"Multi-State Models for Oncology","text":"Next, draw samples prior-predictive distribution model. sample 100 trials 30 individuals per arm. , can re-use sample prior sample already used plotting. generated data can also visualized swimmer plots","code":"tbl_prior_predictive <- sample_predictive(   mdl,    sample = smpl_prior,   n_per_group = c(30L, 30L),    nsim = 100,    seed = 3423423 )   # estimate of the response rates tbl_prior_predictive %>%    filter(from == \"stable\") %>%    group_by(group_id) %>%    summarize(p_response = sum(to == \"response\")/n()) #> # A tibble: 2 √ó 2 #>   group_id     p_response #>   <chr>             <dbl> #> 1 control           0.258 #> 2 intervention      0.498  # crude approximation of the median jump times from \"stable\" tbl_prior_predictive %>%     filter(from == \"stable\") %>%    group_by(group_id, from, to) %>%    summarize(t_jump_approx = median(t_min + t_max)/2, .groups = \"drop\")  #> # A tibble: 4 √ó 4 #>   group_id     from   to          t_jump_approx #>   <chr>        <chr>  <chr>               <dbl> #> 1 control      stable progression           1.8 #> 2 control      stable response              3   #> 3 intervention stable progression           7.8 #> 4 intervention stable response              1.8 # TODO: improve sorting plot_mstate(mdl, tbl_prior_predictive %>% filter(iter == 1))"},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"building-a-visit-data-set","dir":"Articles","previous_headings":"Inference","what":"Building a visit data set","title":"Multi-State Models for Oncology","text":"Usually, data come form individual visits, yet form interval censored transitions. can mimic sake example converting one prior predictive samples visit data. Note conversion exact since mstate format contain information potential visits interval boundaries. Next, add recruitment times.","code":"tbl_visits <- tbl_prior_predictive %>%    filter(iter == 1) %>%    mstate_to_visits(mdl, .) #> 'mstate_to_visits.srp_model' is experimental  print(tbl_visits) #> # A tibble: 505 √ó 4 #>    subject_id group_id     t state       #>    <chr>      <chr>    <dbl> <chr>       #>  1 1          control    0   stable      #>  2 1          control    1.2 stable      #>  3 1          control    2.4 progression #>  4 10         control    0   stable      #>  5 10         control    1.2 stable      #>  6 10         control    2.4 stable      #>  7 10         control    3.6 stable      #>  8 10         control    4.8 stable      #>  9 10         control    6   stable      #> 10 10         control    7.2 stable      #> # ‚Ä¶ with 495 more rows recruitment_rate_overall <- 3 # sample from poisson process set.seed(31532) tbl_sot <- tbl_visits %>%    select(     subject_id,      group_id   ) %>%    distinct() %>%    arrange(runif(n())) %>% # permute groups   mutate(     t_sot = cumsum(rexp(n = n(), rate = recruitment_rate_overall)) # poisson recruitment process   )  # add to visit times tbl_visits <- tbl_visits %>%    left_join(tbl_sot, by = c(\"subject_id\", \"group_id\")) %>%    mutate(t = t + t_sot) %>%    select(-t_sot)  # convert back to mstate format and plot tbl_visits %>%    visits_to_mstate(start_state = \"stable\", absorbing_states = \"progression\") %>%    plot_mstate(mdl, ., relative_to_sot = FALSE)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"a-hypothetical-interim-analysis","dir":"Articles","previous_headings":"Inference","what":"A hypothetical interim analysis","title":"Multi-State Models for Oncology","text":"now cut data 15 months first SoT, can imitate hypothetical interim analysis.  can check observed response rates. Careful, due different time--event biased. can now inference drawing sample posterior distribution. Clearly, extreme sample prior shift posterior compared prior expected.  Bayesian approach specifies full generative model. can used draw samples posterior predictive distribution individuals still risk ones yet recruited. process sampling prior predictive - just replacing prior distribution posterior distribution obtained conditioning available data. 15 months trial, still individuals recruited (final sample size set 30 per group). now sample recruitment dates randomization probabilities still---recruited individuals. hypothetical future first-visits can now combined interim data trajectories can sampled forward using already fitted posterior distribution.  Repeatedly sampling posterior-predictive distribution allows evaluate decision criterion full trial completed since individual-level data practically imputed using posterior predictive distribution. allows compute Probability Success, see [???].","code":"tbl_visits_interim <- tbl_visits %>%    filter(t <= 15)   # convert to mstate plot tbl_mstate_interim <- visits_to_mstate(   tbl_visits_interim,    start_state = \"stable\",    absorbing_states = \"progression\",    now = 15 ) plot_mstate(mdl, tbl_mstate_interim, relative_to_sot = FALSE, now = 15) # estimate of the response rates (biased due to missing!) tbl_mstate_interim %>%    filter(from == \"stable\", !is.na(to)) %>%    group_by(group_id) %>%    summarize(p_response = sum(to == \"response\")/n()) #> # A tibble: 2 √ó 2 #>   group_id     p_response #>   <chr>             <dbl> #> 1 control           0.214 #> 2 intervention      0.545 smpl_posterior <- sample_posterior(   mdl,    tbl_mstate_interim,    refresh = 500, nsim = 5000, warmup = 250, seed = 76947 ) #>  #> SAMPLING FOR MODEL 'srp_model' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.000127 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 1.27 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 5250 [  0%]  (Warmup) #> Chain 1: Iteration:  251 / 5250 [  4%]  (Sampling) #> Chain 1: Iteration:  750 / 5250 [ 14%]  (Sampling) #> Chain 1: Iteration: 1250 / 5250 [ 23%]  (Sampling) #> Chain 1: Iteration: 1750 / 5250 [ 33%]  (Sampling) #> Chain 1: Iteration: 2250 / 5250 [ 42%]  (Sampling) #> Chain 1: Iteration: 2750 / 5250 [ 52%]  (Sampling) #> Chain 1: Iteration: 3250 / 5250 [ 61%]  (Sampling) #> Chain 1: Iteration: 3750 / 5250 [ 71%]  (Sampling) #> Chain 1: Iteration: 4250 / 5250 [ 80%]  (Sampling) #> Chain 1: Iteration: 4750 / 5250 [ 90%]  (Sampling) #> Chain 1: Iteration: 5250 / 5250 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 1.22221 seconds (Warm-up) #> Chain 1:                13.3817 seconds (Sampling) #> Chain 1:                14.6039 seconds (Total) #> Chain 1:  plot(mdl, dt = c(0, 36), sample = smpl_posterior) smpl_posterior %>%    parameter_sample_to_tibble(mdl, .) %>%    filter(parameter == \"p\") %>%    group_by(group_id) %>%    summarize(     p_posterior_mean = median(value),      q25 = quantile(value, probs = .25),      q75 = quantile(value, probs = .75)   ) #> # A tibble: 2 √ó 4 #>   group_id     p_posterior_mean   q25   q75 #>   <chr>                   <dbl> <dbl> <dbl> #> 1 control                 0.227 0.176 0.285 #> 2 intervention            0.529 0.451 0.606 tbl_interim_sample_sizes <- tbl_mstate_interim %>%    select(group_id, subject_id) %>%    distinct() %>%    group_by(group_id) %>%    summarize(n = n())  print(tbl_interim_sample_sizes) #> # A tibble: 2 √ó 2 #>   group_id         n #>   <chr>        <int> #> 1 control         20 #> 2 intervention    20 tbl_to_be_recruited <- tibble(     group_id = tbl_interim_sample_sizes$group_id,     n_to_be_recruited = 30 - tbl_interim_sample_sizes$n     ) %>%    mutate(     tmp = purrr::map(       n_to_be_recruited,        ~tibble(         # use unique identifiers to avoid clashing between groups         subject_id = uuid::UUIDgenerate(n = .),         # sample recruitment times per group using half the overall          # recruitment rate         t_sot = cumsum(rexp(n = ., rate = recruitment_rate_overall/2))       )     )   ) %>%    select(-n_to_be_recruited) %>%    tidyr::unnest(tmp) %>%    # add information on starting state etc to expand to full mstate table   mutate(     from = \"stable\",     to = NA_character_,     t_min = t_sot + 1/30, # preclude events on the day of recruitment     t_max = Inf # right censored   )  tbl_to_be_recruited #> # A tibble: 20 √ó 7 #>    group_id     subject_id                        t_sot from  to     t_min t_max #>    <chr>        <chr>                             <dbl> <chr> <chr>  <dbl> <dbl> #>  1 control      06ab3d86-1511-47b7-be72-9b95fe1‚Ä¶  0.151 stab‚Ä¶ NA     0.184   Inf #>  2 control      28f3bcd3-7e4e-49b4-8bf6-e613ecf‚Ä¶  1.33  stab‚Ä¶ NA     1.36    Inf #>  3 control      6c9487bc-1117-47c9-b659-52ef088‚Ä¶  2.76  stab‚Ä¶ NA     2.79    Inf #>  4 control      a3d9547c-1f58-4c42-89de-0ce76d5‚Ä¶  3.88  stab‚Ä¶ NA     3.91    Inf #>  5 control      edde7248-eb3b-48aa-baf0-320968d‚Ä¶  4.79  stab‚Ä¶ NA     4.82    Inf #>  6 control      5e4f652c-7c41-4e43-a077-44ea554‚Ä¶  6.10  stab‚Ä¶ NA     6.13    Inf #>  7 control      6b935c8f-7caa-4e48-8dbb-c09d93f‚Ä¶  7.78  stab‚Ä¶ NA     7.82    Inf #>  8 control      a923d702-67cb-43d6-94c0-bebcc55‚Ä¶  8.16  stab‚Ä¶ NA     8.20    Inf #>  9 control      0e0315c6-99a3-4a70-b2e9-85088d2‚Ä¶ 10.0   stab‚Ä¶ NA    10.1     Inf #> 10 control      60aefc78-4dce-44fd-a75e-c55c0ac‚Ä¶ 13.9   stab‚Ä¶ NA    13.9     Inf #> 11 intervention 53223006-e291-4394-a8ba-2952cc8‚Ä¶  0.554 stab‚Ä¶ NA     0.587   Inf #> 12 intervention af3a92c2-d611-4750-976e-f1f6001‚Ä¶  0.724 stab‚Ä¶ NA     0.758   Inf #> 13 intervention b6d3dc87-9dce-4b21-87b2-fe6b997‚Ä¶  2.31  stab‚Ä¶ NA     2.34    Inf #> 14 intervention 036d7c04-da9b-4882-830b-2e5dca0‚Ä¶  2.35  stab‚Ä¶ NA     2.38    Inf #> 15 intervention 97ed5706-08c0-4215-a4b3-6996bce‚Ä¶  2.88  stab‚Ä¶ NA     2.92    Inf #> 16 intervention 6f3c7feb-c048-4396-a59e-cc9dd27‚Ä¶  3.04  stab‚Ä¶ NA     3.07    Inf #> 17 intervention 55853fe7-0418-450c-be44-70454d7‚Ä¶  4.32  stab‚Ä¶ NA     4.35    Inf #> 18 intervention 53e62019-0486-47d7-aa3a-95b6ee8‚Ä¶  5.15  stab‚Ä¶ NA     5.18    Inf #> 19 intervention 6c7dc572-e08f-4b0e-aef7-8a54415‚Ä¶  6.29  stab‚Ä¶ NA     6.33    Inf #> 20 intervention 5cb806ed-c9fc-4692-9fc7-966b146‚Ä¶  6.52  stab‚Ä¶ NA     6.55    Inf tbl_mstate_interim_forward <- bind_rows(tbl_mstate_interim, tbl_to_be_recruited)  tbl_posterior_predictive <- impute_predictive(     mdl,     data = tbl_mstate_interim_forward,      sample = smpl_posterior,     nsim = 1   )  plot_mstate(mdl, tbl_posterior_predictive, relative_to_sot = FALSE)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Multi-State Models for Oncology","text":"","code":"sessionInfo() #> R version 4.2.1 (2022-06-23) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 20.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 #> LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_3.3.6      dplyr_1.0.10       oncomsm_0.1.0.9000 #>  #> loaded via a namespace (and not attached): #>  [1] Rcpp_1.0.9           tidyr_1.2.1          visNetwork_2.1.0     #>  [4] prettyunits_1.1.1    ps_1.7.1             rprojroot_2.0.3      #>  [7] digest_0.6.29        utf8_1.2.2           R6_2.5.1             #> [10] backports_1.4.1      stats4_4.2.1         evaluate_0.16        #> [13] highr_0.9            pillar_1.8.1         rlang_1.0.6          #> [16] uuid_1.1-0           callr_3.7.2          jquerylib_0.1.4      #> [19] checkmate_2.1.0      rmarkdown_2.16       DiagrammeR_1.0.9     #> [22] pkgdown_2.0.6        labeling_0.4.2       textshaping_0.3.6    #> [25] desc_1.4.2           stringr_1.4.1        htmlwidgets_1.5.4    #> [28] loo_2.5.1            munsell_0.5.0        compiler_4.2.1       #> [31] xfun_0.33            rstan_2.21.7         pkgconfig_2.0.3      #> [34] systemfonts_1.0.4    pkgbuild_1.3.1       htmltools_0.5.3      #> [37] tidyselect_1.1.2     tibble_3.1.8         gridExtra_2.3        #> [40] codetools_0.2-18     matrixStats_0.62.0   fansi_1.0.3          #> [43] crayon_1.5.1         withr_2.5.0          grid_4.2.1           #> [46] jsonlite_1.8.0       gtable_0.3.1         lifecycle_1.0.2      #> [49] magrittr_2.0.3       StanHeaders_2.21.0-7 scales_1.2.1         #> [52] RcppParallel_5.1.5   cli_3.4.1            stringi_1.7.8        #> [55] cachem_1.0.6         farver_2.1.1         fs_1.5.2             #> [58] bslib_0.4.0          ellipsis_0.3.2       ragg_1.2.2           #> [61] generics_0.1.3       vctrs_0.4.1          RColorBrewer_1.1-3   #> [64] tools_4.2.1          glue_1.6.2           purrr_0.3.4          #> [67] processx_3.7.0       parallel_4.2.1       fastmap_1.1.0        #> [70] yaml_2.3.5           inline_0.3.19        colorspace_2.0-3     #> [73] memoise_2.0.1        knitr_1.40           patchwork_1.1.2      #> [76] sass_0.4.2"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kevin Kunzmann. Author, maintainer.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kunzmann K (2022). oncomsm: Bayesian Multi-State Models Early Oncology. https://boehringer-ingelheim.github.io/oncomsm/, https://github.com/Boehringer-Ingelheim/oncomsm.","code":"@Manual{,   title = {oncomsm: Bayesian Multi-State Models for Early Oncology},   author = {Kevin Kunzmann},   year = {2022},   note = {https://boehringer-ingelheim.github.io/oncomsm/, https://github.com/Boehringer-Ingelheim/oncomsm}, }"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"bayesian-multi-state-models-for-oncology","dir":"","previous_headings":"","what":"Bayesian Multi-State Models for Early Oncology","title":"Bayesian Multi-State Models for Early Oncology","text":"Tl;dr: package implements methods dynamically predict response progression individuals early oncology trials using parametric multi-state models Bayesian inference. allows dynamic computation ‚Äúprobability success‚Äù wide range success criteria.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bayesian Multi-State Models for Early Oncology","text":"","code":"# install.packages(\"remotes\") remotes::install_github(\"https://github.com/Boehringer-Ingelheim/oncomsm\")"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Bayesian Multi-State Models for Early Oncology","text":"package documentation hosted .","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"giving-feedback","dir":"","previous_headings":"Contributing","what":"Giving feedback","title":"Bayesian Multi-State Models for Early Oncology","text":"Even feel comfortable opening issue repository even pull request, feedback error reports highly valued. Just get touch maintainer directly try specific describing potential problem. Feature suggestions etc. better suited issue GitHub though ;)","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"updating-stan-models","dir":"","previous_headings":"Contributing","what":"Updating stan models","title":"Bayesian Multi-State Models for Early Oncology","text":"stan models contained inst/stan automatically updated avoid taking dependency rstantools package. modifying adding new models, run silence R/stanmodels.R via capture.output().","code":"rstantools::rstan_config()"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/Model.html","id":null,"dir":"Reference","previous_headings":"","what":"An abstract multi-state model class ‚Äî Model","title":"An abstract multi-state model class ‚Äî Model","text":"abstract class defining standard set methods implemented multi-state model. Objects class 'Model' instantiated directly. objects respective sub-classes can.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/Model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An abstract multi-state model class ‚Äî Model","text":"","code":"# S3 method for Model sample_prior(   model,   warmup = 500L,   nsim = 2000L,   seed = NULL,   rstan_output = TRUE,   pars = attr(model, \"parameter_names\"),   ... )  # S3 method for Model sample_posterior(   model,   data,   warmup = 500L,   nsim = 2000L,   seed = NULL,   rstan_output = TRUE,   pars = attr(model, \"parameter_names\"),   ... )  # S3 method for Model sample_predictive(   model,   n_per_group,   sample = NULL,   nsim = 100L,   nsim_parameters = 1000L,   warmup_parameters = 250,   seed = NULL,   ... )  # S3 method for Model impute_predictive(   model,   data,   sample = NULL,   nsim = 1000L,   nsim_parameters = 1000L,   warmup_parameters = 250L,   seed = NULL,   ... )  # S3 method for Model parameter_sample_to_tibble(model, sample, ...)  # S3 method for Model plot_mstate(model, data, now, relative_to_sot, ...)  # S3 method for Model generate_visit_data(model, n_per_group, seed = NULL, ...)  # S3 method for Model sample_pfs_rate(   model,   t,   sample = NULL,   warmup = 500L,   nsim = 2000L,   seed = NULL,   ... )  # S3 method for Model mstate_to_visits(model, tbl_mstate, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/Model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"An abstract multi-state model class ‚Äî Model","text":"model model class \"Model\" warmup integer, number warmup samples rstan sampler retaining samples; used tune hyperparameters MCMC algorithm. nsim number samples draw seed integer, fixed random seed; NULL fixed seed rstan_output logical, function returns raw rstan sample object set TRUE pars character vector parameter names sample; resorting model defaults NULL ... arguments passed method implementations data (multi-state) data frame impute trajectories . n_per_group integer vector number individuals per group. sample stanfit object containing samples. parameter samples represent parameter distribution predictive distribution averages. Technically, parameters resampled replacement sample match desired number imputations. nsim_parameters integer, number parameter samples warmup_parameters integer, number warmup samples rstan sampler retaining samples parameters. now current time relative start trial (sot) relative_to_sot Boolean, timeline relative start trial start treatment individual t vector time-points PFS rate computed tbl_mstate data table multi-state format. TODO: explain","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/generate_visit_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Visit data from a multi-state model ‚Äî generate_visit_data","title":"Generate Visit data from a multi-state model ‚Äî generate_visit_data","text":"Generate Visit data multi-state model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/generate_visit_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Visit data from a multi-state model ‚Äî generate_visit_data","text":"","code":"generate_visit_data(model, n_per_group, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/generate_visit_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Visit data from a multi-state model ‚Äî generate_visit_data","text":"model model class \"Model\" n_per_group integer vector number individuals per group. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute_predictive.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute data from predictive distribution ‚Äî impute_predictive","title":"Impute data from predictive distribution ‚Äî impute_predictive","text":"parameter sample provided, sample posterior predictive","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute_predictive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute data from predictive distribution ‚Äî impute_predictive","text":"","code":"impute_predictive(   model,   data,   sample,   nsim,   nsim_parameters,   warmup_parameters,   seed,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute_predictive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute data from predictive distribution ‚Äî impute_predictive","text":"model model class \"Model\" data (multi-state) data frame impute trajectories . sample stanfit object containing samples. parameter samples represent parameter distribution predictive distribution averages. Technically, parameters resampled replacement sample match desired number imputations. nsim number samples draw nsim_parameters integer, number parameter samples warmup_parameters integer, number warmup samples rstan sampler retaining samples parameters. seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute_predictive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute data from predictive distribution ‚Äî impute_predictive","text":"data frame imputed version input data.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/logodds.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-odds function ‚Äî logodds","title":"Log-odds function ‚Äî logodds","text":"computed log odds probability.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/logodds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-odds function ‚Äî logodds","text":"","code":"logodds(p)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/logodds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-odds function ‚Äî logodds","text":"p numeric probabilities","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/logodds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-odds function ‚Äî logodds","text":"log(p/(1-p))","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/mstate_to_visits.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert data from multi-state to visit format ‚Äî mstate_to_visits","title":"Convert data from multi-state to visit format ‚Äî mstate_to_visits","text":"still experimental since conversion 1:1. multi-state representation drops non-changing visits, hence exact visit data recovered form multi-state representation.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/mstate_to_visits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert data from multi-state to visit format ‚Äî mstate_to_visits","text":"","code":"mstate_to_visits(model, tbl_mstate, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/mstate_to_visits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert data from multi-state to visit format ‚Äî mstate_to_visits","text":"model model class \"Model\" tbl_mstate data table multi-state format. TODO: explain ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/mstate_to_visits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert data from multi-state to visit format ‚Äî mstate_to_visits","text":"data frame (tibble) visit format, line corresponds individual visits.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/mstate_to_visits.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert data from multi-state to visit format ‚Äî mstate_to_visits","text":"intermediate visits reconstructed using visit spacing information stored model.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/oncomsm-package.html","id":null,"dir":"Reference","previous_headings":"","what":"The oncomsm package. ‚Äî oncomsm-package","title":"The oncomsm package. ‚Äî oncomsm-package","text":"package implements methods dynamically predict response progression individuals early oncology trials using parametric multi-state models Bayesian inference. allows dynamic computation Probability Success wide range success criteria. inference implemented using stan.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/oncomsm-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The oncomsm package. ‚Äî oncomsm-package","text":"Stan Development Team (2021). RStan: R interface Stan. R package version 2.21.3. https://mc-stan.org","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","title":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","text":"Convert stanfit sample data table","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","text":"","code":"parameter_sample_to_tibble(model, sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","text":"model model class \"Model\" sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","text":"tibble sampled parameters long format","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":null,"dir":"Reference","previous_headings":"","what":"Swimmer-like plot of multi-state data ‚Äî plot_mstate","title":"Swimmer-like plot of multi-state data ‚Äî plot_mstate","text":"Swimmer-like plot multi-state data","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swimmer-like plot of multi-state data ‚Äî plot_mstate","text":"","code":"plot_mstate(model, data, now, relative_to_sot, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Swimmer-like plot of multi-state data ‚Äî plot_mstate","text":"model model class \"Model\" data data table multi-state data now current time relative start trial (sot) relative_to_sot Boolean, timeline relative start trial start treatment individual ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_pfs_rate.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from the progression-free-survival rate ‚Äî sample_pfs_rate","title":"Sample from the progression-free-survival rate ‚Äî sample_pfs_rate","text":"Progression-free-survival rate time t (PFS-t rate) function parameters given multi-state model. Hence prior posterior sample model gives rise sample corresponding PFS t rate.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_pfs_rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from the progression-free-survival rate ‚Äî sample_pfs_rate","text":"","code":"sample_pfs_rate(model, t, sample, warmup, nsim, seed, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_pfs_rate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from the progression-free-survival rate ‚Äî sample_pfs_rate","text":"model model class \"Model\" t vector time-points PFS rate computed sample stanfit object samples respective model. warmup integer, number warmup samples rstan sampler retaining samples; used tune hyperparameters MCMC algorithm. nsim number samples draw seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_pfs_rate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from the progression-free-survival rate ‚Äî sample_pfs_rate","text":"data frame samples PFS rates time points vector t.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample model posterior parameters ‚Äî sample_posterior","title":"Sample model posterior parameters ‚Äî sample_posterior","text":"Posterior sample model parameters conditional data set.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample model posterior parameters ‚Äî sample_posterior","text":"","code":"sample_posterior(model, data, warmup, nsim, seed, rstan_output, pars, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample model posterior parameters ‚Äî sample_posterior","text":"model model class \"Model\" data data frame variables \"subject_id\", \"group_id\", \"t_recruitment\", \"dt1\" \"dt2\" dt1 minimal dt2 maximal time event question. Inf, individual never experience event. dt1 < Inf dt2 == Inf individual still risk. \"t_recruitment\", \"dt1\" \"dt2\" can also missing individual yet recruited. warmup integer, number warmup samples rstan sampler retaining samples; used tune hyperparameters MCMC algorithm. nsim number samples draw seed integer, fixed random seed; NULL fixed seed rstan_output logical, function returns raw rstan sample object set TRUE pars character vector parameter names sample; resorting model defaults NULL ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample model posterior parameters ‚Äî sample_posterior","text":"tibble columns iter (integer), parameter (character), group_id (character), value (numeric) parameter samples long format (rstan_output == TRUE) rstanfit object.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data from predictive distribution of a model ‚Äî sample_predictive","title":"Sample data from predictive distribution of a model ‚Äî sample_predictive","text":"Sample data predictive distribution model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data from predictive distribution of a model ‚Äî sample_predictive","text":"","code":"sample_predictive(   model,   n_per_group,   sample,   nsim,   nsim_parameters,   warmup_parameters,   seed,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample data from predictive distribution of a model ‚Äî sample_predictive","text":"model model class \"Model\" n_per_group integer vector number individuals per group. sample stanfit object samples respective model. nsim number samples draw nsim_parameters integer, number parameter samples warmup_parameters integer, number warmup samples rstan sampler retaining samples parameters. seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample data from predictive distribution of a model ‚Äî sample_predictive","text":"TODO:","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample model prior parameters ‚Äî sample_prior","title":"Sample model prior parameters ‚Äî sample_prior","text":"Sample model parameters model prior distribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample model prior parameters ‚Äî sample_prior","text":"","code":"sample_prior(model, warmup, nsim, seed, rstan_output, pars, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample model prior parameters ‚Äî sample_prior","text":"model model class \"Model\" warmup integer, number warmup samples rstan sampler retaining samples; used tune hyperparameters MCMC algorithm. nsim number samples draw seed integer, fixed random seed; NULL fixed seed rstan_output logical, function returns raw rstan sample object set TRUE pars character vector parameter names sample; resorting model defaults NULL ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample model prior parameters ‚Äî sample_prior","text":"tibble columns iter (integer), parameter (character), group_id (character), value (numeric) parameter samples long format (rstan_output == TRUE) rstanfit object.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":null,"dir":"Reference","previous_headings":"","what":"A Stable-Response-Progression Model ‚Äî mstate_to_visits.srp_model","title":"A Stable-Response-Progression Model ‚Äî mstate_to_visits.srp_model","text":"Create new instance SRP model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Stable-Response-Progression Model ‚Äî mstate_to_visits.srp_model","text":"","code":"# S3 method for srp_model mstate_to_visits(model, tbl_mstate, ...)  create_srp_model(   group_id,   logodds_mean,   logodds_sd,   median_time_to_next_event_mean,   median_time_to_next_event_sd,   visit_spacing,   logodds_min = rep(logodds(0.001), length(group_id)),   logodds_max = rep(logodds(0.999), length(group_id)),   shape_min = matrix(0.99, nrow = length(group_id), ncol = 3),   shape_max = matrix(1.01, nrow = length(group_id), ncol = 3) )  # S3 method for srp_model plot_mstate(   model,   data,   now = max(tbl_mstate$t_max),   relative_to_sot = TRUE,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Stable-Response-Progression Model ‚Äî mstate_to_visits.srp_model","text":"model model class \"Model\" tbl_mstate data table multi-state format. TODO: explain ... arguments passed method implementations group_id character vector group ids, used check compatibility data later logodds_mean vector means (truncated) normal priors log-odds response probability logodds_sd vector standard deviations (truncated) normal priors log-odds response probability median_time_to_next_event_mean matrix means (truncated) normal priors median time next event Weibull transition probabilities, (,j)-th entry -th group median time next event transition j (1=stable-response, 2=stable-progression, 3=response-progression) median_time_to_next_event_sd matrix standard deviations (truncated) normal priors median time next event Weibull transition probabilities, (,j)-th entry -th group median time next event transition j (1=stable-response, 2=stable-progression, 3=response-progression) visit_spacing vector time differences visits per group logodds_min lower boundary log-odds per group logodds_max upper boundary log-odds per group shape_min matrix lower boundaries uniform prior Weibull distribution per group/transition shape_max matrix upper boundaries uniform prior Weibull distribution per group/transition data data table multi-state data now current time relative start trial (sot) relative_to_sot Boolean, timeline relative start trial start treatment individual","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A Stable-Response-Progression Model ‚Äî mstate_to_visits.srp_model","text":"TODO","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert longitudinal visit data to time-to-event data ‚Äî visits_to_mstate","title":"Convert longitudinal visit data to time-to-event data ‚Äî visits_to_mstate","text":"Convert longitudinal visit data time--event data","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert longitudinal visit data to time-to-event data ‚Äî visits_to_mstate","text":"","code":"visits_to_mstate(   tbl_visits,   start_state,   absorbing_states,   now = max(tbl_visits$t),   eof_indicator = \"EOF\" )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert longitudinal visit data to time-to-event data ‚Äî visits_to_mstate","text":"tbl_visits visit data long format start_state staring state absorbing_states character vector absorbing states now time point since start trial (might later last recorded visit) eof_indicator state name indicating (exactly observed) eond follow .","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert longitudinal visit data to time-to-event data ‚Äî visits_to_mstate","text":"data frame","code":""}]
