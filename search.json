[{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contribution Guidelines","title":"Contribution Guidelines","text":"üôè Thank taking time contribute! input deeply valued, whether issue, pull request, even feedback, regardless size, content scope.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"table-of-contents","dir":"","previous_headings":"","what":"Table of contents","title":"Contribution Guidelines","text":"üóÉ License üìú Issues üö© Pull requests üëó Style guide üèÜ Recognition model ‚ùì Questions","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Contribution Guidelines","text":"contributions covered project‚Äôs license.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"Contribution Guidelines","text":"use GitHub track issues, feature requests, bugs. submitting new issue, please check issue already reported. issue already exists, please upvote existing issue üëç. reporting bug, please try specific possible describing provide minimal reproducible example (possible). new feature requests, please elaborate context benefit feature users, developers, relevant personas.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"proposing-changes-to-the-code","dir":"","previous_headings":"","what":"Proposing changes to the code","title":"Contribution Guidelines","text":"repository uses Github flow model collaboration. submit pull request: Create branch. Please see branch naming convention . don‚Äôt write access repository, please fork . Make changes. Make sure code: passes checks imposed GitHub Actions well documented well tested unit tests sufficiently covering changes introduced Create pull request (PR). pull request description, please link relevant issue (), provide detailed description change, include assumptions. Address review comments, (let reviewer know). Receive approval. Merge PR write access. Otherwise, reviewer merge PR behalf. Pat back. Congratulations! üéâ now official contributor project! grateful contribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"style-guide","dir":"","previous_headings":"","what":"Style guide","title":"Contribution Guidelines","text":"repository follows standard tidyverse style guide uses lintr lint checks. Customized lint configurations available repository‚Äôs .lintr file.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"updating-stan-models","dir":"","previous_headings":"","what":"Updating stan models","title":"Contribution Guidelines","text":"stan models contained inst/stan automatically updated avoid taking dependency rstantools package. modifying adding new models, run silence R/stanmodels.R via capture.output().","code":"rstantools::rstan_config()"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"recognition-model","dir":"","previous_headings":"","what":"Recognition model","title":"Contribution Guidelines","text":"currently formal recognition model place. expect recognition certain kind contribution, make sure clarify package maintainer advance.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"questions","dir":"","previous_headings":"","what":"Questions","title":"Contribution Guidelines","text":"questions regarding contribution guidelines, please contact package/repository maintainer.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/bhmbasket-integration.html","id":"defining-go-decision","dir":"Articles","previous_headings":"","what":"Defining ‚Äògo‚Äô decision","title":"Integration with bhmbasket","text":"bhmbasket package implements dynamic borrowing arms basket trials via Bayesian hierarchical models (BHMs). , demonstrate oncomsm prior specified mdl can used derive probability ‚Äògo‚Äô based bhmbasket analysis. use ‚ÄúBerry‚Äù type model analysis response data use posterior \\(0.25\\) quantile response probability \\(0.3\\) declare ‚Äògo‚Äô. means individual arm developed \\(0.75\\) posterior probability according BHM response rate larger \\(0.3\\).","code":"go <- function(model, data, nsim = 250) {   set.seed(2340239L)   # convert data to bhmbasket format (multi-state to binary counts)   data <- data %>%     group_by(group_id, subject_id) %>%     summarize(       responder = any(state == \"response\"),       .groups = \"drop_last\"     ) %>%     summarize(       r = sum(responder),       n = n(),     ) %>%     {       bhmbasket::createTrial(.$n, .$r)     }   # define Berry model in bhmbasket   prms_berry <- bhmbasket::setPriorParametersBerry(     mu_mean   = bhmbasket::logit(0.25),     mu_sd     = 1,     tau_scale = 1   )   # perform analysis in bhmbasket   res <- suppressMessages(bhmbasket::performAnalyses(     scenario_list         = data,     method_names          = \"berry\",     evidence_levels       = 1 - 0.25,     prior_parameters_list = prms_berry,     target_rates          = c(.2, .3, .3),     n_mcmc_iterations     = nsim,     verbose               = FALSE   ))   # 'go' if posterior quantile of response rate is sufficiently large   return(tibble(     group_id = model$group_id,     go = res$scenario_1$quantiles_list$berry[[1]][5, 2:4] >= .3   )) }"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/bhmbasket-integration.html","id":"probability-of-go-before-start-of-the-trial","dir":"Articles","previous_headings":"","what":"Probability of ‚Äògo‚Äô before start of the trial","title":"Integration with bhmbasket","text":"‚Äògo‚Äô criterion can applied resampled data sets.","code":"tbl_decisions <- simulate_decision_rule(mdl,                                          c(40, 40, 40),                                          go,                                         nsim = 250,                                         seed = 32487)  tbl_pr_go_planning <- tbl_decisions %>%    group_by(group_id) %>%    summarize(`Pr[go] planning` = mean(go))  tbl_pr_go_planning #> # A tibble: 3 √ó 2 #>   group_id `Pr[go] planning` #>   <chr>                <dbl> #> 1 A                    0.228 #> 2 B                    0.68  #> 3 C                    0.868"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/bhmbasket-integration.html","id":"update-probability-of-go","dir":"Articles","previous_headings":"","what":"Update probability of ‚Äògo‚Äô","title":"Integration with bhmbasket","text":"Now assume interim data available. data fairly extreme group group B.  prior can now updated data. probability ‚Äògo‚Äô updated sampling forward posterior predictive.","code":"tbl_interim <- tribble(    ~subject_id, ~group_id, ~t, ~state,           \"s1\", \"A\", 0, \"stable\",           \"s1\", \"A\", 1.5, \"stable\",           \"s1\", \"A\", 2.25, \"response\",           \"s2\", \"A\", 1, \"stable\",           \"s2\", \"A\", 2, \"response\",           \"s3\", \"A\", 3, \"stable\",           \"s3\", \"A\", 4.5, \"response\",                      \"s4\", \"B\", 0, \"stable\",           \"s5\", \"B\", 1.5, \"stable\",                      \"s6\", \"C\", 0, \"stable\",           \"s6\", \"C\", 1.5, \"progression\",           \"s7\", \"C\", 2.25, \"stable\",           \"s7\", \"C\", 3, \"progression\",           \"s8\", \"C\", 2, \"stable\",           \"s8\", \"C\", 3, \"progression\",           \"s9\", \"C\", 2, \"stable\",           \"s9\", \"C\", 2.6, \"stable\",           \"s9\", \"C\", 3, \"progression\",          \"s10\", \"C\", 3, \"stable\",          \"s10\", \"C\", 5, \"progression\" )  # plot it visits_to_mstate(tbl_interim, mdl) %>%    plot_mstate(mdl, relative_to_sot = FALSE) smpl_prior <- sample_prior(mdl, seed = 2314513) smpl_posterior <- sample_posterior(mdl, tbl_interim, seed = 2314)  tibble(   group_id = mdl$group_id,   prior = rstan::extract(smpl_prior, \"p\")[[1]] %>% colMeans(),   posterior = rstan::extract(smpl_posterior, \"p\")[[1]] %>% colMeans() ) #> # A tibble: 3 √ó 3 #>   group_id prior posterior #>   <chr>    <dbl>     <dbl> #> 1 A        0.300     0.389 #> 2 B        0.401     0.383 #> 3 C        0.504     0.400 tbl_decisions_interim <- simulate_decision_rule(   mdl,   c(40, 40, 40),    go,   data = tbl_interim,   nsim = 250,   seed = 32487 )  tbl_pr_go_planning %>%    left_join(     tbl_decisions_interim %>%      group_by(group_id) %>%      summarize(       `Pr[go] interim` = mean(go)     ),     by = \"group_id\"   ) #> # A tibble: 3 √ó 3 #>   group_id `Pr[go] planning` `Pr[go] interim` #>   <chr>                <dbl>            <dbl> #> 1 A                    0.228            0.54  #> 2 B                    0.68             0.608 #> 3 C                    0.868            0.548"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"specifying-the-model","dir":"Articles","previous_headings":"","what":"Specifying the model","title":"Multi-State Models for Oncology","text":"following code defined prior assumptions two-group trial visit-spacing 1 months. prior variance shape parameter low. sampling form prior, matter uncertainty Weibull shape parameters can assumed. posterior inference, identifying shape scale (median time event) small sample interval censored observations feasible leads divergent MCMC samples. shape thus kept almost fixed cases inference. model assumptions can visualized sampling prior.","code":"mdl <- create_srp_model(   A = srp_group_prior(     p_mean = 0.4, p_n = 10,     median_t_q05 = c(3, 2, 6) - 1, # s->r s->p r->p     median_t_q95 = c(3, 2, 6) + 1   ),   B = srp_group_prior(     p_mean = 0.6, p_n = 10,     median_t_q05 = c(2, 8, 3) - 1, # s->r s->p r->p     median_t_q95 = c(2, 8, 12) + 1,     shape_q05 = c(2, 2, 0.75),     shape_q95 = c(2.1, 2.1, 0.76)   ) )  print(mdl) #> srp_model<A,B>"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"prior-checks","dir":"Articles","previous_headings":"","what":"Prior checks","title":"Multi-State Models for Oncology","text":"First, plot cumulative distribution functions (CDF) time--next-event first 36 (months) CDF response probabilities per group. based sample drawn prior distribution model. can re-use parameter sample sampling prior-predictive distribution separating sampling plotting steps. Often, rate progression free survival (PFS) particular time point interest. quantity direct function model parameters. Since simplified model distinguish progression death, denote combined endpoint ‚Äúprogression‚Äù. \\[ \\begin{align} \\operatorname{PFS}(t) :&= \\operatorname{Pr}\\big[\\,\\text{progression } t\\,\\big] \\\\   &= 1 - \\operatorname{Pr}\\big[\\,\\text{progression } t\\,] \\\\   &= 1 - \\Big(\\ \\operatorname{Pr}\\big[\\,\\text{progression } t\\,|\\, \\text{response}\\,]\\cdot\\operatorname{Pr}\\big[\\,\\text{response}\\,] \\\\   &\\qquad+ \\operatorname{Pr}\\big[\\,\\text{progression } t\\,|\\, \\text{response}\\,]\\cdot\\operatorname{Pr}\\big[\\,\\text{response}\\,] \\ \\Big)\\\\   &= 1 - p\\cdot\\int_0^t f_1(u) \\cdot F_3(t - u) \\operatorname{d}u - (1 - p)\\cdot F_2(t) \\ . \\end{align} \\] integral arises need reflect uncertainty state change ‚Äústable‚Äù ‚Äúresponse‚Äù way ‚Äúprogression‚Äù. parameter sample thus also induces sample PFS rate given time point curve PFS rate time corresponds survival function ‚Äúprogression death‚Äù event.","code":"smpl_prior <- sample_prior(mdl, seed = 36L)  # plot(mdl) also works but need to resample prior further below plot(mdl, parameter_sample = smpl_prior, confidence = 0.9)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"sampling-from-the-prior-predictive-distribution","dir":"Articles","previous_headings":"","what":"Sampling from the prior-predictive distribution","title":"Multi-State Models for Oncology","text":"Next, draw samples prior-predictive distribution model. sample 100 trials 30 individuals per arm. , can re-use sample prior sample already used plotting. can run quick checks sampled data, e.g., observed response rates. crude approximation median transition times can compared prior means. default, prior predictive distribution given terms panel visit data. data can transformed interval-censored multi-state representation, (first sampled trial). multi-state data can visualized swimmer plots.  also possible simulate prior predictive distribution fixing parameter values. Fixing parameter values can interpreted conditioning parameters. instance one set response probabilities fixed values \\(0.1\\) \\(0.9\\):","code":"tbl_prior_predictive <- sample_predictive(   mdl,   sample = smpl_prior,   n_per_group = c(30L, 30L),   nsim = 100,   seed = 342 )  print(tbl_prior_predictive, n = 25) #> # A tibble: 59,667 √ó 5 #>    subject_id group_id     t state     iter #>    <chr>      <chr>    <dbl> <chr>    <int> #>  1 ID00010865 B         11.2 stable       1 #>  2 ID00010865 B         12.2 response     1 #>  3 ID00010865 B         13.2 response     1 #>  4 ID00010865 B         14.2 response     1 #>  5 ID00010865 B         15.2 response     1 #>  6 ID00010865 B         16.2 response     1 #>  7 ID00010865 B         17.2 response     1 #>  8 ID00010865 B         18.2 response     1 #>  9 ID00010865 B         19.2 response     1 #> 10 ID00010865 B         20.2 response     1 #> 11 ID00010865 B         21.2 response     1 #> 12 ID00010865 B         22.2 response     1 #> 13 ID00010865 B         23.2 response     1 #> 14 ID00010865 B         24.2 response     1 #> 15 ID00010865 B         25.2 response     1 #> 16 ID00010865 B         26.2 response     1 #> 17 ID00010865 B         27.2 response     1 #> 18 ID00010865 B         28.2 response     1 #> 19 ID00010865 B         29.2 response     1 #> 20 ID00010865 B         30.2 response     1 #> 21 ID00010865 B         31.2 response     1 #> 22 ID00010865 B         32.2 response     1 #> 23 ID00010865 B         33.2 response     1 #> 24 ID00010865 B         34.2 response     1 #> 25 ID00010865 B         35.2 response     1 #> # ‚Ä¶ with 59,642 more rows tbl_prior_predictive %>%   group_by(group_id, iter, subject_id) %>%   summarize(     responder = any(state == \"response\"),     .groups = \"drop\"   ) %>%   group_by(group_id) %>%   summarize(     p_response = mean(responder),     se = sd(responder) / sqrt(n())   ) #> # A tibble: 2 √ó 3 #>   group_id p_response      se #>   <chr>         <dbl>   <dbl> #> 1 A             0.353 0.00872 #> 2 B             0.515 0.00913 tbl_prior_predictive %>%   distinct(subject_id, iter, state, .keep_all = TRUE) %>%   group_by(iter, group_id, subject_id) %>%   summarize(     dt = t - lag(t),     from = lag(state),     to = state,     .groups = \"drop\"   ) %>%   filter(to != \"stable\") %>%   group_by(group_id, from, to) %>%   summarize(     `median transition time` = median(dt),     .groups = \"drop\"   ) #> # A tibble: 6 √ó 4 #>   group_id from     to          `median transition time` #>   <chr>    <chr>    <chr>                          <dbl> #> 1 A        response progression                        7 #> 2 A        stable   progression                        2 #> 3 A        stable   response                           3 #> 4 B        response progression                        5 #> 5 B        stable   progression                        7 #> 6 B        stable   response                           2 tbl_mstate <- tbl_prior_predictive %>%   filter(iter == 1) %>%   visits_to_mstate(mdl)  tbl_mstate #> # A tibble: 80 √ó 7 #>    subject_id group_id from     to          t_min t_max t_sot #>    <chr>      <chr>    <chr>    <chr>       <dbl> <dbl> <dbl> #>  1 ID00010865 B        stable   response    11.2  12.2  11.2  #>  2 ID00010865 B        response progression 77.2  78.2  11.2  #>  3 ID00019694 B        stable   progression 30.2  31.2  18.2  #>  4 ID00294641 B        stable   progression 29.8  30.8  23.8  #>  5 ID00559801 B        stable   response    22.9  23.9  22.9  #>  6 ID00559801 B        response progression 48.9  49.9  22.9  #>  7 ID00827488 A        stable   response    16.2  17.2   7.19 #>  8 ID00827488 A        response progression 17.2  18.2   7.19 #>  9 ID01007254 A        stable   progression 27.4  28.4  23.4  #> 10 ID01039842 A        stable   progression  1.45  2.45  1.45 #> # ‚Ä¶ with 70 more rows plot_mstate(tbl_mstate, mdl) sample_predictive(     mdl,     sample = smpl_prior,     p = c(0.1, 0.9),     n_per_group = c(30L, 30L),     nsim = 100,     seed = 3423423   ) %>%   group_by(group_id, iter, subject_id) %>%   summarize(     responder = any(state == \"response\"),     .groups = \"drop\"   ) %>%   group_by(group_id) %>%   summarize(     p_response = mean(responder),     se = sd(responder) / sqrt(n())   ) #> # A tibble: 2 √ó 3 #>   group_id p_response      se #>   <chr>         <dbl>   <dbl> #> 1 A             0.093 0.00530 #> 2 B             0.792 0.00741"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"a-hypothetical-interim-analysis","dir":"Articles","previous_headings":"","what":"A hypothetical interim analysis","title":"Multi-State Models for Oncology","text":"First, sample single data set extreme response probabilities deviate chosen prior. data can curtailed hypothetical interim time-point simply filtering visit time-points. censoring interim data can visualized swimmer plot .  can check observed response rates . Due censoring interim time point, response rate estimate biased. Instead, one can now inference drawing sample posterior distribution account censoring. Since data conflicts prior, posterior mass move direction observed response rates.","code":"tbl_data_interim <- sample_predictive(     mdl,     sample = smpl_prior,     p = c(0.2, 0.8),     n_per_group = c(30L, 30L),     nsim = 1,     seed = 42L   ) %>%   filter(     t <= 15   ) tbl_data_interim %>%   visits_to_mstate(mdl, now = 15) %>%   plot_mstate(mdl, relative_to_sot = FALSE, now = 15) tbl_data_interim %>%   group_by(group_id, iter, subject_id) %>%   summarize(     responder = any(state == \"response\"),     .groups = \"drop\"   ) %>%   group_by(group_id) %>%   summarize(     p_response = mean(responder),     se = sd(responder) / sqrt(n())   ) #> # A tibble: 2 √ó 3 #>   group_id p_response    se #>   <chr>         <dbl> <dbl> #> 1 A               0     0   #> 2 B               0.9   0.1 smpl_posterior <- sample_posterior(mdl, tbl_data_interim, seed = 43L)  plot(mdl, parameter_sample = smpl_posterior, confidence = 0.9) # plot under posterior # calculate posterior quantiles of response probability smpl_posterior %>%   parameter_sample_to_tibble(mdl, .) %>%   filter(parameter == \"p\") %>%   group_by(group_id) %>%   summarize(     p_posterior_mean = median(value),     q25 = quantile(value, probs = .25),     q75 = quantile(value, probs = .75)   ) #> # A tibble: 2 √ó 4 #>   group_id p_posterior_mean   q25   q75 #>   <chr>               <dbl> <dbl> <dbl> #> 1 A                   0.298 0.212 0.387 #> 2 B                   0.760 0.682 0.826"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Multi-State Models for Oncology","text":"","code":"sessionInfo() #> R version 4.2.2 (2022-10-31) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 22.04.1 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_3.4.0      dplyr_1.0.10       oncomsm_0.1.1.9000 #>  #> loaded via a namespace (and not attached): #>  [1] Rcpp_1.0.9           tidyr_1.2.1          prettyunits_1.1.1    #>  [4] ps_1.7.2             visNetwork_2.1.2     rprojroot_2.0.3      #>  [7] digest_0.6.30        utf8_1.2.2           R6_2.5.1             #> [10] backports_1.4.1      stats4_4.2.2         evaluate_0.18        #> [13] highr_0.9            pillar_1.8.1         rlang_1.0.6          #> [16] callr_3.7.3          jquerylib_0.1.4      checkmate_2.1.0      #> [19] rmarkdown_2.18       DiagrammeR_1.0.9     pkgdown_2.0.6        #> [22] labeling_0.4.2       textshaping_0.3.6    desc_1.4.2           #> [25] stringr_1.4.1        htmlwidgets_1.5.4    loo_2.5.1            #> [28] munsell_0.5.0        compiler_4.2.2       xfun_0.35            #> [31] rstan_2.21.7         pkgconfig_2.0.3      systemfonts_1.0.4    #> [34] pkgbuild_1.4.0       htmltools_0.5.3      tidyselect_1.2.0     #> [37] tibble_3.1.8         gridExtra_2.3        codetools_0.2-18     #> [40] matrixStats_0.63.0   fansi_1.0.3          crayon_1.5.2         #> [43] withr_2.5.0          grid_4.2.2           jsonlite_1.8.3       #> [46] gtable_0.3.1         lifecycle_1.0.3      magrittr_2.0.3       #> [49] StanHeaders_2.21.0-7 scales_1.2.1         RcppParallel_5.1.5   #> [52] cli_3.4.1            stringi_1.7.8        cachem_1.0.6         #> [55] farver_2.1.1         fs_1.5.2             bslib_0.4.1          #> [58] ellipsis_0.3.2       ragg_1.2.4           generics_0.1.3       #> [61] vctrs_0.5.1          RColorBrewer_1.1-3   tools_4.2.2          #> [64] glue_1.6.2           purrr_0.3.5          processx_3.8.0       #> [67] parallel_4.2.2       fastmap_1.1.0        yaml_2.3.6           #> [70] RcppNumerical_0.4-0  inline_0.3.19        colorspace_2.0-3     #> [73] memoise_2.0.1        knitr_1.41           patchwork_1.1.2      #> [76] sass_0.4.4"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/prior-choice.html","id":"why-weibull-transition-times","dir":"Articles","previous_headings":"","what":"Why Weibull transition times?","title":"Prior Choice","text":"oncomsm distributions -state transition times always modeled Weibull distributions. restriction terms class distribution implicit prior transition times. rationale mainly due trade-model flexibility model complexity. Weibull family two parameter distribution family probability density function given \\[ f(t|,b) = \\frac b \\bigg(\\frac t b\\bigg)^{- 1} e^{-\\big(\\frac t b\\big)^} \\quad t > 0 \\] \\(\\) shape \\(b\\) scale parameter. corresponding hazard function given \\[ h(t|,b) = \\frac b \\bigg(\\frac t \\bigg)^{b - 1} \\ . \\] one-parameter exponential distribution recovered special case \\(b = 1\\). Weibull distribution family adds flexibility one important aspect since allows hazard rate either increasing (\\(b<1\\)) decreasing (\\(b>1\\)) time. Combined three-state model, provides quite flexibility model different disease progression characteristics without increasing model complexity much. Compared exponential model, three-state Weibull model 7 instead 4 parameters. two-parameter survival distributions like log-normal Gamma distribution equally viable characteristics hazard functions intricate. Realistically, proper model selection identification complex patterns hazard function unfeasible small sample sizes. settings larger sample sizes, e.g., model selection frequentist framework, often feasible. excellent flexsurv package covers large number common parametric survival models supports multi-state models.","code":"h <- function(t, a, b) b / a * (t / a)^(b - 1) t <- pmax(0.1, seq(0, 36, length.out = 100)) tidyr::expand_grid(   t = t ,    tibble(     a = c(3, 6, 12, 12, 12, 12),      b = c(1, 1, 1, .5, 1.5, 3)   ) ) %>%  mutate(   hazard = h(t, a, b),   label = sprintf(\"a=%5.2f, b=%5.2f\", a, b) ) %>%    ggplot() +      aes(t, hazard, color = label) +     geom_line() +     scale_y_continuous(limits = c(0, 1))"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/prior-choice.html","id":"paramter-prior-choice","dir":"Articles","previous_headings":"","what":"Paramter prior choice","title":"Prior Choice","text":"Since parameters interest, reference prior Weibull distribution proportional \\(1/(b)\\) (note non-informative priors Weibull distributions). corresponds measure-preserving determinant inverse transformation \\[ (, b) \\mapsto \\big(\\log(), \\log(b) \\big) \\] hence, corresponds improper uniform distribution \\(\\log()\\) \\(\\log(b)\\). weakly alternative proper alternative thus place independent normal distributions log parameters , equivalently, use independent log-normal priors \\(\\) \\(b\\). Let \\[ g(x | \\mu, \\sigma) = \\frac e^{-\\frac {(\\log(x) - \\mu)^2} {2\\sigma^2} } {x\\sigma\\sqrt{2\\pi}} \\] density log-normal distribution parameters \\(\\mu, \\sigma\\). question chose parameters practice. Due potentially large skew log-normal distribution might intuitive specify mode distribution ‚Äòtypical‚Äô values quantile, e.g., \\(0.9\\)-quantile indicate long transition times. mode thus chosen somewhat feasible value ‚Äòbest guess‚Äô relatively large \\(0.90\\)-quantile indicate vagueness. Solving specified mode standard deviation log-normal distribution specified \\(\\mu\\) \\(\\sigma\\) uniquely. , instance, typical time stable response around 3 months, \\(0.9\\)-quantile 10 times mode leads fairly vague prior heavy right tail. typically least degree information median time transition, choice prior shape much less obvious weakly informative prior centered \\(1\\) (neither increasing decreasing hazard suggested default. following plot demonstrates shape variety Weibull distributions fixed median 6. sample joint prior median time response shape, first sample shape parameter. given shape \\(b\\), median \\(\\log(2)^{(1/b)}\\) hence mode quantile log-normal distribution scale need divided factor \\(\\log(2)^{(1/b)}\\).","code":"get_mu_sigma <- function(mean, sd, prob = 0.9) {   f <- function(x) {     mu <- x[1]     sigma <- x[2]     c(       exp(mu - sigma^2), # mode       qlnorm(prob, mu, sigma)     )   }   res <- optim(     c(1, 0.5),     function(x) sum((f(x) - c(mean, sd))^2),     lower = c(-Inf, 0.001),     method = \"L-BFGS-B\"   )   return(tibble(     mu = res$par[1],     sigma = res$par[2],     res = list(res)   )) } res <- get_mu_sigma(5, 20) median_transition_time <- t ggplot(tibble(median_transition_time = median_transition_time, pdf = dlnorm(median_transition_time, res$mu, res$sigma)), aes(median_transition_time, pdf)) + geom_line() tmp <- 5 res <- get_mu_sigma(1, tmp) shape <- seq(0, 5, length.out = 100) ggplot(tibble(shape = shape, pdf = dlnorm(shape, res$mu, res$sigma)), aes(shape, pdf)) + geom_line() #set.seed(251L) tibble(   b = rlnorm(50, get_mu_sigma(1, tmp)$mu, get_mu_sigma(1, tmp)$sigma),   a = 6 ) %>%  expand_grid(t = t) %>%  mutate(   survival = 1 - pweibull(t, b, a),    label = sprintf(\"a=%5.2f, b=%5.2f\", a, b) ) %>%  ggplot() +    aes(t, survival, group = label) +   geom_line(alpha = .2) set.seed(251L) tibble(   b = rlnorm(20, get_mu_sigma(1, tmp)$mu, get_mu_sigma(1, tmp)$sigma),   a = purrr::map_dbl(b, function(x) {       fct <- (log(2)^(1 / x))       res <- get_mu_sigma(3 / fct, 30 / fct)       rlnorm(1, res$mu, res$sigma)     }   ) ) %>%  expand_grid(t = t) %>%  mutate(   survival = 1 - pweibull(t, b, a),    label = sprintf(\"a=%5.2f, b=%5.2f\", a, b) ) %>%  ggplot() +    aes(t, survival, group = label) +   geom_line() mdl <- create_srp_model(   \"A\",    0,    .5,    matrix(c(3, 3, 6), nrow = 1),    matrix(c(.1, .1, .1), nrow = 1),    c(1, 1, 1),   shape_mode = matrix(c(1, 1, 1), nrow = 1),   shape_90q = matrix(c(5, 5, 5), nrow = 1),   median_t_mode = matrix(c(3, 3, 6), nrow = 1),   median_t_90q = matrix(c(30, 30, 60), nrow = 1),   visit_spacing = c(.1, .1, .1),   p_mean = .5,   p_n = 20,   p_eta = .0 )  plot(mdl)  sample_prior(mdl) tbl_prior_predictive <- sample_predictive(mdl, 1e3)  tbl_prior_predictive %>%       distinct(subject_id, iter, state, .keep_all = TRUE) %>%       group_by(iter, group_id, subject_id) %>%       summarize(         dt = t - lag(t),         from = lag(state),         to = state,         .groups = \"drop\"       ) %>%       filter(to != \"stable\") %>%       group_by(group_id, from, to) %>%       summarize(         median = median(dt),         .groups = \"drop\"       )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/probability-of-go.html","id":"decision-criteria","dir":"Articles > Web_only","previous_headings":"","what":"Decision criteria","title":"Application to Probability of 'go'","text":"Let \\(D_t \\\\mathbb{D}\\) observed (visit) data time point \\(t\\) start trial. Let \\(\\tau\\) stopping time trial, e.g., time point \\(n\\) individuals recruited reached minimal follow-. final decision ‚Äògo‚Äô can modeled function \\(\\phi: \\mathbb{D} \\\\{0,1\\}\\) \\[\\phi(D_\\tau)=1 :\\Leftrightarrow D_\\tau\\ \\ \\text{leads 'go'}\\ . \\] Examples decision rules quantile posterior distribution response rate certain relevance threshold, quantile posterior distribution PFS6 rate certain relevance threshold, quantile posterior distribution PFS certain threshold, combination .","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/probability-of-go.html","id":"probability-of-go","dir":"Articles > Web_only","previous_headings":"","what":"Probability of ‚Äògo‚Äô","title":"Application to Probability of 'go'","text":"Let \\(\\theta\\) vector parameters generative model allows sample data \\(D_\\tau|\\theta\\). Probability ‚Äògo‚Äô can calculated expected value decision rule prior distribution (density) \\(f(\\theta)\\) parameter space: \\[ \\operatorname{Pr}\\big[\\,go\\,\\big] = \\int \\phi(D_\\tau\\,|\\,\\theta) \\cdot f(\\theta) \\operatorname{d}\\theta \\ . \\] practice, integral can approximated sampling generative model calculating average ‚Äògo‚Äô rate. data \\(D_t=d_t\\) observed, probability ‚Äògo‚Äô can updated using Bayes Theorem \\[ \\operatorname{Pr}\\big[\\,go\\,|\\, D_t=d_t \\,\\big] = \\int \\phi(D_\\tau\\,|\\,D_t=d_t,\\theta) \\cdot f(\\theta\\,|\\,D_t=d_t) \\operatorname{d}\\theta \\] \\(f(\\theta\\,|\\,D_t=d_t)\\) posterior density given data \\(d_t\\) observed time \\(t\\).","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/probability-of-go.html","id":"example","dir":"Articles > Web_only","previous_headings":"","what":"Example","title":"Application to Probability of 'go'","text":"","code":"mdl <- create_srp_model(   A = srp_group_prior(     p_mean = 0.5, p_n = 3, p_eta = 0.2,     recruitment_rate = 2   ) ) smpl_prior <- sample_prior(mdl, seed = 6835L)  plot(mdl, parameter_sample = smpl_prior, confidence = 0.9)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/probability-of-go.html","id":"orr-and-pfs-go-criterion","dir":"Articles > Web_only","previous_headings":"Example","what":"ORR and PFS ‚Äògo‚Äô criterion","title":"Application to Probability of 'go'","text":"Assume ‚Äògo‚Äô defined combination sufficiently high response rate sufficiently high progression-free-survival rate 12 months: \\[\\phi(D_\\tau) := \\begin{cases}   1 \\quad \\text{} \\quad \\operatorname{Pr}\\big[\\,\\text{ORR} \\geq 0.3\\ \\&\\ \\text{PFS}_{t=12} \\geq 0.4 \\, | \\, D_\\tau\\,\\big] \\geq 0.8 \\\\   0 \\quad \\text{else.}   \\end{cases}\\] decision criterion can implemented following function: criterion can tested sampling model fixed, favorable parameters - clearly expect ‚Äògo‚Äô.","code":"go <- function(model, data, nsim = 200L) {   set.seed(3819308) # fix the seed for reproducibility   smpl <- suppressWarnings( # low sample size leads to stan warnings on ESS                             # can be ignored, errors average out                             # can also be avoided by increasing nsim     sample_posterior(model, data = data, warmup = 200L, nsim = nsim)   )   tbl_pfs_orr <- inner_join(     compute_pfs(model, 12, smpl), # PFS 12     parameter_sample_to_tibble(model, smpl) %>% # ORR       filter(parameter == \"p\") %>%       transmute(iter = 1:nsim, group_id, orr = value),     by = c(\"iter\", \"group_id\")   )   res <- tbl_pfs_orr %>% # apply decision criterion     group_by(group_id) %>%     summarize(       go = mean(pfs >= 0.5 & orr >= 0.3) >= 0.8     )   return(res) } tbl_prior_predictive <- sample_predictive(     mdl,     n_per_group = 40L,     sample = smpl_prior,     p = 1,      shape = matrix(c(1, 1, 1), ncol = 3),      # median = scale * log(2)^(1/shape)     scale = matrix(c(4, 2, 24), ncol = 3) / log(2),     nsim = 1L,     seed = 34930L   )  tbl_prior_predictive %>%    visits_to_mstate(mdl) %>%    plot_mstate(mdl, relative_to_sot = FALSE) go(mdl, tbl_prior_predictive) #> # A tibble: 1 √ó 2 #>   group_id go    #>   <chr>    <lgl> #> 1 A        TRUE"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/probability-of-go.html","id":"calculating-go-probability","dir":"Articles > Web_only","previous_headings":"","what":"Calculating ‚Äògo‚Äô probability","title":"Application to Probability of 'go'","text":"Next, can create table multiple prior-predictive samples. Grouping iteration nesting data frames results data frame data frames, tbl_prior_predictive$data[[]] corresponds data \\(\\)-th resample. Applying decision criterion averaging iterations MCMC approximation probability ‚Äògo‚Äô. functionality available function oncomsm::simulate_decision_rule.","code":"tbl_prior_predictive <- sample_predictive(     mdl,     n_per_group = 40L,     sample = smpl_prior,     p = 0.6,      shape = matrix(c(1, 1, 1), ncol = 3),      # median = scale * log(2)^(1/shape)     scale = matrix(c(3, 12, 24), ncol = 3) / log(2),     nsim = 100L,     seed = 34930L   ) %>%   group_by(iter) %>%   tidyr::nest() %>%   ungroup()  print(tbl_prior_predictive) #> # A tibble: 100 √ó 2 #>     iter data                 #>    <int> <list>               #>  1     1 <tibble [1,600 √ó 4]> #>  2     2 <tibble [1,686 √ó 4]> #>  3     3 <tibble [1,083 √ó 4]> #>  4     4 <tibble [1,205 √ó 4]> #>  5     5 <tibble [911 √ó 4]>   #>  6     6 <tibble [1,104 √ó 4]> #>  7     7 <tibble [1,200 √ó 4]> #>  8     8 <tibble [1,441 √ó 4]> #>  9     9 <tibble [1,518 √ó 4]> #> 10    10 <tibble [1,059 √ó 4]> #> # ‚Ä¶ with 90 more rows # compute results in parallel res <- foreach(i = seq_len(nrow(tbl_prior_predictive))) %dorng% {   go(mdl, tbl_prior_predictive$data[[i]]) }  # bind results together and aggregate to probability of 'go' tbl_pr_go <- bind_rows(res, .id = \"iter\") %>%   group_by(group_id) %>%   summarize(     `Pr[go]` = mean(go),     se  = sd(go) / sqrt(n())   )  print(tbl_pr_go) #> # A tibble: 1 √ó 3 #>   group_id `Pr[go]`    se #>   <chr>       <dbl> <dbl> #> 1 A            0.99  0.01 simulate_decision_rule(mdl, 40L, go, nsim = 100L, seed = 324879) %>%    group_by(group_id) %>%   summarize(     `Pr[go]` = mean(go),     se  = sd(go) / sqrt(n())   )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/probability-of-go.html","id":"probability-of-go-during-a-trial","dir":"Articles > Web_only","previous_headings":"","what":"Probability of ‚Äògo‚Äô during a trial","title":"Application to Probability of 'go'","text":"Bayesian generative model allows calculating posterior distribution time point given data observed point. future course trial can sampled posterior predictive distribution. illustrate shift ‚Äògo‚Äô probability time, single trial realization set fixed response probabilities conflict prior mean sampled hypothetical data. data accrues, evidence lead shift posterior probability thus probability ‚Äògo‚Äô. just take first sampled trial ground truth. Next, interim views full data set sequence time points can created. data subsets correspond data available potential interim analyses. can compared number available responses, progressions, stable individuals time point.  interim data set, remainder trial can imputed sampling form posterior-predictive distribution given data observed point. probability ‚Äògo‚Äô average ‚Äògo‚Äô rate posterior predictive sample applying decision criterion. First, calculation probability ‚Äògo‚Äô wrapped function accepts dataset (tbl) number resamples (nsim). wrapper around oncomsm::simulate_decision_rule Next, function mapped interim time points respective interim data. number simulations main factor determining runtime program besides number samples drawn posterior distribution evaluate decision criterion. change ‚Äògo‚Äô probability time shown error bars corresponding standard error simulation.","code":"tbl_data <- tbl_prior_predictive$data[[1]] tbl_data_interims <- tibble(     t_interim = c(1, 3, 6, 9, 12, 18, 24) # interim time point (months)   ) %>%   mutate(     data = purrr::map(t_interim, ~filter(tbl_data, t <= .))   )  print(tbl_data_interims) #> # A tibble: 7 √ó 2 #>   t_interim data               #>       <dbl> <list>             #> 1         1 <tibble [2 √ó 4]>   #> 2         3 <tibble [10 √ó 4]>  #> 3         6 <tibble [37 √ó 4]>  #> 4         9 <tibble [76 √ó 4]>  #> 5        12 <tibble [131 √ó 4]> #> 6        18 <tibble [311 √ó 4]> #> 7        24 <tibble [527 √ó 4]> f <- function(tbl) {   tbl %>%   group_by(group_id, subject_id) %>%   summarize(     status = {       if (all(state == \"stable\")) {         \"stable\"       } else {         state[which(state != \"stable\")[1]]       }     },     .groups = \"drop_last\"   ) %>%    group_by(group_id, status) %>%    summarize(n = n(), .groups = \"drop\") }  tibble(   t_interim = tbl_data_interims$t_interim,   summary = purrr::map(tbl_data_interims$data, f) ) %>% unnest(summary) %>%  ggplot() +   aes(t_interim, n, color = status) +   geom_step() +   geom_point() +   scale_x_continuous(\"t [months]\", breaks = seq(0, 36, by = 6)) +   scale_y_continuous(\"\", breaks = seq(0, 30, by = 5)) pr_go <- function(tbl, model, nsim = 100L) {   tbl_pr_go <- simulate_decision_rule(mdl, 40, go, data = tbl,                                       nsim = nsim, seed = 27307) %>%      group_by(group_id) %>%     summarize(       `Pr[go]` = mean(go),       se  = sd(go) / sqrt(n())     )   return(tbl_pr_go) } tbl_pr_go_over_time <- tbl_data_interims %>%   mutate(     res = purrr::map(data, pr_go, nsim = 33L)   ) %>%   tidyr::unnest(res)  tbl_pr_go_over_time #> # A tibble: 7 √ó 5 #>   t_interim data               group_id `Pr[go]`     se #>       <dbl> <list>             <chr>       <dbl>  <dbl> #> 1         1 <tibble [2 √ó 4]>   A           0.152 0.0634 #> 2         3 <tibble [10 √ó 4]>  A           0.273 0.0787 #> 3         6 <tibble [37 √ó 4]>  A           0.515 0.0883 #> 4         9 <tibble [76 √ó 4]>  A           0.758 0.0758 #> 5        12 <tibble [131 √ó 4]> A           0.970 0.0303 #> 6        18 <tibble [311 √ó 4]> A           1     0      #> 7        24 <tibble [527 √ó 4]> A           1     0 t_last_patient_follow_up <- tbl_data %>%   visits_to_mstate(mdl) %>%   pull(t_sot) %>%   max() + 3 # assuming minimal follow-up of three months ggplot(tbl_pr_go_over_time) +   aes(t_interim) +   geom_errorbar(aes(ymin = `Pr[go]` - se, ymax = `Pr[go]` + se), width = 1) +   geom_line(aes(y = `Pr[go]`), alpha = 0.33) +   geom_vline(xintercept = t_last_patient_follow_up) +   scale_x_continuous(\"t [months]\", breaks = seq(0, 36, by = 6)) +   scale_y_continuous(breaks = seq(0, 1, by = 0.1), limits = c(0, 1))"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kevin Kunzmann. Author, maintainer. Karhtik Ananthakrishnan. Contributor. Boehringer Ingelheim Ltd.. Copyright holder, funder.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kunzmann K (2022). oncomsm: Bayesian Multi-State Models Early Oncology. https://boehringer-ingelheim.github.io/oncomsm/, https://github.com/Boehringer-Ingelheim/oncomsm.","code":"@Manual{,   title = {oncomsm: Bayesian Multi-State Models for Early Oncology},   author = {Kevin Kunzmann},   year = {2022},   note = {https://boehringer-ingelheim.github.io/oncomsm/, https://github.com/Boehringer-Ingelheim/oncomsm}, }"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"bayesian-multi-state-models-for-early-oncology","dir":"","previous_headings":"","what":"Bayesian Multi-State Models for Early Oncology","title":"Bayesian Multi-State Models for Early Oncology","text":"R package oncomsm implements methods dynamically predict response progression individuals early oncology trials using parametric multi-state models Bayesian inference. allows dynamic computation ‚Äúprobability success‚Äù wide range success (‚Äúgo‚Äù) criteria. instance, bhmbasket R package can used define study success based Bayesian hierarchical models.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bayesian Multi-State Models for Early Oncology","text":"","code":"# install.packages(\"remotes\") remotes::install_github(\"https://github.com/Boehringer-Ingelheim/oncomsm\")"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Bayesian Multi-State Models for Early Oncology","text":"package documentation hosted .","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Bayesian Multi-State Models for Early Oncology","text":"See contributing guidelines.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/Model.html","id":null,"dir":"Reference","previous_headings":"","what":"An abstract multi-state model class ‚Äî Model","title":"An abstract multi-state model class ‚Äî Model","text":"abstract class defining standard set methods implemented multi-state model. Objects class 'Model' instantiated directly, objects respective sub-classes can .","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/Model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An abstract multi-state model class ‚Äî Model","text":"","code":"# S3 method for Model format(x, ...)  # S3 method for Model print(x, ...)  # S3 method for Model sample_prior(   model,   nsim = 2000L,   seed = NULL,   warmup = 500L,   pars = attr(model, \"parameter_names\"),   nuts_control = list(),   ... )  # S3 method for Model sample_posterior(   model,   data,   nsim = 2000L,   seed = NULL,   warmup = 500L,   nuts_control = list(),   pars = attr(model, \"parameter_names\"),   ... )  # S3 method for Model sample_predictive(   model,   n_per_group,   sample = NULL,   nsim = 100L,   seed = NULL,   nsim_parameters = 1000L,   warmup_parameters = 250,   as_mstate = FALSE,   nuts_control = list(),   ... )  # S3 method for Model impute(   model,   data,   nsim,   n_per_group = NULL,   now = NULL,   seed = NULL,   recruitment_rates = model$recruitment_rate,   sample = NULL,   nsim_parameters = 1000L,   warmup_parameters = 250L,   nuts_control = list(),   ... )  # S3 method for Model parameter_sample_to_tibble(model, sample, ...)  # S3 method for Model plot_transition_times(model, parameter_sample, ...)  # S3 method for Model plot_response_probability(model, parameter_sample, ...)  # S3 method for Model plot_pfs(model, parameter_sample, ...)  # S3 method for Model plot_mstate(data, model, now, relative_to_sot, ...)  # S3 method for Model compute_pfs(model, t, parameter_sample, ...)  # S3 method for Model visits_to_mstate(   tbl_visits,   model,   now = max(tbl_visits$t),   eof_indicator = \"EOF\" )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/Model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"An abstract multi-state model class ‚Äî Model","text":"x Model print ... arguments passed method implementations model model class \"Model\" nsim number samples draw seed integer, fixed random seed; NULL fixed seed warmup integer, number warmup samples rstan sampler retaining samples; used tune hyperparameters MCMC algorithm. pars character vector parameter names sample; resorting model defaults NULL nuts_control control parameters NUTS algorithm see rstan::stan() data data frame variables \"subject_id\", \"group_id\", \"t_recruitment\", \"dt1\" \"dt2\" dt1 minimal dt2 maximal time event question. Inf, individual never experience event. dt1 < Inf dt2 == Inf individual still risk. \"t_recruitment\", \"dt1\" \"dt2\" can also missing individual yet recruited. n_per_group integer vector number individuals per group. sample stanfit object containing samples. parameter samples represent parameter distribution predictive distribution averages. Technically, parameters resampled replacement sample match desired number imputations. nsim_parameters integer, number parameter samples warmup_parameters integer, number warmup samples rstan sampler retaining samples parameters. as_mstate return data multi-state forma, see visits_to_mstate() now exact time point relative start trial recruitment_rates vector recruitment rates parameter_sample stanfit object samples respective model. relative_to_sot Boolean, timeline relative start trial start treatment individual t vector time-points PFS rate computed tbl_visits visit data long format eof_indicator state name indicating (exactly observed) end follow .","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from the progression-free-survival rate ‚Äî compute_pfs","title":"Sample from the progression-free-survival rate ‚Äî compute_pfs","text":"Progression-free-survival rate time t (PFS-t rate) function parameters given multi-state model. Hence prior posterior sample model gives rise sample corresponding PFS t rate.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from the progression-free-survival rate ‚Äî compute_pfs","text":"","code":"compute_pfs(model, t, parameter_sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from the progression-free-survival rate ‚Äî compute_pfs","text":"model model class \"Model\" t vector time-points PFS rate computed parameter_sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from the progression-free-survival rate ‚Äî compute_pfs","text":"data frame samples PFS rates time points vector t.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute data from predictive distribution ‚Äî impute","title":"Impute data from predictive distribution ‚Äî impute","text":"parameter sample provided, sample posterior predictive","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute data from predictive distribution ‚Äî impute","text":"","code":"impute(model, data, nsim, n_per_group, now, seed, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute data from predictive distribution ‚Äî impute","text":"model model class \"Model\" data (multi-state) data frame impute trajectories . nsim number samples draw n_per_group number individuals per group recruited. now exact time point relative start trial seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute data from predictive distribution ‚Äî impute","text":"data frame imputed version input data.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/oncomsm-package.html","id":null,"dir":"Reference","previous_headings":"","what":"The oncomsm package. ‚Äî oncomsm-package","title":"The oncomsm package. ‚Äî oncomsm-package","text":"package implements methods dynamically predict response progression individuals early oncology trials using parametric multi-state models Bayesian inference. allows dynamic computation Probability Success wide range success criteria. inference implemented using stan.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/oncomsm-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The oncomsm package. ‚Äî oncomsm-package","text":"Stan Development Team (2021). RStan: R interface Stan. R package version 2.21.3. https://mc-stan.org","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","title":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","text":"Convert stanfit sample data table","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","text":"","code":"parameter_sample_to_tibble(model, sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","text":"model model class \"Model\" sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","text":"tibble sampled parameters long format","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":null,"dir":"Reference","previous_headings":"","what":"Swimmer-like plot of multi-state data ‚Äî plot_mstate","title":"Swimmer-like plot of multi-state data ‚Äî plot_mstate","text":"Swimmer-like plot multi-state data","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swimmer-like plot of multi-state data ‚Äî plot_mstate","text":"","code":"plot_mstate(data, model, now, relative_to_sot, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Swimmer-like plot of multi-state data ‚Äî plot_mstate","text":"data data table multi-state data model model class \"Model\" now current time relative start trial (sot) relative_to_sot Boolean, timeline relative start trial start treatment individual ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_pfs.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the progression-free-survival function of a model ‚Äî plot_pfs","title":"Plot the progression-free-survival function of a model ‚Äî plot_pfs","text":"Plot progression-free-survival function model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_pfs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the progression-free-survival function of a model ‚Äî plot_pfs","text":"","code":"plot_pfs(model, parameter_sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_pfs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the progression-free-survival function of a model ‚Äî plot_pfs","text":"model model class \"Model\" parameter_sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_response_probability.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the response probability distributions of a model ‚Äî plot_response_probability","title":"Plot the response probability distributions of a model ‚Äî plot_response_probability","text":"Plot response probability distributions model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_response_probability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the response probability distributions of a model ‚Äî plot_response_probability","text":"","code":"plot_response_probability(model, parameter_sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_response_probability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the response probability distributions of a model ‚Äî plot_response_probability","text":"model model class \"Model\" parameter_sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_transition_times.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the transition time distributions of a model ‚Äî plot_transition_times","title":"Plot the transition time distributions of a model ‚Äî plot_transition_times","text":"Plot transition time distributions model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_transition_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the transition time distributions of a model ‚Äî plot_transition_times","text":"","code":"plot_transition_times(model, parameter_sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_transition_times.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the transition time distributions of a model ‚Äî plot_transition_times","text":"model model class \"Model\" parameter_sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample model posterior parameters ‚Äî sample_posterior","title":"Sample model posterior parameters ‚Äî sample_posterior","text":"Posterior sample model parameters conditional data set.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample model posterior parameters ‚Äî sample_posterior","text":"","code":"sample_posterior(model, data, nsim, seed, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample model posterior parameters ‚Äî sample_posterior","text":"model model class \"Model\" data data frame variables \"subject_id\", \"group_id\", \"t_recruitment\", \"dt1\" \"dt2\" dt1 minimal dt2 maximal time event question. Inf, individual never experience event. dt1 < Inf dt2 == Inf individual still risk. \"t_recruitment\", \"dt1\" \"dt2\" can also missing individual yet recruited. nsim number samples draw seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample model posterior parameters ‚Äî sample_posterior","text":"rstanfit object posterior samples.","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data from predictive distribution of a model ‚Äî sample_predictive","title":"Sample data from predictive distribution of a model ‚Äî sample_predictive","text":"Sample data predictive distribution model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data from predictive distribution of a model ‚Äî sample_predictive","text":"","code":"sample_predictive(model, n_per_group, sample, nsim, seed, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample data from predictive distribution of a model ‚Äî sample_predictive","text":"model model class \"Model\" n_per_group integer vector number individuals per group. sample stanfit object samples respective model. nsim number samples draw seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample data from predictive distribution of a model ‚Äî sample_predictive","text":"TODO:","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample model prior parameters ‚Äî sample_prior","title":"Sample model prior parameters ‚Äî sample_prior","text":"Sample model parameters model prior distribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample model prior parameters ‚Äî sample_prior","text":"","code":"sample_prior(model, nsim, seed, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample model prior parameters ‚Äî sample_prior","text":"model model class \"Model\" nsim number samples draw seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample model prior parameters ‚Äî sample_prior","text":"rstanfit object sampled prior parameters","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/simulate_decision_rule.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate a custom decision rule ‚Äî simulate_decision_rule","title":"Simulate a custom decision rule ‚Äî simulate_decision_rule","text":"Simulate custom decision rule","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/simulate_decision_rule.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate a custom decision rule ‚Äî simulate_decision_rule","text":"","code":"simulate_decision_rule(   model,   n_per_group,   decision_rule,   data = NULL,   parameter_sample = NULL,   seed = NULL,   nsim = 1L )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/simulate_decision_rule.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate a custom decision rule ‚Äî simulate_decision_rule","text":"model model use sampling n_per_group group size decision_rule function signature rule(mdl, data, ...) returning data frame results applying decision rule data setdata, typically contains column group_id one column per decision/result. data data frame visit data condition parameter_sample optional parameter sample reuse seed optional fixed seed nsim number resamples draw predictive distribution","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/simulate_decision_rule.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate a custom decision rule ‚Äî simulate_decision_rule","text":"data frame columns iter (resample index) columns returned decision_rule applied nsim datasets sampled predictive distribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine SRP group priors to model object ‚Äî srp_model","title":"Combine SRP group priors to model object ‚Äî srp_model","text":"function takes one prior-specifications SRP multi-state model combines joint model. Groups still treated independent. function takes one prior-specifications SRP multi-state model combines joint model. Groups still treated independent.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine SRP group priors to model object ‚Äî srp_model","text":"","code":"srp_group_prior(   p_mean = 0.5,   p_n = 3,   p_eta = 0,   p_min = 0,   p_max = 1,   median_t_q05 = c(1, 1, 3),   median_t_q95 = c(12, 12, 24),   shape_q05 = c(0.99, 0.99, 0.99),   shape_q95 = c(1.01, 1.01, 1.01),   visit_spacing = 1,   recruitment_rate = 1 )  create_srp_model(..., maximal_time = 10 * 12)  # S3 method for srp_model format(x, ...)  # S3 method for srp_model visits_to_mstate(   tbl_visits,   model,   now = max(tbl_visits$t),   eof_indicator = \"EOF\" )  # S3 method for srp_model compute_pfs(   model,   t,   parameter_sample = NULL,   warmup = 500L,   nsim = 1000L,   seed = NULL,   ... )  # S3 method for srp_model plot_mstate(   data,   model,   now = max(tbl_mstate$t_max),   relative_to_sot = TRUE,   ... )  # S3 method for srp_model plot_transition_times(   model,   parameter_sample = NULL,   seed = 42L,   nsim = 500L,   warmup = 250,   nuts_control = list(),   dt_interval = NULL,   dt_n_grid = 25,   dt_expand = 1.1,   dt_grid = NULL,   confidence = NULL,   ... )  # S3 method for srp_model plot_response_probability(   model,   parameter_sample = NULL,   seed = 42L,   nsim = 500L,   warmup = 250,   nuts_control = list(),   ... )  # S3 method for srp_model plot_pfs(   model,   parameter_sample = NULL,   seed = 42L,   nsim = 500L,   warmup = 250,   nuts_control = list(),   dt_interval = NULL,   dt_n_grid = 25,   dt_expand = 1.1,   dt_grid = NULL,   confidence = NULL,   ... )  # S3 method for srp_model plot(   x,   parameter_sample = NULL,   seed = 42L,   nsim = 500L,   warmup = 250,   nuts_control = list(),   dt_interval = NULL,   dt_n_grid = 25,   dt_expand = 1.1,   dt_grid = NULL,   confidence = NULL,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine SRP group priors to model object ‚Äî srp_model","text":"p_mean numeric, mean beta prior response probability p_n numeric, beta prior equivalent sample size (+ b) p_eta numeric, robustification parameter beta prior; actual prior (1 - eta) beta + eta; .e., eta non-informative weight. p_min numeric, minimal response probability p_max numeric, maximal response probability median_t_q05 numeric length three, 5% quantiles log-normal distributions median time--next-event three transitions s->r, s->p, r->p. median_t_q95 numeric length three, 95% quantiles log-normal distributions median time--next-event three transitions s->r, s->p, r->p. shape_q05 numeric length three, 5% quantiles log-normal distributions shapes time--next-event distributions three transitions s->r, s->p, r->p. shape_q95 numeric length three, 95% quantiles log-normal distributions shapes time--next-event distributions three transitions s->r, s->p, r->p. visit_spacing numeric, fixed duration visits recruitment_rate numeric, constant recruitment rate ... arguments passed method implementations maximal_time maximal overall runtime trial measured first visit group. visits past point sampled. x model plot tbl_visits visit data long format model multi-state model object now time point since start trial (might later last recorded visit) eof_indicator state name indicating (exactly observed) end follow . t vector time-points PFS rate computed parameter_sample stanfit object samples respective model. warmup integer, number warmup samples rstan sampler retaining samples; used tune hyperparameters MCMC algorithm. nsim number samples draw seed integer, fixed random seed; NULL fixed seed data data table multi-state data relative_to_sot Boolean, timeline relative start trial start treatment individual nuts_control control parameters NUTS algorithm see rstan::stan() dt_interval numeric vector length two minimal maximal time (relative individual first visit) use plotting dt_n_grid number grid points use automatically choosing plotting interval dt_expand expansion factor upper plotting limit using automatic interval detection dt_grid numeric vector time points use plotting confidence numeric (0, 1) confidence level point-wise confidence bands around mean; none plotted NULL.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine SRP group priors to model object ‚Äî srp_model","text":"object type srp_group_prior holding prior information list-like structure; visit_spacing recruitment_rate accessible attributes. object class srp_model; named list group_ids, maximal time, visit spacing, recruitment rate, list prior parameters response probability, median transition times, shape transition time distribution (Weibull)","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert cross sectional visit data to time-to-event data ‚Äî visits_to_mstate","title":"Convert cross sectional visit data to time-to-event data ‚Äî visits_to_mstate","text":"function assumes visit density high enough miss transient state jumps.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert cross sectional visit data to time-to-event data ‚Äî visits_to_mstate","text":"","code":"visits_to_mstate(   tbl_visits,   model,   now = max(tbl_visits$t),   eof_indicator = \"EOF\" )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert cross sectional visit data to time-to-event data ‚Äî visits_to_mstate","text":"tbl_visits visit data long format model multi-state model object now time point since start trial (might later last recorded visit) eof_indicator state name indicating (exactly observed) end follow .","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert cross sectional visit data to time-to-event data ‚Äî visits_to_mstate","text":"data frame","code":""}]
