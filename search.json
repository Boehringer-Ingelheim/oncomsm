[{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contribution Guidelines","title":"Contribution Guidelines","text":"üôè Thank taking time contribute! input deeply valued, whether issue, pull request, even feedback, regardless size, content scope.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"table-of-contents","dir":"","previous_headings":"","what":"Table of contents","title":"Contribution Guidelines","text":"üóÉ License üìú Issues üö© Pull requests üëó Style guide üèÜ Recognition model ‚ùì Questions","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Contribution Guidelines","text":"contributions covered project‚Äôs license.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"Contribution Guidelines","text":"use GitHub track issues, feature requests, bugs. submitting new issue, please check issue already reported. issue already exists, please upvote existing issue üëç. reporting bug, please try specific possible describing provide minimal reproducible example (possible). new feature requests, please elaborate context benefit feature users, developers, relevant personas.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"proposing-changes-to-the-code","dir":"","previous_headings":"","what":"Proposing changes to the code","title":"Contribution Guidelines","text":"repository uses Github flow model collaboration. submit pull request: Create branch. Please see branch naming convention . don‚Äôt write access repository, please fork . Make changes. Make sure code: passes checks imposed GitHub Actions well documented well tested unit tests sufficiently covering changes introduced Create pull request (PR). pull request description, please link relevant issue (), provide detailed description change, include assumptions. Address review comments, (let reviewer know). Receive approval. Merge PR write access. Otherwise, reviewer merge PR behalf. Pat back. Congratulations! üéâ now official contributor project! grateful contribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"style-guide","dir":"","previous_headings":"","what":"Style guide","title":"Contribution Guidelines","text":"repository follows standard tidyverse style guide uses lintr lint checks. Customized lint configurations available repository‚Äôs .lintr file.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"updating-stan-models","dir":"","previous_headings":"","what":"Updating stan models","title":"Contribution Guidelines","text":"stan models contained inst/stan automatically updated avoid taking dependency rstantools package. modifying adding new models, run silence R/stanmodels.R via capture.output().","code":"rstantools::rstan_config()"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"recognition-model","dir":"","previous_headings":"","what":"Recognition model","title":"Contribution Guidelines","text":"currently formal recognition model place. expect recognition certain kind contribution, make sure clarify package maintainer advance.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"questions","dir":"","previous_headings":"","what":"Questions","title":"Contribution Guidelines","text":"questions regarding contribution guidelines, please contact package/repository maintainer.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"specifying-the-model","dir":"Articles","previous_headings":"","what":"Specifying the model","title":"Multi-State Models for Oncology","text":"following code defined prior assumptions two-group trial visit-spacing 1 months. prior variance shape parameter low. sampling prior, matter uncertainty Weibull shape parameters can assumed. posterior inference, identifying shape scale (median time event) small sample interval censored observations feasible leads divergent MCMC samples. shape thus kept almost fixed cases inference. model assumptions can visualized sampling prior.","code":"mdl <- create_srpmodel(   A = define_srp_prior(     p_mean = 0.4, p_n = 10,     median_t_q05 = c(3, 2, 6) - 1, # s->r s->p r->p     median_t_q95 = c(3, 2, 6) + 1   ),   B = define_srp_prior(     p_mean = 0.6, p_n = 10,     median_t_q05 = c(2, 8, 3) - 1, # s->r s->p r->p     median_t_q95 = c(2, 8, 12) + 1,     shape_q05 = c(2, 2, 0.75),     shape_q95 = c(2.1, 2.1, 0.76)   ) )  print(mdl) #> srpmodel<A,B>"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"prior-checks","dir":"Articles","previous_headings":"","what":"Prior checks","title":"Multi-State Models for Oncology","text":"First, plot cumulative distribution functions (CDF) time--next-event first 36 (months) CDF response probabilities per group. based sample drawn prior distribution model. can re-use parameter sample sampling prior-predictive distribution separating sampling plotting steps. Often, rate progression free survival (PFS) particular time point interest. quantity direct function model parameters. Since simplified model distinguish progression death, denote combined endpoint ‚Äúprogression‚Äù. \\[ \\begin{align} \\operatorname{PFS}(t) :&= \\operatorname{Pr}\\big[\\,\\text{progression } t\\,\\big] \\\\   &= 1 - \\operatorname{Pr}\\big[\\,\\text{progression } t\\,] \\\\   &= 1 - \\Big(\\ \\operatorname{Pr}\\big[\\,\\text{progression } t\\,|\\, \\text{response}\\,]\\cdot\\operatorname{Pr}\\big[\\,\\text{response}\\,] \\\\   &\\qquad+ \\operatorname{Pr}\\big[\\,\\text{progression } t\\,|\\, \\text{response}\\,]\\cdot\\operatorname{Pr}\\big[\\,\\text{response}\\,] \\ \\Big)\\\\   &= 1 - p\\cdot\\int_0^t f_1(u) \\cdot F_3(t - u) \\operatorname{d}u - (1 - p)\\cdot F_2(t) \\ . \\end{align} \\] integral arises need reflect uncertainty state change ‚Äústable‚Äù ‚Äúresponse‚Äù way ‚Äúprogression‚Äù. parameter sample thus also induces sample PFS rate given time point curve PFS rate time corresponds survival function ‚Äúprogression death‚Äù event.","code":"smpl_prior <- sample_prior(mdl, seed = 36L)  # plot(mdl) also works but need to resample prior further below plot(mdl, parameter_sample = smpl_prior, confidence = 0.75)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"sampling-from-the-prior-predictive-distribution","dir":"Articles","previous_headings":"","what":"Sampling from the prior-predictive distribution","title":"Multi-State Models for Oncology","text":"Next, draw samples prior-predictive distribution model. sample 100 trials 30 individuals per arm. , can re-use sample prior sample already used plotting. can run quick checks sampled data, e.g., observed response rates. crude approximation median transition times can compared prior means. default, prior predictive distribution given terms panel visit data. data can transformed interval-censored multi-state representation, (first sampled trial). multi-state data can visualized swimmer plots.  also possible simulate prior predictive distribution fixing parameter values. Fixing parameter values can interpreted conditioning parameters. instance one set response probabilities fixed values \\(0.1\\) \\(0.9\\):","code":"tbl_prior_predictive <- sample_predictive(   mdl,   sample = smpl_prior,   n_per_group = c(30L, 30L),   nsim = 100,   seed = 342 )  print(tbl_prior_predictive, n = 25) #> # A tibble: 58,525 √ó 5 #>    subject_id group_id     t state        iter #>    <chr>      <chr>    <dbl> <chr>       <int> #>  1 ID00010865 B         11.2 stable          1 #>  2 ID00010865 B         12.2 stable          1 #>  3 ID00010865 B         13.2 stable          1 #>  4 ID00010865 B         14.2 response        1 #>  5 ID00010865 B         15.2 response        1 #>  6 ID00010865 B         16.2 response        1 #>  7 ID00010865 B         17.2 response        1 #>  8 ID00010865 B         18.2 response        1 #>  9 ID00010865 B         19.2 response        1 #> 10 ID00010865 B         20.2 response        1 #> 11 ID00010865 B         21.2 response        1 #> 12 ID00010865 B         22.2 progression     1 #> 13 ID00019694 B         18.2 stable          1 #> 14 ID00019694 B         19.2 stable          1 #> 15 ID00019694 B         20.2 stable          1 #> 16 ID00019694 B         21.2 stable          1 #> 17 ID00019694 B         22.2 response        1 #> 18 ID00019694 B         23.2 response        1 #> 19 ID00019694 B         24.2 response        1 #> 20 ID00019694 B         25.2 response        1 #> 21 ID00019694 B         26.2 response        1 #> 22 ID00019694 B         27.2 progression     1 #> 23 ID00294641 B         23.8 stable          1 #> 24 ID00294641 B         24.8 stable          1 #> 25 ID00294641 B         25.8 progression     1 #> # ‚Ñπ 58,500 more rows tbl_prior_predictive %>%   group_by(group_id, iter, subject_id) %>%   summarize(     responder = any(state == \"response\"),     .groups = \"drop\"   ) %>%   group_by(group_id) %>%   summarize(     p_response = mean(responder),     se = sd(responder) / sqrt(n())   ) #> # A tibble: 2 √ó 3 #>   group_id p_response      se #>   <chr>         <dbl>   <dbl> #> 1 A             0.365 0.00879 #> 2 B             0.508 0.00913 tbl_prior_predictive %>%   distinct(subject_id, iter, state, .keep_all = TRUE) %>%   group_by(iter, group_id, subject_id) %>%   summarize(     dt = t - lag(t),     from = lag(state),     to = state,     .groups = \"drop\"   ) %>%   filter(to != \"stable\") %>%   group_by(group_id, from, to) %>%   summarize(     `median transition time` = median(dt),     .groups = \"drop\"   ) #> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in #> dplyr 1.1.0. #> ‚Ñπ Please use `reframe()` instead. #> ‚Ñπ When switching from `summarise()` to `reframe()`, remember that `reframe()` #>   always returns an ungrouped data frame and adjust accordingly. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #> # A tibble: 6 √ó 4 #>   group_id from     to          `median transition time` #>   <chr>    <chr>    <chr>                          <dbl> #> 1 A        response progression                        6 #> 2 A        stable   progression                        2 #> 3 A        stable   response                           3 #> 4 B        response progression                        7 #> 5 B        stable   progression                        7 #> 6 B        stable   response                           2 tbl_mstate <- tbl_prior_predictive %>%   filter(iter == 1) %>%   visits_to_mstate(mdl)  tbl_mstate #> # A tibble: 89 √ó 7 #>    subject_id group_id from     to          t_min t_max t_sot #>    <chr>      <chr>    <chr>    <chr>       <dbl> <dbl> <dbl> #>  1 ID00010865 B        stable   response    13.2  14.2  11.2  #>  2 ID00010865 B        response progression 21.2  22.2  11.2  #>  3 ID00019694 B        stable   response    21.2  22.2  18.2  #>  4 ID00019694 B        response progression 26.2  27.2  18.2  #>  5 ID00294641 B        stable   progression 24.8  25.8  23.8  #>  6 ID00559801 B        stable   response    26.9  27.9  22.9  #>  7 ID00559801 B        response progression 36.9  37.9  22.9  #>  8 ID00827488 A        stable   progression  7.19  8.19  7.19 #>  9 ID01007254 A        stable   progression 24.4  25.4  23.4  #> 10 ID01039842 A        stable   progression  1.45  2.45  1.45 #> # ‚Ñπ 79 more rows plot_mstate(tbl_mstate, mdl) sample_predictive(     mdl,     sample = smpl_prior,     p = c(0.1, 0.9),     n_per_group = c(30L, 30L),     nsim = 100,     seed = 3423423   ) %>%   group_by(group_id, iter, subject_id) %>%   summarize(     responder = any(state == \"response\"),     .groups = \"drop\"   ) %>%   group_by(group_id) %>%   summarize(     p_response = mean(responder),     se = sd(responder) / sqrt(n())   ) #> # A tibble: 2 √ó 3 #>   group_id p_response      se #>   <chr>         <dbl>   <dbl> #> 1 A             0.109 0.00570 #> 2 B             0.790 0.00743"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"a-hypothetical-interim-analysis","dir":"Articles","previous_headings":"","what":"A hypothetical interim analysis","title":"Multi-State Models for Oncology","text":"First, sample single data set extreme response probabilities deviate chosen prior. data can curtailed hypothetical interim time-point simply filtering visit time-points. censoring interim data can visualized swimmer plot .  can check observed response rates . Due censoring interim time point, response rate estimate biased. Instead, one can now inference drawing sample posterior distribution account censoring. Since data conflicts prior, posterior mass move direction observed response rates.  Alternatively, analysis also run using default weakly-informative prior. details prior choice, see corresponding vignette.","code":"tbl_data_interim <- sample_predictive(     mdl,     sample = smpl_prior,     p = c(0.2, 0.8),     n_per_group = c(30L, 30L),     nsim = 1,     seed = 42L   ) %>%   filter(     t <= 15   ) tbl_data_interim %>%   visits_to_mstate(mdl, now = 15) %>%   plot_mstate(mdl, relative_to_sot = FALSE, now = 15) tbl_data_interim %>%   group_by(group_id, iter, subject_id) %>%   summarize(     responder = any(state == \"response\"),     .groups = \"drop\"   ) %>%   group_by(group_id) %>%   summarize(     p_response = mean(responder),     se = sd(responder) / sqrt(n())   ) #> # A tibble: 2 √ó 3 #>   group_id p_response    se #>   <chr>         <dbl> <dbl> #> 1 A               0   0     #> 2 B               0.7 0.153 smpl_posterior <- sample_posterior(mdl, tbl_data_interim, seed = 43L) # plot under posterior plot(mdl, parameter_sample = smpl_posterior, confidence = 0.75) # calculate posterior quantiles of response probability smpl_posterior %>%   parameter_sample_to_tibble(mdl, .) %>%   filter(parameter == \"p\") %>%   group_by(group_id) %>%   summarize(     p_posterior_mean = median(value),     q25 = quantile(value, probs = .25),     q75 = quantile(value, probs = .75)   ) #> # A tibble: 2 √ó 4 #>   group_id p_posterior_mean   q25   q75 #>   <chr>               <dbl> <dbl> <dbl> #> 1 A                   0.293 0.212 0.384 #> 2 B                   0.678 0.602 0.747 mdl2 <- create_srpmodel(   A = define_srp_prior(),   B = define_srp_prior() ) smpl_posterior2 <- sample_posterior(mdl2, tbl_data_interim, seed = 43L) # plot under posterior plot(mdl2, parameter_sample = smpl_posterior2, confidence = 0.75) # calculate posterior quantiles of response probability smpl_posterior2 %>%   parameter_sample_to_tibble(mdl2, .) %>%   filter(parameter == \"p\") %>%   group_by(group_id) %>%   summarize(     p_posterior_mean = median(value),     q25 = quantile(value, probs = .25),     q75 = quantile(value, probs = .75)   ) #> # A tibble: 2 √ó 4 #>   group_id p_posterior_mean   q25   q75 #>   <chr>               <dbl> <dbl> <dbl> #> 1 A                   0.221 0.126 0.357 #> 2 B                   0.726 0.630 0.815"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Multi-State Models for Oncology","text":"","code":"sessionInfo() #> R version 4.2.3 (2023-03-15) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 22.04.2 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_3.4.2      dplyr_1.1.1        oncomsm_0.1.4.9000 #>  #> loaded via a namespace (and not attached): #>  [1] Rcpp_1.0.10          tidyr_1.3.0          listenv_0.9.0        #>  [4] visNetwork_2.1.2     prettyunits_1.1.1    ps_1.7.4             #>  [7] rprojroot_2.0.3      digest_0.6.31        utf8_1.2.3           #> [10] parallelly_1.35.0    R6_2.5.1             backports_1.4.1      #> [13] stats4_4.2.3         evaluate_0.20        highr_0.10           #> [16] pillar_1.9.0         rlang_1.1.0          furrr_0.3.1          #> [19] callr_3.7.3          jquerylib_0.1.4      checkmate_2.1.0      #> [22] DiagrammeR_1.0.9     rmarkdown_2.21       pkgdown_2.0.7        #> [25] labeling_0.4.2       textshaping_0.3.6    desc_1.4.2           #> [28] stringr_1.5.0        htmlwidgets_1.6.2    loo_2.6.0            #> [31] munsell_0.5.0        compiler_4.2.3       xfun_0.38            #> [34] rstan_2.21.8         pkgconfig_2.0.3      systemfonts_1.0.4    #> [37] pkgbuild_1.4.0       rstantools_2.3.1     globals_0.16.2       #> [40] htmltools_0.5.5      tidyselect_1.2.0     tibble_3.2.1         #> [43] gridExtra_2.3        codetools_0.2-19     matrixStats_0.63.0   #> [46] fansi_1.0.4          future_1.32.0        withr_2.5.0          #> [49] crayon_1.5.2         grid_4.2.3           jsonlite_1.8.4       #> [52] gtable_0.3.3         lifecycle_1.0.3      magrittr_2.0.3       #> [55] StanHeaders_2.21.0-7 scales_1.2.1         RcppParallel_5.1.7   #> [58] cli_3.6.1            stringi_1.7.12       cachem_1.0.7         #> [61] farver_2.1.1         fs_1.6.1             bslib_0.4.2          #> [64] ellipsis_0.3.2       ragg_1.2.5           generics_0.1.3       #> [67] vctrs_0.6.1          RColorBrewer_1.1-3   tools_4.2.3          #> [70] glue_1.6.2           purrr_1.0.1          processx_3.8.0       #> [73] parallel_4.2.3       fastmap_1.1.1        yaml_2.3.7           #> [76] RcppNumerical_0.5-0  inline_0.3.19        colorspace_2.1-0     #> [79] memoise_2.0.1        knitr_1.42           patchwork_1.1.2      #> [82] sass_0.4.5"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/prior-choice.html","id":"why-weibull-transition-times","dir":"Articles","previous_headings":"","what":"Why Weibull transition times?","title":"Prior Choice","text":"oncomsm, distributions -state transition times modeled Weibull distributions. restriction terms class distribution implicit prior transition times. rationale mainly due trade-model flexibility model complexity. Weibull family two parameter distribution family probability density function given \\[ f(t|,b) = \\frac b \\bigg(\\frac t b\\bigg)^{- 1} e^{-\\big(\\frac t b\\big)^} \\quad t > 0 \\] \\(\\) shape \\(b\\) scale parameter. corresponding hazard function given \\[ h(t|,b) = \\frac b \\bigg(\\frac t \\bigg)^{b - 1} \\ . \\] one-parameter exponential distribution recovered special case \\(b = 1\\). Weibull distribution family adds flexibility one important aspect since allows hazard rate either increasing (\\(b<1\\)) decreasing (\\(b>1\\)) time.  Combined three-state model, Weibull-model provides quite flexibility model different disease progression characteristics without increasing model complexity much. Compared exponential model, three-state Weibull model 7 instead 4 parameters. two-parameter survival distributions like log-normal Gamma distribution equally viable characteristics hazard functions either intricate (non-monotonous) less flexible Weibull distribution. Additionally, Weibull distribution distribution can interpreted terms proportional hazards accelerated failure times. Note covariate modeling yet implemented oncomsm. Realistically, proper model selection identification complex patterns hazard function unfeasible small sample sizes. Weibull distribution primarily chosen due intuitive interpretation parameters. settings larger sample sizes model selection feasible. flexsurv package covers large number common parametric survival models supports multi-state models well.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/prior-choice.html","id":"parameterization-and-prior-classes","dir":"Articles","previous_headings":"","what":"Parameterization and prior classes","title":"Prior Choice","text":"scale shape interest. Hence, reference prior Weibull distribution proportional \\(1/(\\, b)\\) (see, note non-informative priors Weibull distributions). differentiable re-parameterization \\(g^{-1}:g(,b)\\mapsto (,b)\\) Jacobian absolute determinant \\(1/(\\,b)\\) thus leads (improper) uniform reference prior via pull-back reference prior \\((,b)\\). transformation given \\[ g^{-1}(, b) = \\Bigg(\\ \\log\\bigg(\\ \\underbrace{\\log(2)^{1/b}}_{\\text{median}} \\ \\bigg),\\ \\log(b) \\ \\Bigg) \\] transforms scale \\(\\) shape \\(b\\) log-median log-shape Jacobian \\[ \\begin{pmatrix}   \\frac 1 & - \\frac{\\log(\\log(2))}{b^2} \\\\   0 & \\frac 1 b \\end{pmatrix} \\] thus determinant \\(1/(\\,b)\\). sense, median log-shape natural parameterization Weibull distribution since reference Jeffreys prior coincide (improper) uniform distribution parameter space. practical benefit using median instead raw scale parameter direct interpretation practitioners. stabilize inference settings little data, often advisable use weakly informative priors instead completely non-informative ones. one willing specify first two moments distribution \\(\\mathbb{R}^2\\), normal distribution unique maximum entropy distribution. Assuming independence shape median, implies log-normal priors shape median natural weakly-informative class priors Weibull distribution. response probability \\(p\\), mixture prior consisting \\(\\operatorname{Beta}(\\alpha,\\beta)\\) component weight \\(1-\\eta\\) uniform component, \\(\\operatorname{Beta}(1,1)\\), weight \\(\\eta\\) suggested.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/prior-choice.html","id":"choice-of-hyperparameters","dir":"Articles","previous_headings":"","what":"Choice of hyperparameters","title":"Prior Choice","text":"Directly specifying mean variance lognormal priors shape median time event can unintuitive. Instead, \\(0.05\\) \\(0.95\\) quantiles median shape can specified. two constraints sufficient identify mean variance parameters log-normal distribution. , instance, little known median time response implausible median lower 1 greater 36 months, lognormal prior median time response depicted following plot.  default vague prior median time next event three transitions. choice prior shape difficult since shape parameter harder identify (interval censored) data points per transition. avoid convergence issues oncomsm uses default lognormal prior 5% quantile 0.9 95% quantile 2.5. changes hazards time expected, can make sense relax prior risk divergent transitions sampling. small number divergent transitions can usually tolerated (default: 10%). practice, always possible reduce prior variability post-hoc fine-tune MCMC parameters obtain stable inference[https://mc-stan.org/docs/2_19/reference-manual/divergent-transitions]. following plot shows variability shape fixed scale default prior.  resulting Weibull density  sample joint prior reflects overall variability.","code":"res <- oncomsm:::get_mu_sigma(1, 36) median_transition_time <- t tibble(   median_transition_time = median_transition_time,   pdf = dlnorm(median_transition_time, res$mu, res$sigma) ) %>% ggplot() +   aes(median_transition_time, pdf) +   geom_line() res <- oncomsm:::get_mu_sigma(0.9, 2.5) shape <- seq(0, 5, length.out = 100) set.seed(251L) tibble(   b = rlnorm(100, res$mu, res$sigma),   a = 6 ) %>% expand_grid(t = t) %>% mutate(   survival = 1 - pweibull(t, b, a),   label = sprintf(\"a=%5.2f, b=%5.2f\", a, b) ) %>% ggplot() +   aes(t, survival, group = label) +   geom_line(alpha = .2) tibble(shape = shape, pdf = dlnorm(shape, res$mu, res$sigma)) %>% ggplot() +   aes(shape, pdf) +   geom_line() set.seed(251L) tibble(   b = rlnorm(100, oncomsm:::get_mu_sigma(0.75, 3)$mu,              oncomsm:::get_mu_sigma(0.75, 3)$sigma),   a = purrr::map_dbl(b, function(x) {       res <- oncomsm:::get_mu_sigma(2, 6)       rlnorm(1, res$mu, res$sigma) / log(2)^(1 / x)     }   ) ) %>% expand_grid(t = t) %>% mutate(   survival = 1 - pweibull(t, b, a),   label = sprintf(\"a=%5.2f, b=%5.2f\", a, b) ) %>% ggplot() +   aes(t, survival, group = label) +   geom_line(alpha = .2)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/bhmbasket-integration.html","id":"defining-go-decision","dir":"Articles > Web_only","previous_headings":"","what":"Defining ‚Äògo‚Äô decision","title":"Integration with bhmbasket","text":"bhmbasket package implements dynamic borrowing arms basket trials via Bayesian hierarchical models (BHMs). , demonstrate oncomsm prior specified mdl can used derive probability ‚Äògo‚Äô based bhmbasket analysis. use ‚ÄúBerry‚Äù type model analysis response data use posterior \\(0.25\\) quantile response probability \\(0.3\\) declare ‚Äògo‚Äô. means individual arm developed \\(0.75\\) posterior probability according BHM response rate larger \\(0.3\\).","code":"go <- function(model, data, nsim = 250) {   set.seed(2340239L)   # convert data to bhmbasket format (multi-state to binary counts)   data <- data %>%     group_by(group_id, subject_id) %>%     summarize(       responder = any(state == \"response\"),       .groups = \"drop_last\"     ) %>%     summarize(       r = sum(responder),       n = n(),     ) %>%     {       bhmbasket::createTrial(.$n, .$r)     }   # define Berry model in bhmbasket   prms_berry <- bhmbasket::setPriorParametersBerry(     mu_mean   = bhmbasket::logit(0.25),     mu_sd     = 1,     tau_scale = 1   )   # perform analysis in bhmbasket   res <- suppressMessages(bhmbasket::performAnalyses(     scenario_list         = data,     method_names          = \"berry\",     evidence_levels       = 1 - 0.25,     prior_parameters_list = prms_berry,     target_rates          = c(.2, .3, .3),     n_mcmc_iterations     = nsim,     verbose               = FALSE   ))   # 'go' if posterior quantile of response rate is sufficiently large   return(tibble(     group_id = model$group_id,     go = res$scenario_1$quantiles_list$berry[[1]][5, 2:4] >= .3   )) }"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/bhmbasket-integration.html","id":"probability-of-go-before-start-of-the-trial","dir":"Articles > Web_only","previous_headings":"","what":"Probability of ‚Äògo‚Äô before start of the trial","title":"Integration with bhmbasket","text":"‚Äògo‚Äô criterion can applied resampled data sets.","code":"tbl_decisions <- simulate_decision_rule(mdl,                                         c(40, 40, 40),                                         go,                                         nsim = 250,                                         seed = 32487)  tbl_pr_go_planning <- tbl_decisions %>%   group_by(group_id) %>%   summarize(`Pr[go] planning` = mean(go))  tbl_pr_go_planning #> # A tibble: 3 √ó 2 #>   group_id `Pr[go] planning` #>   <chr>                <dbl> #> 1 A                    0.312 #> 2 B                    0.716 #> 3 C                    0.884"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/bhmbasket-integration.html","id":"update-probability-of-go","dir":"Articles > Web_only","previous_headings":"","what":"Update probability of ‚Äògo‚Äô","title":"Integration with bhmbasket","text":"Now assume interim data available. data fairly extreme group group B.  prior can now updated data. probability ‚Äògo‚Äô updated sampling forward posterior predictive.","code":"tbl_interim <- tribble(    ~subject_id, ~group_id, ~t, ~state,           \"s1\", \"A\", 0, \"stable\",           \"s1\", \"A\", 1.5, \"stable\",           \"s1\", \"A\", 2.25, \"response\",           \"s2\", \"A\", 1, \"stable\",           \"s2\", \"A\", 2, \"response\",           \"s3\", \"A\", 3, \"stable\",           \"s3\", \"A\", 4.5, \"response\",           \"s4\", \"B\", 0, \"stable\",           \"s5\", \"B\", 1.5, \"stable\",           \"s6\", \"C\", 0, \"stable\",           \"s6\", \"C\", 1.5, \"progression\",           \"s7\", \"C\", 2.25, \"stable\",           \"s7\", \"C\", 3, \"progression\",           \"s8\", \"C\", 2, \"stable\",           \"s8\", \"C\", 3, \"progression\",           \"s9\", \"C\", 2, \"stable\",           \"s9\", \"C\", 2.6, \"stable\",           \"s9\", \"C\", 3, \"progression\",          \"s10\", \"C\", 3, \"stable\",          \"s10\", \"C\", 5, \"progression\" )  # plot it visits_to_mstate(tbl_interim, mdl) %>%   plot_mstate(mdl, relative_to_sot = FALSE) smpl_prior <- sample_prior(mdl, seed = 2314513) smpl_posterior <- sample_posterior(mdl, tbl_interim, seed = 2314)  tibble(   group_id = mdl$group_id,   prior = rstan::extract(smpl_prior, \"p\")[[1]] %>% colMeans(),   posterior = rstan::extract(smpl_posterior, \"p\")[[1]] %>% colMeans() ) #> # A tibble: 3 √ó 3 #>   group_id prior posterior #>   <chr>    <dbl>     <dbl> #> 1 A        0.302     0.391 #> 2 B        0.399     0.377 #> 3 C        0.500     0.401 tbl_decisions_interim <- simulate_decision_rule(   mdl,   c(40, 40, 40),   go,   data = tbl_interim,   nsim = 250,   seed = 32487 )  tbl_pr_go_planning %>%   left_join(     tbl_decisions_interim %>%     group_by(group_id) %>%     summarize(       `Pr[go] interim` = mean(go)     ),     by = \"group_id\"   ) #> # A tibble: 3 √ó 3 #>   group_id `Pr[go] planning` `Pr[go] interim` #>   <chr>                <dbl>            <dbl> #> 1 A                    0.312            0.644 #> 2 B                    0.716            0.64  #> 3 C                    0.884            0.54"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/probability-of-go.html","id":"decision-criteria","dir":"Articles > Web_only","previous_headings":"","what":"Decision criteria","title":"Application to Probability of 'go'","text":"Let \\(D_t \\\\mathbb{D}\\) observed (visit) data time point \\(t\\) start trial. Let \\(\\tau\\) stopping time trial, e.g., time point \\(n\\) individuals recruited reached minimal follow-. final decision ‚Äògo‚Äô can modeled function \\(\\phi: \\mathbb{D} \\\\{0,1\\}\\) \\[\\phi(D_\\tau)=1 :\\Leftrightarrow D_\\tau\\ \\ \\text{leads 'go'}\\ . \\] Examples decision rules quantile posterior distribution response rate certain relevance threshold, quantile posterior distribution PFS6 rate certain relevance threshold, quantile posterior distribution PFS certain threshold, combination .","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/probability-of-go.html","id":"probability-of-go","dir":"Articles > Web_only","previous_headings":"","what":"Probability of ‚Äògo‚Äô","title":"Application to Probability of 'go'","text":"Let \\(\\theta\\) vector parameters generative model allows sample data \\(D_\\tau|\\theta\\). Probability ‚Äògo‚Äô can calculated expected value decision rule prior distribution (density) \\(f(\\theta)\\) parameter space: \\[ \\operatorname{Pr}\\big[\\,go\\,\\big] = \\int \\phi(D_\\tau\\,|\\,\\theta) \\cdot f(\\theta) \\operatorname{d}\\theta \\ . \\] practice, integral can approximated sampling generative model calculating average ‚Äògo‚Äô rate. data \\(D_t=d_t\\) observed, probability ‚Äògo‚Äô can updated using Bayes Theorem \\[ \\operatorname{Pr}\\big[\\,go\\,|\\, D_t=d_t \\,\\big] = \\int \\phi(D_\\tau\\,|\\,D_t=d_t,\\theta) \\cdot f(\\theta\\,|\\,D_t=d_t) \\operatorname{d}\\theta \\] \\(f(\\theta\\,|\\,D_t=d_t)\\) posterior density given data \\(d_t\\) observed time \\(t\\).","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/probability-of-go.html","id":"example","dir":"Articles > Web_only","previous_headings":"","what":"Example","title":"Application to Probability of 'go'","text":"","code":"mdl <- create_srpmodel(   A = define_srp_prior(     p_mean = 0.5, p_n = 3, p_eta = 0.2,     recruitment_rate = 2   ) ) smpl_prior <- sample_prior(mdl, seed = 6835L)  plot(mdl, parameter_sample = smpl_prior, confidence = 0.9)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/probability-of-go.html","id":"orr-and-pfs-go-criterion","dir":"Articles > Web_only","previous_headings":"Example","what":"ORR and PFS ‚Äògo‚Äô criterion","title":"Application to Probability of 'go'","text":"Assume ‚Äògo‚Äô defined combination sufficiently high response rate sufficiently high progression-free-survival rate 12 months: \\[\\phi(D_\\tau) := \\begin{cases}   1 \\quad \\text{} \\quad \\operatorname{Pr}\\big[\\,\\text{ORR} \\geq 0.3\\ \\&\\ \\text{PFS}_{t=12} \\geq 0.4 \\, | \\, D_\\tau\\,\\big] \\geq 0.8 \\\\   0 \\quad \\text{else.}   \\end{cases}\\] decision criterion can implemented following function: criterion can tested sampling model fixed, favorable parameters - clearly expect ‚Äògo‚Äô.","code":"go <- function(model, data, nsim = 200L) {   set.seed(3819308) # fix the seed for reproducibility   smpl <- suppressWarnings( # low sample size leads to stan warnings on ESS                             # can be ignored, errors average out                             # can also be avoided by increasing nsim     sample_posterior(model, data = data, warmup = 200L, nsim = nsim)   )   tbl_pfs_orr <- inner_join(     compute_pfs(model, 12, smpl), # PFS 12     parameter_sample_to_tibble(model, smpl) %>% # ORR       filter(parameter == \"p\") %>%       transmute(iter = 1:nsim, group_id, orr = value),     by = c(\"iter\", \"group_id\")   )   res <- tbl_pfs_orr %>% # apply decision criterion     group_by(group_id) %>%     summarize(       go = mean(pfs >= 0.5 & orr >= 0.3) >= 0.8     )   return(res) } tbl_prior_predictive <- sample_predictive(     mdl,     n_per_group = 40L,     sample = smpl_prior,     p = 1,     shape = matrix(c(1, 1, 1), ncol = 3),     scale = matrix(c(4, 2, 24), ncol = 3) / log(2),     nsim = 1L,     seed = 34930L   )  tbl_prior_predictive %>%   visits_to_mstate(mdl) %>%   plot_mstate(mdl, relative_to_sot = FALSE) go(mdl, tbl_prior_predictive) #> # A tibble: 1 √ó 2 #>   group_id go    #>   <chr>    <lgl> #> 1 A        TRUE"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/probability-of-go.html","id":"calculating-go-probability","dir":"Articles > Web_only","previous_headings":"","what":"Calculating ‚Äògo‚Äô probability","title":"Application to Probability of 'go'","text":"Next, can create table multiple prior-predictive samples. Grouping iteration nesting data frames results data frame data frames, tbl_prior_predictive$data[[]] corresponds data \\(\\)-th resample. Applying decision criterion averaging iterations MCMC approximation probability ‚Äògo‚Äô. functionality available function oncomsm::simulate_decision_rule.","code":"tbl_prior_predictive <- sample_predictive(     mdl,     n_per_group = 40L,     sample = smpl_prior,     p = 0.6,     shape = matrix(c(1, 1, 1), ncol = 3),     scale = matrix(c(3, 12, 24), ncol = 3) / log(2),     nsim = 100L,     seed = 34930L   ) %>%   group_by(iter) %>%   tidyr::nest() %>%   ungroup()  print(tbl_prior_predictive) #> # A tibble: 100 √ó 2 #>     iter data                 #>    <int> <list>               #>  1     1 <tibble [1,600 √ó 4]> #>  2     2 <tibble [1,686 √ó 4]> #>  3     3 <tibble [1,083 √ó 4]> #>  4     4 <tibble [1,205 √ó 4]> #>  5     5 <tibble [911 √ó 4]>   #>  6     6 <tibble [1,104 √ó 4]> #>  7     7 <tibble [1,200 √ó 4]> #>  8     8 <tibble [1,441 √ó 4]> #>  9     9 <tibble [1,518 √ó 4]> #> 10    10 <tibble [1,059 √ó 4]> #> # ‚Ñπ 90 more rows # compute results in parallel res <- foreach(i = seq_len(nrow(tbl_prior_predictive))) %dorng% {   go(mdl, tbl_prior_predictive$data[[i]]) }  # bind results together and aggregate to probability of 'go' tbl_pr_go <- bind_rows(res, .id = \"iter\") %>%   group_by(group_id) %>%   summarize(     `Pr[go]` = mean(go),     se  = sd(go) / sqrt(n())   )  print(tbl_pr_go) #> # A tibble: 1 √ó 3 #>   group_id `Pr[go]`    se #>   <chr>       <dbl> <dbl> #> 1 A            0.99  0.01 simulate_decision_rule(mdl, 40L, go, nsim = 100L, seed = 324879) %>%   group_by(group_id) %>%   summarize(     `Pr[go]` = mean(go),     se  = sd(go) / sqrt(n())   )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/probability-of-go.html","id":"probability-of-go-during-a-trial","dir":"Articles > Web_only","previous_headings":"","what":"Probability of ‚Äògo‚Äô during a trial","title":"Application to Probability of 'go'","text":"Bayesian generative model allows calculating posterior distribution time point given data observed point. future course trial can sampled posterior predictive distribution. illustrate shift ‚Äògo‚Äô probability time, single trial realization set fixed response probabilities conflict prior mean sampled hypothetical data. data accrues, evidence lead shift posterior probability thus probability ‚Äògo‚Äô. just take first sampled trial ground truth. Next, interim views full data set sequence time points can created. data subsets correspond data available potential interim analyses. can compared number available responses, progressions, stable individuals time point.  interim data set, remainder trial can imputed sampling form posterior-predictive distribution given data observed point. probability ‚Äògo‚Äô average ‚Äògo‚Äô rate posterior predictive sample applying decision criterion. First, calculation probability ‚Äògo‚Äô wrapped function accepts dataset (tbl) number resamples (nsim). wrapper around oncomsm::simulate_decision_rule Next, function mapped interim time points respective interim data. number simulations main factor determining runtime program besides number samples drawn posterior distribution evaluate decision criterion. change ‚Äògo‚Äô probability time shown error bars corresponding standard error simulation.","code":"tbl_data <- tbl_prior_predictive$data[[1]] tbl_data_interims <- tibble(     t_interim = c(1, 3, 6, 9, 12, 18, 24) # interim time point (months)   ) %>%   mutate(     data = purrr::map(t_interim, ~filter(tbl_data, t <= .))   )  print(tbl_data_interims) #> # A tibble: 7 √ó 2 #>   t_interim data               #>       <dbl> <list>             #> 1         1 <tibble [2 √ó 4]>   #> 2         3 <tibble [10 √ó 4]>  #> 3         6 <tibble [37 √ó 4]>  #> 4         9 <tibble [76 √ó 4]>  #> 5        12 <tibble [131 √ó 4]> #> 6        18 <tibble [311 √ó 4]> #> 7        24 <tibble [527 √ó 4]> f <- function(tbl) {   tbl %>%   group_by(group_id, subject_id) %>%   summarize(     status = {       if (all(state == \"stable\")) {         \"stable\"       } else {         state[which(state != \"stable\")[1]]       }     },     .groups = \"drop_last\"   ) %>%   group_by(group_id, status) %>%   summarize(n = n(), .groups = \"drop\") }  tibble(   t_interim = tbl_data_interims$t_interim,   summary = purrr::map(tbl_data_interims$data, f) ) %>% unnest(summary) %>% ggplot() +   aes(t_interim, n, color = status) +   geom_step() +   geom_point() +   scale_x_continuous(\"t [months]\", breaks = seq(0, 36, by = 6)) +   scale_y_continuous(\"\", breaks = seq(0, 30, by = 5)) pr_go <- function(tbl, model, nsim = 100L) {   tbl_pr_go <- simulate_decision_rule(mdl, 40, go, data = tbl,                                       nsim = nsim, seed = 27307) %>%     group_by(group_id) %>%     summarize(       `Pr[go]` = mean(go),       se  = sd(go) / sqrt(n())     )   return(tbl_pr_go) } tbl_pr_go_over_time <- tbl_data_interims %>%   mutate(     res = purrr::map(data, pr_go, nsim = 33L)   ) %>%   tidyr::unnest(res)  tbl_pr_go_over_time #> # A tibble: 7 √ó 5 #>   t_interim data               group_id `Pr[go]`     se #>       <dbl> <list>             <chr>       <dbl>  <dbl> #> 1         1 <tibble [2 √ó 4]>   A           0.394 0.0864 #> 2         3 <tibble [10 √ó 4]>  A           0.455 0.0880 #> 3         6 <tibble [37 √ó 4]>  A           0.758 0.0758 #> 4         9 <tibble [76 √ó 4]>  A           0.818 0.0682 #> 5        12 <tibble [131 √ó 4]> A           1     0      #> 6        18 <tibble [311 √ó 4]> A           1     0      #> 7        24 <tibble [527 √ó 4]> A           1     0 t_last_patient_follow_up <- tbl_data %>%   visits_to_mstate(mdl) %>%   pull(t_sot) %>%   max() + 3 # assuming minimal follow-up of three months ggplot(tbl_pr_go_over_time) +   aes(t_interim) +   geom_errorbar(aes(ymin = `Pr[go]` - se, ymax = `Pr[go]` + se), width = 1) +   geom_line(aes(y = `Pr[go]`), alpha = 0.33) +   geom_vline(xintercept = t_last_patient_follow_up) +   scale_x_continuous(\"t [months]\", breaks = seq(0, 36, by = 6)) +   scale_y_continuous(breaks = seq(0, 1, by = 0.1), limits = c(0, 1))"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kevin Kunzmann. Author, maintainer. Karthik Ananthakrishnan. Contributor. Boehringer Ingelheim Ltd.. Copyright holder, funder.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kunzmann K (2023). oncomsm: Bayesian Multi-State Models Early Oncology. https://boehringer-ingelheim.github.io/oncomsm/, https://github.com/Boehringer-Ingelheim/oncomsm.","code":"@Manual{,   title = {oncomsm: Bayesian Multi-State Models for Early Oncology},   author = {Kevin Kunzmann},   year = {2023},   note = {https://boehringer-ingelheim.github.io/oncomsm/, https://github.com/Boehringer-Ingelheim/oncomsm}, }"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"bayesian-multi-state-models-for-early-oncology","dir":"","previous_headings":"","what":"Bayesian Multi-State Models for Early Oncology","title":"Bayesian Multi-State Models for Early Oncology","text":"R package oncomsm implements methods dynamically predict response progression individuals early oncology trials using parametric multi-state models Bayesian inference. allows dynamic computation ‚Äúprobability success‚Äù wide range success (‚Äúgo‚Äù) criteria. instance, bhmbasket R package can used define study success based Bayesian hierarchical models.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bayesian Multi-State Models for Early Oncology","text":"development version can installed repository. development version can installed repository.","code":"install.packages(\"oncomsm\") # install.packages(\"remotes\") remotes::install_github(\"https://github.com/Boehringer-Ingelheim/oncomsm\")"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Bayesian Multi-State Models for Early Oncology","text":"package documentation hosted .","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Bayesian Multi-State Models for Early Oncology","text":"See contributing guidelines.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/check_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Check a visits data set for correct format ‚Äî check_data","title":"Check a visits data set for correct format ‚Äî check_data","text":"Raises specific errors encountering issues data.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/check_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check a visits data set for correct format ‚Äî check_data","text":"","code":"check_data(data, model)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/check_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check a visits data set for correct format ‚Äî check_data","text":"data data.frame check model srpmodel object used fit data","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/check_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check a visits data set for correct format ‚Äî check_data","text":"data.frame, input censoring events terminal states removed.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/check_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check a visits data set for correct format ‚Äî check_data","text":"","code":"tbl <- data.frame(group_id = \"A\", subject_id = \"A1\", t = 0, state = \"stable\") mdl <- create_srpmodel(A = define_srp_prior()) check_data(tbl, mdl) #> # A tibble: 1 √ó 4 #>   group_id subject_id     t state  #>   <chr>    <chr>      <dbl> <chr>  #> 1 A        A1             0 stable"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute progression-free-survival rate given sample ‚Äî compute_pfs","title":"Compute progression-free-survival rate given sample ‚Äî compute_pfs","text":"compute_pfs() computes progression-free-survival rate specified times given paramter sample.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute progression-free-survival rate given sample ‚Äî compute_pfs","text":"","code":"compute_pfs(   model,   t,   parameter_sample = NULL,   warmup = 500L,   nsim = 1000L,   seed = NULL,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute progression-free-survival rate given sample ‚Äî compute_pfs","text":"model object class srpmodel containing prior information t vector time-points PFS rate computed parameter_sample stanfit object samples respective model. warmup integer, number warm-samples MCMC sampler retaining samples; see warmup parameter rstan::stan(). nsim integer, number samples draw seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute progression-free-survival rate given sample ‚Äî compute_pfs","text":"data frame samples PFS rates time points vector t.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute progression-free-survival rate given sample ‚Äî compute_pfs","text":"","code":"mdl <- create_srpmodel(A = define_srp_prior()) smpl <- sample_prior(mdl, nsim = 500, seed = 34L) dplyr::filter(   compute_pfs(mdl, t = seq(0, 12), parameter_sample = smpl),   iter == 1 ) #> # A tibble: 13 √ó 4 #>     iter group_id     t   pfs #>    <int> <chr>    <dbl> <dbl> #>  1     1 A            0 1     #>  2     1 A            1 0.887 #>  3     1 A            2 0.801 #>  4     1 A            3 0.743 #>  5     1 A            4 0.704 #>  6     1 A            5 0.677 #>  7     1 A            6 0.656 #>  8     1 A            7 0.639 #>  9     1 A            8 0.624 #> 10     1 A            9 0.610 #> 11     1 A           10 0.596 #> 12     1 A           11 0.583 #> 13     1 A           12 0.569"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/oncomsm-package.html","id":null,"dir":"Reference","previous_headings":"","what":"The oncomsm package ‚Äî oncomsm-package","title":"The oncomsm package ‚Äî oncomsm-package","text":"package implements methods dynamically predict response progression individuals early oncology trials using parametric multi-state models Bayesian inference. allows dynamic computation Probability Success wide inference implemented using 'rstan'.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/oncomsm-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The oncomsm package ‚Äî oncomsm-package","text":"Stan Development Team (2021). \"RStan: R interface Stan\". R package version 2.21.3. https://mc-stan.org","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert parameter sample to data table ‚Äî parameter_sample_to_tibble","title":"Convert parameter sample to data table ‚Äî parameter_sample_to_tibble","text":"parameter_sample_to_tibble() takes rstan::stanfit parameter sample model, extracts paramters values returns data frame.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert parameter sample to data table ‚Äî parameter_sample_to_tibble","text":"","code":"parameter_sample_to_tibble(model, sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert parameter sample to data table ‚Äî parameter_sample_to_tibble","text":"model object class srpmodel containing prior information sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert parameter sample to data table ‚Äî parameter_sample_to_tibble","text":"tibble sampled parameters, long format","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert parameter sample to data table ‚Äî parameter_sample_to_tibble","text":"","code":"mdl <- create_srpmodel(A = define_srp_prior()) smpl <- sample_prior(mdl, seed = 3647L) parameter_sample_to_tibble(mdl, smpl) #> # A tibble: 20,000 √ó 5 #>     iter parameter group_id transition  value #>    <int> <chr>     <chr>         <int>  <dbl> #>  1     1 p         A                NA  0.605 #>  2     1 median_t  A                 1  2.04  #>  3     1 median_t  A                 2 12.1   #>  4     1 median_t  A                 3 24.4   #>  5     1 shape     A                 1  1.15  #>  6     1 shape     A                 2  1.30  #>  7     1 shape     A                 3  1.99  #>  8     1 scale     A                 1  2.81  #>  9     1 scale     A                 2 16.0   #> 10     1 scale     A                 3 29.4   #> # ‚Ñπ 19,990 more rows"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot.srpmodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary plot of model prior ‚Äî plot.srpmodel","title":"Summary plot of model prior ‚Äî plot.srpmodel","text":"Summary plot model prior","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot.srpmodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary plot of model prior ‚Äî plot.srpmodel","text":"","code":"# S3 method for srpmodel plot(   x,   parameter_sample = NULL,   seed = 42L,   nsim = 500L,   warmup = 250,   nuts_control = list(),   dt_interval = NULL,   dt_n_grid = 25,   dt_expand = 1.1,   dt_grid = NULL,   confidence = NULL,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot.srpmodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary plot of model prior ‚Äî plot.srpmodel","text":"x model plot parameter_sample stanfit object samples respective model. seed integer, fixed random seed; NULL fixed seed nsim integer, number samples draw warmup integer, number warm-samples MCMC sampler retaining samples; see warmup parameter rstan::stan(). nuts_control list, parameters NUTS algorithm see control argument inrstan::stan() dt_interval numeric vector length two minimal maximal time (relative individual first visit) use plotting dt_n_grid number grid points use automatically choosing plotting interval dt_expand expansion factor upper plotting limit using automatic interval detection dt_grid numeric vector time points use plotting confidence numeric (0, 1) confidence level point-wise confidence bands around mean; none plotted NULL. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot.srpmodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary plot of model prior ‚Äî plot.srpmodel","text":"patchwork object, see patchwork::patchwork","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot.srpmodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary plot of model prior ‚Äî plot.srpmodel","text":"","code":"if (FALSE) { mdl <- create_srpmodel(A = define_srp_prior()) plot(mdl) }"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":null,"dir":"Reference","previous_headings":"","what":"Swimmer plot of multi-state data ‚Äî plot_mstate","title":"Swimmer plot of multi-state data ‚Äî plot_mstate","text":"plot_mstate() plots data 'multi-state-format' swimmer plot.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swimmer plot of multi-state data ‚Äî plot_mstate","text":"","code":"plot_mstate(   data,   model,   now = max(tbl_mstate$t_max),   relative_to_sot = TRUE,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Swimmer plot of multi-state data ‚Äî plot_mstate","text":"data data frame multi-state data; variables subject_id<chr>, group_id<chr>, subject_id<chr>, <chr>, <chr>, t_min<dbl>, t_max<dbl>, t_sot<dbl>, indicate state transitions occurs (stable, response, progression), t_max t_min specify interval transition occurred relative t_sot (start treatment). model object class srpmodel containing prior information now current time relative start trial relative_to_sot logical, timeline relative start trial start treatment individual ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Swimmer plot of multi-state data ‚Äî plot_mstate","text":"ggplot2::ggplot object","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Swimmer plot of multi-state data ‚Äî plot_mstate","text":"","code":"mdl <- create_srpmodel(A = define_srp_prior()) tbl_visits <- sample_predictive(mdl, n_per_group = 5L, nsim = 1, seed = 468L) tbl_mstate <- visits_to_mstate(tbl_visits, mdl) plot_mstate(tbl_mstate, mdl)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_pfs.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot progression-free-survival function ‚Äî plot_pfs","title":"Plot progression-free-survival function ‚Äî plot_pfs","text":"plot_pfs() plots progression-free-survival function model.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_pfs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot progression-free-survival function ‚Äî plot_pfs","text":"","code":"plot_pfs(   model,   parameter_sample = NULL,   seed = 42L,   nsim = 500L,   warmup = 250,   nuts_control = list(),   dt_interval = NULL,   dt_n_grid = 25,   dt_expand = 1.1,   dt_grid = NULL,   confidence = NULL,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_pfs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot progression-free-survival function ‚Äî plot_pfs","text":"model object class srpmodel containing prior information parameter_sample stanfit object samples respective model. seed integer, fixed random seed; NULL fixed seed nsim integer, number samples draw warmup integer, number warm-samples MCMC sampler retaining samples; see warmup parameter rstan::stan(). nuts_control list, parameters NUTS algorithm see control argument inrstan::stan() dt_interval numeric vector length two minimal maximal time (relative individual first visit) use plotting dt_n_grid number grid points use automatically choosing plotting interval dt_expand expansion factor upper plotting limit using automatic interval detection dt_grid numeric vector time points use plotting confidence numeric (0, 1) confidence level point-wise confidence bands around mean; none plotted NULL. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_pfs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot progression-free-survival function ‚Äî plot_pfs","text":"ggplot2::ggplot object","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_pfs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot progression-free-survival function ‚Äî plot_pfs","text":"","code":"if (FALSE) { mdl <- create_srpmodel(A = define_srp_prior()) plot_pfs(mdl) }"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_response_probability.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the response probability distributions ‚Äî plot_response_probability","title":"Plot the response probability distributions ‚Äî plot_response_probability","text":"plot_response_probability() plots distribution response probability parameter specified model.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_response_probability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the response probability distributions ‚Äî plot_response_probability","text":"","code":"plot_response_probability(   model,   parameter_sample = NULL,   seed = 42L,   nsim = 500L,   warmup = 250,   nuts_control = list(),   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_response_probability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the response probability distributions ‚Äî plot_response_probability","text":"model object class srpmodel containing prior information parameter_sample stanfit object samples respective model. seed integer, fixed random seed; NULL fixed seed nsim integer, number samples draw warmup integer, number warm-samples MCMC sampler retaining samples; see warmup parameter rstan::stan(). nuts_control list, parameters NUTS algorithm see control argument inrstan::stan() ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_response_probability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the response probability distributions ‚Äî plot_response_probability","text":"ggplot2::ggplot object","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_response_probability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the response probability distributions ‚Äî plot_response_probability","text":"","code":"mdl <- create_srpmodel(A = define_srp_prior()) plot_response_probability(mdl)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_transition_times.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the transition times of a model ‚Äî plot_transition_times","title":"Plot the transition times of a model ‚Äî plot_transition_times","text":"plot_transition_times() plots survival functions transition times multi-state model.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_transition_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the transition times of a model ‚Äî plot_transition_times","text":"","code":"plot_transition_times(   model,   parameter_sample = NULL,   seed = 42L,   nsim = 500L,   warmup = 250,   nuts_control = list(),   dt_interval = NULL,   dt_n_grid = 25,   dt_expand = 1.1,   dt_grid = NULL,   confidence = NULL,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_transition_times.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the transition times of a model ‚Äî plot_transition_times","text":"model object class srpmodel containing prior information parameter_sample stanfit object samples respective model. seed integer, fixed random seed; NULL fixed seed nsim integer, number samples draw warmup integer, number warm-samples MCMC sampler retaining samples; see warmup parameter rstan::stan(). nuts_control list, parameters NUTS algorithm see control argument inrstan::stan() dt_interval numeric vector length two minimal maximal time (relative individual first visit) use plotting dt_n_grid number grid points use automatically choosing plotting interval dt_expand expansion factor upper plotting limit using automatic interval detection dt_grid numeric vector time points use plotting confidence numeric (0, 1) confidence level point-wise confidence bands around mean; none plotted NULL. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_transition_times.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the transition times of a model ‚Äî plot_transition_times","text":"ggplot2::ggplot object","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_transition_times.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the transition times of a model ‚Äî plot_transition_times","text":"","code":"if (FALSE) { mdl <- create_srpmodel(A = define_srp_prior()) plot_transition_times(mdl) }"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/print.srpmodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Print an srpmodel ‚Äî print.srpmodel","title":"Print an srpmodel ‚Äî print.srpmodel","text":"Print srpmodel","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/print.srpmodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print an srpmodel ‚Äî print.srpmodel","text":"","code":"# S3 method for srpmodel print(x, ...)  # S3 method for srpmodel format(x, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/print.srpmodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print an srpmodel ‚Äî print.srpmodel","text":"x model print ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/print.srpmodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print an srpmodel ‚Äî print.srpmodel","text":"format() returns character string representation object, print() prints console returns object invisibly.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/print.srpmodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print an srpmodel ‚Äî print.srpmodel","text":"","code":"print(create_srpmodel(A = define_srp_prior())) #> srpmodel<A>  format(create_srpmodel(A = define_srp_prior())) #> [1] \"srpmodel<A>\""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample parameters from a model ‚Äî sample_posterior","title":"Sample parameters from a model ‚Äî sample_posterior","text":"sample_posterior() draws samples posterior distribution specified model given data set visit data. sample_prior() draws samples prior distribution specified model object.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample parameters from a model ‚Äî sample_posterior","text":"","code":"sample_posterior(   model,   data,   now = NULL,   nsim = 2000L,   seed = NULL,   warmup = 500L,   nuts_control = list(),   acceptable_divergent_transition_fraction = 0.1,   ... )  sample_prior(   model,   nsim = 2000L,   seed = NULL,   warmup = 500L,   nuts_control = list(),   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample parameters from a model ‚Äî sample_posterior","text":"model object class srpmodel containing prior information data data frame variables subject_id<chr> (subject identifier), group_id<chr> (group identifier), t<dbl> (time visit, relative first visit study), state<chr> (state recorded visit). Allowed states \"stable\", \"response\", \"progression\" (death), \"EOF\" (end follow-). EOF state marks end individual's follow-absorbing state \"progression\". now numeric, time first visit data different form last recorded visit nsim integer, number samples draw seed integer, fixed random seed; NULL fixed seed warmup integer, number warm-samples MCMC sampler retaining samples; see warmup parameter rstan::stan(). nuts_control list, parameters NUTS algorithm see control argument inrstan::stan() acceptable_divergent_transition_fraction, numeric 0 1 giving acceptable fraction divergent transitions throwing error ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample parameters from a model ‚Äî sample_posterior","text":"rstan::stanfit object posterior samples.","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample parameters from a model ‚Äî sample_posterior","text":"","code":"mdl <- create_srpmodel(A = define_srp_prior()) tbl <- tibble::tibble(   subject_id = c(\"A1\", \"A1\"),   group_id = c(\"A\", \"A\"),   t = c(0, 1.5),   state = c(\"stable\", \"response\") ) sample_posterior(mdl, tbl, seed = 42L) #> Inference for Stan model: srp_model_simple. #> 1 chains, each with iter=2500; warmup=500; thin=1;  #> post-warmup draws per chain=2000, total post-warmup draws=2000. #>  #>                mean se_mean    sd   2.5%   25%   50%   75%  97.5% n_eff Rhat #> p[1]           0.62    0.00  0.22   0.16  0.47  0.64  0.81   0.97  2190    1 #> median_t[1,1]  3.72    0.23  7.51   0.42  1.10  1.95  3.80  17.83  1101    1 #> median_t[1,2] 16.23    0.72 26.85   0.71  3.32  7.80 17.96  81.91  1404    1 #> median_t[1,3] 17.67    0.79 28.91   1.02  3.55  8.00 18.84  90.19  1325    1 #> shape[1,1]     1.54    0.01  0.47   0.83  1.21  1.47  1.81   2.66  2493    1 #> shape[1,2]     1.57    0.01  0.49   0.83  1.22  1.50  1.82   2.68  3233    1 #> shape[1,3]     1.60    0.01  0.51   0.85  1.22  1.52  1.91   2.73  3183    1 #> scale[1,1]     5.01    0.32 10.51   0.53  1.40  2.48  5.02  25.33  1066    1 #> scale[1,2]    21.09    0.95 35.37   0.90  4.25 10.13 23.37 103.49  1385    1 #> scale[1,3]    22.94    1.02 38.15   1.26  4.57 10.34 24.44 119.57  1409    1 #> lp__          -8.45    0.08  2.00 -13.16 -9.47 -8.11 -6.99  -5.59   660    1 #>  #> Samples were drawn using NUTS(diag_e) at Sun Apr 16 23:11:46 2023. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1).  sample_prior(mdl, seed = 42L) #> Inference for Stan model: srp_model_simple. #> 1 chains, each with iter=2500; warmup=500; thin=1;  #> post-warmup draws per chain=2000, total post-warmup draws=2000. #>  #>                mean se_mean    sd   2.5%   25%   50%   75%  97.5% n_eff Rhat #> p[1]           0.50    0.00  0.24   0.06  0.31  0.50  0.68   0.93  4210    1 #> median_t[1,1] 18.44    1.66 60.24   0.66  3.35  7.62 17.93  93.39  1313    1 #> median_t[1,2] 15.94    0.70 27.92   0.71  3.45  7.75 17.83  77.51  1570    1 #> median_t[1,3] 16.69    0.76 31.94   0.68  3.35  7.63 17.93  93.79  1761    1 #> shape[1,1]     1.57    0.01  0.49   0.83  1.21  1.51  1.86   2.70  2917    1 #> shape[1,2]     1.56    0.01  0.49   0.84  1.20  1.48  1.85   2.68  4107    1 #> shape[1,3]     1.58    0.01  0.52   0.83  1.19  1.51  1.86   2.80  3429    1 #> scale[1,1]    23.99    2.22 80.73   0.86  4.36  9.84 23.33 123.84  1321    1 #> scale[1,2]    20.70    0.90 35.96   0.94  4.45  9.97 22.84 100.43  1609    1 #> scale[1,3]    21.89    1.05 43.80   0.84  4.33  9.75 22.90 120.76  1735    1 #> lp__          -6.02    0.07  1.97 -10.54 -7.08 -5.65 -4.56  -3.28   768    1 #>  #> Samples were drawn using NUTS(diag_e) at Sun Apr 16 23:11:46 2023. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1)."},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample visits from predictive distribution ‚Äî impute","title":"Sample visits from predictive distribution ‚Äî impute","text":"impute() samples visits individuals data potentially missing individuals maximum n_per_group posterior predictive distribution given model. sample_predictive() draws samples predictive distribution model given parameter sample.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample visits from predictive distribution ‚Äî impute","text":"","code":"impute(   model,   data,   nsim,   n_per_group = NULL,   sample = NULL,   p = NULL,   shape = NULL,   scale = NULL,   now = NULL,   seed = NULL,   nsim_parameters = 1000L,   warmup_parameters = 250L,   nuts_control = list(),   as_mstate = FALSE,   ... )  sample_predictive(   model,   nsim,   n_per_group,   sample = NULL,   p = NULL,   shape = NULL,   scale = NULL,   seed = NULL,   nsim_parameters = 1000L,   warmup_parameters = 250,   nuts_control = list(),   as_mstate = FALSE,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample visits from predictive distribution ‚Äî impute","text":"model object class srpmodel containing prior information data data frame variables subject_id<chr> (subject identifier), group_id<chr> (group identifier), t<dbl> (time visit, relative first visit study), state<chr> (state recorded visit). Allowed states \"stable\", \"response\", \"progression\" (death), \"EOF\" (end follow-). EOF state marks end individual's follow-absorbing state \"progression\". nsim integer, number samples draw n_per_group integer vector number individuals per group. sample stanfit object samples respective model. p numeric, vector optional fixed response probabilities use sampling shape numeric, matrix optional fixed Weibull shape parameters use sampling must matrix dim c(n_groups, 3) second dimension corresponds transitions s->r, s->p, r->p scale numeric, matrix optional fixed Weibull scale parameters use sampling must matrix dim c(n_groups, 3) second dimension corresponds transitions s->r, s->p, r->p now numeric, time since first visit data last recorded visit time seed integer, fixed random seed; NULL fixed seed nsim_parameters integer, number parameter samples warmup_parameters integer, number warmup samples rstan sampler retaining samples parameters. nuts_control list, parameters NUTS algorithm see control argument inrstan::stan() as_mstate logical, return data mstate format? ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample visits from predictive distribution ‚Äî impute","text":"data frame variables subject_id<chr> (subject identifier), group_id<chr> (group identifier), t<dbl> (time visit, relative first visit study), state<chr> (state recorded visit) iter<int> (re-sample indicator). Allowed states \"stable\", \"response\", \"progression\" (death), \"EOF\" (end follow-). EOF state marks end individual's follow-absorbing state \"progression\".","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample visits from predictive distribution ‚Äî impute","text":"","code":"mdl <- create_srpmodel(A = define_srp_prior()) tbl <- tibble::tibble(   subject_id = c(\"A1\", \"A1\"),   group_id = c(\"A\", \"A\"),   t = c(0, 1.5),   state = c(\"stable\", \"stable\") ) impute(mdl, tbl, 1L, seed = 38L) #> # A tibble: 16 √ó 5 #>    subject_id group_id     t state        iter #>    <chr>      <chr>    <dbl> <chr>       <int> #>  1 A1         A          0   stable          1 #>  2 A1         A          1.5 stable          1 #>  3 A1         A          2.5 stable          1 #>  4 A1         A          3.5 stable          1 #>  5 A1         A          4.5 stable          1 #>  6 A1         A          5.5 stable          1 #>  7 A1         A          6.5 stable          1 #>  8 A1         A          7.5 stable          1 #>  9 A1         A          8.5 response        1 #> 10 A1         A          9.5 response        1 #> 11 A1         A         10.5 response        1 #> 12 A1         A         11.5 response        1 #> 13 A1         A         12.5 response        1 #> 14 A1         A         13.5 response        1 #> 15 A1         A         14.5 response        1 #> 16 A1         A         15.5 progression     1  sample_predictive(mdl, 1L, 20L, seed = 38L) #> # A tibble: 1,507 √ó 5 #>    subject_id group_id     t state   iter #>    <chr>      <chr>    <dbl> <chr>  <int> #>  1 ID00969187 A         26.7 stable     1 #>  2 ID00969187 A         27.7 stable     1 #>  3 ID00969187 A         28.7 stable     1 #>  4 ID00969187 A         29.7 stable     1 #>  5 ID00969187 A         30.7 stable     1 #>  6 ID00969187 A         31.7 stable     1 #>  7 ID00969187 A         32.7 stable     1 #>  8 ID00969187 A         33.7 stable     1 #>  9 ID00969187 A         34.7 stable     1 #> 10 ID00969187 A         35.7 stable     1 #> # ‚Ñπ 1,497 more rows"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/simulate_decision_rule.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate results under a custom decision rule ‚Äî simulate_decision_rule","title":"Simulate results under a custom decision rule ‚Äî simulate_decision_rule","text":"simulate_decision_rule() simulates prior posterior predictive distribution model applies custom decision rule simulated data set.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/simulate_decision_rule.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate results under a custom decision rule ‚Äî simulate_decision_rule","text":"","code":"simulate_decision_rule(   model,   n_per_group,   decision_rule,   data = NULL,   parameter_sample = NULL,   seed = NULL,   nsim = 1L )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/simulate_decision_rule.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate results under a custom decision rule ‚Äî simulate_decision_rule","text":"model model use sampling n_per_group group size decision_rule function signature rule(mdl, data, ...) returning data frame results applying decision rule data setdata, typically contains column group_id one column per decision/result. data data frame visit data condition parameter_sample optional parameter sample reuse seed optional fixed seed nsim number resamples draw predictive distribution","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/simulate_decision_rule.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate results under a custom decision rule ‚Äî simulate_decision_rule","text":"data frame columns iter (resample index) columns returned decision_rule applied nsim datasets sampled predictive distribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/simulate_decision_rule.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate results under a custom decision rule ‚Äî simulate_decision_rule","text":"sampling implementing using furrr::future_map() thus supports parallel execution specifying future::plan().","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/simulate_decision_rule.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate results under a custom decision rule ‚Äî simulate_decision_rule","text":"","code":"mdl <- create_srpmodel(A = define_srp_prior()) rule <- function(model, data) {   tibble::tibble(decision = sample(c(0,1), 1)) } simulate_decision_rule(mdl, 5, rule, nsim = 3) #> # A tibble: 3 √ó 2 #>    iter decision #>   <int>    <dbl> #> 1     1        0 #> 2     2        0 #> 3     3        0"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srpmodel.html","id":null,"dir":"Reference","previous_headings":"","what":"A stable-response-progression model ‚Äî srpmodel","title":"A stable-response-progression model ‚Äî srpmodel","text":"create_model() takes one prior-specifications SRP multi-state model combines single model object. Groups still treated independent.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srpmodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A stable-response-progression model ‚Äî srpmodel","text":"","code":"define_srp_prior(   p_mean = 0.5,   p_n = 3,   p_eta = 0,   p_min = 0,   p_max = 1,   median_t_q05 = c(1, 1, 1),   median_t_q95 = c(60, 60, 60),   shape_q05 = rep(0.9, 3),   shape_q95 = rep(2.5, 3),   visit_spacing = 1,   recruitment_rate = 1 )  create_srpmodel(   ...,   maximal_time = 10 * 12,   states = c(\"stable\", \"response\", \"progression\"),   censored = \"EOF\" )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srpmodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A stable-response-progression model ‚Äî srpmodel","text":"p_mean numeric, mean beta prior response probability p_n numeric, beta prior equivalent sample size (+ b) p_eta numeric, robustification parameter beta prior; actual prior (1 - eta) beta + eta; .e., eta non-informative weight. p_min numeric, minimal response probability p_max numeric, maximal response probability median_t_q05 numeric length three, 5% quantiles log-normal distributions median time--next-event three transitions s->r, s->p, r->p. median_t_q95 numeric length three, 95% quantiles log-normal distributions median time--next-event three transitions s->r, s->p, r->p. shape_q05 numeric length three, 5% quantiles log-normal distributions shapes time--next-event distributions three transitions s->r, s->p, r->p. shape_q95 numeric length three, 95% quantiles log-normal distributions shapes time--next-event distributions three transitions s->r, s->p, r->p. visit_spacing numeric, fixed duration visits recruitment_rate numeric, constant recruitment rate ... named srp_prior objects; argument names serve group labels maximal_time maximal overall runtime trial measured first visit group. visits past point sampled. states character vector three states (initial, intermediate, terminal) censored string, indicator premature censoring events; data imputed point.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srpmodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A stable-response-progression model ‚Äî srpmodel","text":"define_srp_prior() returns object class srp_prior, inputs accessible via $x x name input argument function call except two parameters visit_spacing recruitment_rate. two parameters saved attributes can retrieved directly using attr(mdl, \"visit_spacing\") attr(mdl, \"recruitment_rate\"). create_srpmodel() returns object class c(\"srpmodel\", \"list\") holds information potentially multiple groups compact format can accessed using list operator $name. group_id character vector group names, maximal_time maximal follow-time since first visit study, visit_spacing vector per-group difference visits (relevant forward sampling), recruitment_rate vector per-group recruitment rates, stan_model pre-compiled 'stan' model used inference, states vector state names multi-state model, prior list hyperparamters model prior elements p, vector, response probability per group, median_t c(n_groups, 3, 2) dimensional array median_t[,j,1] holds 5% quantile lognormal prior median transition time group transition j median_t[,j,2] corresponding upper 95% quantile. shape hyperparamter format specified corresponding quantiles Weibull shape parameter.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srpmodel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A stable-response-progression model ‚Äî srpmodel","text":"define_srp_prior() specifies prior distribution three state model (stable, response, progression) single group.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srpmodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A stable-response-progression model ‚Äî srpmodel","text":"","code":"# a model with prior 25% response rate and variance equivalent to # 10 data points (i.e. a Beta(2.5, 7.5) distribution). grp <- define_srp_prior(p_mean = 0.25, p_n = 10) attr(grp, \"recruitment_rate\") #> [1] 1  # a model with two groups and different priors on the respective response # probabilities mdl <- create_srpmodel(   A = define_srp_prior(),   B = define_srp_prior(p_mean = 0.33, p_n = 10) ) mdl$median_t #> NULL"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert cross-sectional visit data to multi-state format ‚Äî visits_to_mstate","title":"Convert cross-sectional visit data to multi-state format ‚Äî visits_to_mstate","text":"visits_to_mstate() converts visits interval-censored multi-state data row corresponds transition states. conversion assumes visit spacing tight enough miss transitions.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert cross-sectional visit data to multi-state format ‚Äî visits_to_mstate","text":"","code":"visits_to_mstate(tbl_visits, model, now = max(tbl_visits$t))"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert cross-sectional visit data to multi-state format ‚Äî visits_to_mstate","text":"tbl_visits data frame, visit data long format model object class srpmodel containing prior information now time point since start trial (might later last recorded visit)","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert cross-sectional visit data to multi-state format ‚Äî visits_to_mstate","text":"data frame multi-state data; variables subject_id<chr>, group_id<chr>, subject_id<chr>, <chr>, <chr>, t_min<dbl>, t_max<dbl>, t_sot<dbl>, indicate state transitions occurs, t_max t_min specify interval transition occurred relative t_sot (start treatment).","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert cross-sectional visit data to multi-state format ‚Äî visits_to_mstate","text":"","code":"mdl <- create_srpmodel(A = define_srp_prior()) tbl_visits <- sample_predictive(mdl, n_per_group = 5L, nsim = 1, seed = 468L) visits_to_mstate(tbl_visits, mdl) #> # A tibble: 8 √ó 7 #>   subject_id group_id from     to          t_min t_max t_sot #>   <chr>      <chr>    <chr>    <chr>       <dbl> <dbl> <dbl> #> 1 ID05135273 A        stable   response    46.8  47.8   5.84 #> 2 ID05135273 A        response progression 54.8  55.8   5.84 #> 3 ID05466621 A        stable   progression 52.0  53.0   1.01 #> 4 ID05662273 A        stable   progression 35.8  36.8   3.81 #> 5 ID05729114 A        stable   response    12.3  13.3   6.26 #> 6 ID05729114 A        response progression 23.3  24.3   6.26 #> 7 ID07955012 A        stable   response     6.94  7.94  4.94 #> 8 ID07955012 A        response progression 25.9  26.9   4.94"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/news/index.html","id":"oncomsm-014","dir":"Changelog","previous_headings":"","what":"oncomsm 0.1.4","title":"oncomsm 0.1.4","text":"‚Ä¶","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/news/index.html","id":"oncomsm-013","dir":"Changelog","previous_headings":"","what":"oncomsm 0.1.3","title":"oncomsm 0.1.3","text":"CRAN release: 2023-03-11 Added NEWS.md file track changes package. Made state name censoring indicator configurable creat_srpmodel() Reverted back non-static C++ code (use rstantools translate build-time) Added check_data() function using check data inputs possible","code":""}]
