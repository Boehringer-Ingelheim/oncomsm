[{"path":"https://boehringer-ingelheim.github.io/oncomsm/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/LICENSE.html","id":"1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/LICENSE.html","id":"2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/LICENSE.html","id":"3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/LICENSE.html","id":"4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/LICENSE.html","id":"5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/LICENSE.html","id":"6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/LICENSE.html","id":"7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/LICENSE.html","id":"8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/LICENSE.html","id":"9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/LICENSE.html","id":"appendix-how-to-apply-the-apache-license-to-your-work","dir":"","previous_headings":"","what":"APPENDIX: How to apply the Apache License to your work","title":"Apache License","text":"apply Apache License work, attach following boilerplate notice, fields enclosed brackets [] replaced identifying information. (Don’t include brackets!) text enclosed appropriate comment syntax file format. also recommend file class name description purpose included “printed page” copyright notice easier identification within third-party archives.","code":"Copyright [yyyy] [name of copyright owner]  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/application-to-probability-of-success.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Application to Probability of Success Calculation","text":"general introduction multi-state approach used throughout package, see vignette Multi-state Models Early Oncology. fully generative multi-state model, future trial data can sampled prior predictive distribution (data available) posterior predictive distribution conditioning data accrues. can used evaluate decision criterion determine trial success thus compute Probability Success.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/application-to-probability-of-success.html","id":"decision-criterion","dir":"Articles","previous_headings":"Background","what":"Decision criterion","title":"Application to Probability of Success Calculation","text":"Assume sample size (follow-) trial randomization scheme fixed upfront. Let \\(D_t \\\\mathbb{D}\\) observed (visit) data time point \\(t\\) start trial. Let \\(\\tau\\) stopping time trial (\\(n\\) individuals recruited minimal follow-reached) final decision whether trial considered success can modeled function \\(\\phi: \\mathbb{D} \\\\{0,1\\}\\) \\[\\phi(D_\\tau)=1 :\\Leftrightarrow D_\\tau\\ \\text{considered success}\\ . \\] can sample data \\(D_\\tau|\\theta\\) given generative model parameters \\(\\theta\\), can evaluate Probability Success \\[ \\operatorname{PoS} = \\int \\phi(D_\\tau) \\cdot f(\\theta) \\operatorname{d}\\theta \\] \\(f(\\theta)\\) prior model parameters using MCMC integration simulating forward form predictive distribution. data \\(D_t=d_t\\) observed \\(t\\leq\\tau\\), one can update PoS using Bayes Theorem \\[ \\operatorname{PoS}\\,|\\, (D_t=d_t \\ ) = \\int \\phi(D_\\tau\\,|\\,D_t=d_t) \\cdot f(\\theta\\,|\\,D_t=d_t) \\operatorname{d}\\theta \\ . \\] Examples decision rules … quantile posterior distribution response rate certain relevance threshold, quantile posterior distribution PFS6 rate certain relevance threshold, quantile posterior distribution PFS certain threshold, combination .","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/application-to-probability-of-success.html","id":"prior-specification","dir":"Articles","previous_headings":"Example","what":"Prior specification","title":"Application to Probability of Success Calculation","text":"Assume following prior multi-state model . can now sample prior visualize .  induced prior PFS rates 3, 6, 12, 18 months ","code":"mdl <- create_srp_model(     # names of the arms/groups     group_id = c(\"A\", \"B\", \"C\"),     # per-group logodds of response|stable     logodds_mean =  c(logodds(.20), logodds(.3), logodds(.3)),     logodds_sd = c(.5, .5, .5),     # m[i,j] is the median time to next event for group i and transition j     median_time_to_next_event = matrix(c(       3, 2, 6,       2, 8, 9,       2, 6, 24      ), byrow = TRUE,  nrow = 3, ncol = 3),     # fixed standard deviation of the prior for all median times     median_time_to_next_event_sd = matrix(        1, byrow = TRUE,  nrow = 3, ncol = 3     ),     # uniform prior over the shape parameter, difficult to identify,      # better keep it tight to avoid issues with the sampler     shape_min = matrix(        .75, byrow = TRUE,  nrow = 3, ncol = 3     ),     shape_max = matrix(        2, byrow = TRUE,  nrow = 3, ncol = 3     ),     # the visit interval     visit_spacing = c(1.2, 1.2, 1.2)   ) smpl_prior <- sample_prior(mdl, warmup = 500, nsim = 2000, seed = 6835L)  plot(mdl, dt = c(0, 36), sample = smpl_prior) tbl_pfs_rates <- sample_pfs_rate(mdl, c(3, 6, 12, 18), sample = smpl_prior) %>%    mutate(t = factor(t))    ggplot(tbl_pfs_rates) +   geom_boxplot(aes(x = t, y = pfs, color = group_id)) +   scale_color_discrete(\"\") +   labs(x = \"t\", y = \"Pr[no death or progression before t]\")"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/application-to-probability-of-success.html","id":"definition-of-success-criterion","dir":"Articles","previous_headings":"Example","what":"Definition of success criterion","title":"Application to Probability of Success Calculation","text":"Let us consider two success criteria per arm: \\(\\phi_1^(D_\\tau) = 0.25 \\ \\text{posterior quantile response greater } \\ 0.3\\) \\(\\phi_2^(D_\\tau) = 0.25 \\ \\text{posterior quantile PFS12 rate greater } \\ 0.5\\)","code":"# the simulation number is only chosen so small for demonstration purposes # we compute both phi_1 and phi_2 jointly to reuse the same posterior sample eval_phi <- function(data, prob = 0.25, nsim = 250) {   smpl <- sample_posterior(mdl, data = data, seed = 38497, warmup = 150L, nsim = nsim)   mtx_p <- rstan::extract(smpl, \"p\")$p   p <- apply(mtx_p, 2, function(x) quantile(x, .25))   res <- sample_pfs_rate(mdl, 12, smpl) %>%      group_by(group_id) %>%      summarize(pfs12 = quantile(pfs, .25)) %>%      mutate(       p = p,       phi_1 = p >= 0.3,       phi_2 = pfs12 >= 0.5     ) %>%      select(group_id, phi_1, phi_2)   return(res) } tbl_prior_predictive <- sample_predictive(     mdl,     n_per_group = rep(30L, 3),     sample = smpl_prior,     nsim = 100L, # same, here, only for demonstration purposes     seed = 34930L   ) %>%    group_by(iter) %>%    tidyr::nest() plan(multisession) # instruct future how to run in parallel  # it is a good idea to cache long running simulation ;) tbl_results <- xfun::cache_rds({       tbl_prior_predictive %>%     ungroup() %>%      mutate(       res = furrr::future_map(         data, eval_phi,         .options = furrr::furrr_options(seed = TRUE, scheduling = 5L)       )     ) %>%      select(-data)    }, dir = \".cache/\", file = \"sim_results.rds\") # end caching tbl_results %>%    tidyr::unnest(res) %>%    group_by(group_id) %>%    summarize(     pos_phi_1 = mean(phi_1),     pos_phi_2 = mean(phi_2)   ) #> # A tibble: 3 × 3 #>   group_id pos_phi_1 pos_phi_2 #>   <chr>        <dbl>     <dbl> #> 1 A             0.04      0    #> 2 B             0.21      0    #> 3 C             0.35      0.01"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/application-to-probability-of-success.html","id":"advanced-decision-boundaries-connection-with-bhmbasket","dir":"Articles","previous_headings":"Example","what":"Advanced decision boundaries: connection with bhmbasket","title":"Application to Probability of Success Calculation","text":"bhmbasket package implements dynamic borrowing arms basket trials via Bayesian hierarchical models (BHMs). , demonstrate prior predictive sample generated earlier can used conjunction shrinkage estimator compute PoS decision based BHM. use “Berry” type model analysis response data use posterior \\(0.25\\) quantile response rate \\(0.3\\) declare success (\\(\\phi_3^\\)).","code":"prms_berry <- bhmbasket::setPriorParametersBerry(   mu_mean   = bhmbasket::logit(0.25),   mu_sd     = 1,   tau_scale = 1 )  data_to_bhmbasket_trial <- function(data) {   data %>%      group_by(group_id, subject_id) %>%      summarize(responder = any(to == \"response\")) %>%      summarize(r = sum(responder), n = n()) %>%      {bhmbasket::createTrial(.$n, .$r)} %>%      return() }  eval_phi_3 <- function(data, nsim = 250) {   prob = 0.25 # needs to be hard coded   set.seed(2340239L)   res <- suppressMessages(bhmbasket::performAnalyses(       scenario_list         = data_to_bhmbasket_trial(data),       method_names          = \"berry\",       evidence_levels       = 1 - prob,       prior_parameters_list = prms_berry,       target_rates          = c(.2, .3, .3),       n_mcmc_iterations     = nsim,       verbose               = FALSE     ))   return(tibble(     group_id = attr(mdl, \"group_id\"),     phi_3 = res$scenario_1$quantiles_list$berry[[1]][5, 2:4] >= .3   )) } # it is a good idea to cache long running simulation ;) tbl_results_bhmbasket <- xfun::cache_rds({       tbl_prior_predictive %>%     ungroup() %>%      mutate(       res = furrr::future_map(         data, eval_phi_3,         .options = furrr::furrr_options(seed = TRUE)       )     ) %>%      select(-data)    }, dir = \".cache/\", file = \"sim_results_bhmbasket.rds\") # end caching tbl_results_bhmbasket %>%    tidyr::unnest(res) %>%    group_by(group_id) %>%    summarize(     pos_phi_3 = mean(phi_3)   ) %>%    left_join(     tbl_results %>%        tidyr::unnest(res) %>%        group_by(group_id) %>%        summarize(         pos_phi_1 = mean(phi_1),         pos_phi_2 = mean(phi_2)       ),      by = \"group_id\"   ) #> # A tibble: 3 × 4 #>   group_id pos_phi_3 pos_phi_1 pos_phi_2 #>   <chr>        <dbl>     <dbl>     <dbl> #> 1 A             0.06      0.04      0    #> 2 B             0.22      0.21      0    #> 3 C             0.31      0.35      0.01"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/application-to-probability-of-success.html","id":"computing-dynamic-probability-of-success","dir":"Articles","previous_headings":"","what":"Computing dynamic Probability of Success","title":"Application to Probability of Success Calculation","text":"Bayesian framework two distinct advantages applied early setting.","code":"recruitment_rate_overall <- 3 tbl_interim <- sample_predictive(     mdl,      sample = smpl_prior,     n_per_group = c(30L, 30L),      nsim = 250,      seed = 3423423   ) %>%    filter(iter == 1) %>%    select(-t_sot) %>%    {left_join(     .,     select(., subject_id, group_id) %>%        distinct() %>%        arrange(runif(n())) %>% # permute groups       mutate(         t_sot = cumsum(rexp(n = n(), rate = recruitment_rate_overall)), # poisson recruitment process       ),     by = c(\"subject_id\", \"group_id\")   )} %>%    mutate(     t_min = t_min + t_sot,     t_max = t_max + t_sot   ) %>%    mstate_to_visits(mdl, .) %>%    filter(t <= 10) %>%    visits_to_mstate(     start_state = \"stable\",      absorbing_states = \"progression\",      now = 10   ) #> 'mstate_to_visits.srp_model' is experimental  tbl_interim_sample_sizes <- tbl_interim %>%    select(group_id, subject_id) %>%    distinct() %>%    group_by(group_id) %>%    summarize(n = n())  smpl_posterior <- sample_posterior(   mdl,    tbl_interim,    nsim = 2000, warmup = 250, seed = 76947 )  tbl_to_be_recruited <- tibble(     group_id = tbl_interim_sample_sizes$group_id,     n_to_be_recruited = 30 - tbl_interim_sample_sizes$n     ) %>%    mutate(     tmp = purrr::map(       n_to_be_recruited,        ~tibble(         # use unique identifiers to avoid clashing between groups         subject_id = uuid::UUIDgenerate(n = .),         # sample recruitment times per group using half the overall          # recruitment rate         t_sot = cumsum(rexp(n = ., rate = recruitment_rate_overall/2))       )     )   ) %>%    select(-n_to_be_recruited) %>%    tidyr::unnest(tmp) %>%    # add information on starting state etc to expand to full mstate table   mutate(     from = \"stable\",     to = NA_character_,     t_min = t_sot + 1/30, # preclude events on the day of recruitment     t_max = Inf # right censored   )  tbl_mstate_interim_forward <- bind_rows(tbl_interim, tbl_to_be_recruited)  tbl_posterior_predictive <- impute_predictive(     mdl,     data = tbl_mstate_interim_forward,      sample = smpl_posterior,     nsim = 100   )  tbl_posterior_predictive #> # A tibble: 7,807 × 8 #>    subject_id                       group…¹ from  to     t_min t_max t_sot  iter #>    <chr>                            <chr>   <chr> <chr>  <dbl> <dbl> <dbl> <int> #>  1 2fe5c666-b261-41fb-932f-7077f72… B       stab… prog… 14.7   15.9  0.231     1 #>  2 2fe5c666-b261-41fb-932f-7077f72… B       stab… prog…  0.264  1.46 0.231     2 #>  3 2fe5c666-b261-41fb-932f-7077f72… B       stab… prog… 11.1   12.3  0.231     3 #>  4 2fe5c666-b261-41fb-932f-7077f72… B       stab… resp…  1.46   2.66 0.231     4 #>  5 2fe5c666-b261-41fb-932f-7077f72… B       resp… prog… 11.1   12.3  0.231     4 #>  6 2fe5c666-b261-41fb-932f-7077f72… B       stab… resp…  0.264  1.46 0.231     5 #>  7 2fe5c666-b261-41fb-932f-7077f72… B       resp… prog…  7.46   8.66 0.231     5 #>  8 2fe5c666-b261-41fb-932f-7077f72… B       stab… prog…  3.86   5.06 0.231     6 #>  9 2fe5c666-b261-41fb-932f-7077f72… B       stab… prog…  5.06   6.26 0.231     7 #> 10 2fe5c666-b261-41fb-932f-7077f72… B       stab… prog… 15.9   17.1  0.231     8 #> # … with 7,797 more rows, and abbreviated variable name ¹​group_id #> # ℹ Use `print(n = ...)` to see more rows"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Multi-State Models for Oncology","text":"tl;dr: Tumor response data often treated binary endpoint early oncology trials (objective response progression free survival x months). ignores fact time--event endpoints. Instead, multi-state characteristics data can exploited reduce bias interim analyses drive event prediction probability success calculations. early oncology trials, (objective tumor) response based RECIST criteria often used primary endpoint establish activity treatment. Response often treated binary variable although delayed event endpoint. final analysis, simplification little concern since individuals tend followed long enough justify assumption non-responders unlikely still become responders. approach often plausible since individuals tumors responding treatment ultimately progress. However, continuously monitoring trial, assumption sufficient follow-longer fulfilled simple binary analysis may biased. vignette, problem addressed extending statistic binary response model three-state model “stable”, “response”, “progression death”. respective transition numbers given graph . someone becomes responder, model allows transition combined progression death state. means progression death modeled competing events simplifies analysis greatly model like one : Coming back simpler model, still competing event issue starting ‘stable’. Often, convenient hazard-based approach used model multistate situations like . hazard-based approach intuitive, especially considering non-parametric estimation, co variate inclusion well-understood. However, hazard-based approach several disadvantages: hazard scale difficult interpret since momentary risk, probability. leads problems prior specification Bayesian setting. Bayesian approach , however, particularly useful early development process since allows augment data prior opinion evidence thus improve accuracy. hazard based, non-Markov multi-state model leads intractable expressions implicitly given transition probabilities. Hence need calculated simulation makes model less convenient work transition probabilities primary interest. Since (objective) response rate often plays important role analysis early oncology trials, disadvantage. alternative framework model multi-state data using mixture models. details, see {ref} [link flexsurv covid paper]. , describe concrete application simplified “stable”, “response”, “progression” model. approach similar [gaelle paper]. Assuming transition process can described semi-Markov process one way rendering modeling tractable. means time next transition depends time already spent state, prior jumps. Additionally, assumed transition times states conditional originating target state can described Weibull distributions. parametric family encompasses exponential distribution constant transition rates special cases also allows increasing decreasing hazards time. Transition 2 fully characterized corresponding Weibull distribution since competing event. Let \\(\\tau_i,\\ \\\\{1,2,3\\}\\) respective transition times (\\(\\tau_i=\\infty\\) means transition occur) \\(R\\) binary random variable \\(R=1\\) response occurs, model can specified : \\[ \\begin{align} R &\\sim \\operatorname{Bernoulli}(p) \\\\ \\tau_1 \\,|\\, R = 1 &\\sim \\operatorname{Weibull}(shape[1], scale[1]) \\\\ \\tau_1 \\,|\\, R = 0 &\\sim \\delta_{\\infty} \\\\ \\tau_2 \\,|\\, R = 0 &\\sim \\operatorname{Weibull}(shape[2], scale[2]) \\\\ \\tau_2 \\,|\\, R = 1 &\\sim \\delta_{\\infty} \\\\ \\tau_3 &\\sim \\operatorname{Weibull}(shape[3], scale[3])  \\end{align} \\] \\(\\delta_{\\infty}\\) point measure infinity. Let \\(f_i(t)\\) PDF Weibull distribution transition \\(\\\\{1,2,3\\}\\) indicated figure let \\(F_i(t)\\) corresponding CDF. model implies \\[ \\operatorname{Pr}\\big[\\,\\tau_1 > t \\text{ } \\tau_3 > t \\,\\big]  = p\\cdot(1 - F_1(t))  + (1 - p)\\cdot(1 - F_3(t))\\\\ \\] hence, can seen mixture model. Instead parameterizing Weibull distributions directly via shape scale, shape median-time--next-event used. scale parameter can recovered via relationship \\[ \\operatorname{scale} = \\frac{\\operatorname{median-time--next-event}}{\\log(2)^{1/\\operatorname{shape}}} .  \\] following priors used: normal prior log-odds response \\(\\operatorname{logit}(p) \\sim \\mathcal{N}(\\mu_p,\\sigma_p^2)\\) truncated normal prior median-time--next-event transition \\(\\operatorname{median-time--next-event}_{\\,} \\sim \\mathcal{N}(\\mu_i,\\sigma_i^2)[\\,0,\\infty)\\) flat prior shape transition \\(\\operatorname{shape}_{\\,} \\sim \\operatorname{Uniform}(a_i. n_i)\\) assumed observation process (visit spacing) fixed, e.g. every 6 weeks. irrelevant inference, important sampling forward model since assumed transition times observed exactly regular visits. treat recruitment times independent outcome. can modeled separately required.","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"specifying-the-model","dir":"Articles","previous_headings":"Example","what":"Specifying the model","title":"Multi-State Models for Oncology","text":"assume time-scale months.","code":"mdl <- create_srp_model(     # names of the arms/groups     group_id = c(\"control\", \"intervention\"),     # per-group logodds of response|stable     logodds_mean =  c(logodds(.25), logodds(.5)),     logodds_sd = c(.75, .75),     # m[i,j] is the median time to next event for group i and transition j     median_time_to_next_event = matrix(c(       3, 2, 6,       2, 8, 12     ), byrow = TRUE,  nrow = 2, ncol = 3),     # fixed standard deviation of the prior for all median times     median_time_to_next_event_sd = matrix(        1, byrow = TRUE,  nrow = 2, ncol = 3     ),     # uniform prior over the shape parameter, difficult to identify,      # better keep it tight to avoid issues with the sampler     shape_min = matrix(        .75, byrow = TRUE,  nrow = 2, ncol = 3     ),     shape_max = matrix(        2, byrow = TRUE,  nrow = 2, ncol = 3     ),     # the visit interval     visit_spacing = c(1.2, 1.2)   ) # TODO: implement a nice summary / print function here"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"prior-checks","dir":"Articles","previous_headings":"Example","what":"Prior checks","title":"Multi-State Models for Oncology","text":"First plot cumulative distribution functions (CDF) time--next-event first 36 (months) (empirical) CDF response probabilities per group. based sample drawn prior distribution model. can re-use parameter sample sampling prior-predictive distribution separating sampling plotting steps. parameter sample provided plotting function samples automatically.  Next, draw samples prior-predictive distribution model. sample 100 trials 30 individuals per arm. , can re-use sample prior sample already used plotting. generated data can also visualized swimmer plots","code":"smpl_prior <- sample_prior(mdl, warmup = 500, nsim = 2000, seed = 36L)  plot(mdl, dt = c(0, 36), sample = smpl_prior) tbl_prior_predictive <- sample_predictive(   mdl,    sample = smpl_prior,   n_per_group = c(30L, 30L),    nsim = 100,    seed = 3423423 )   # estimate of the response rates tbl_prior_predictive %>%    filter(from == \"stable\") %>%    group_by(group_id) %>%    summarize(p_response = sum(to == \"response\")/n()) #> # A tibble: 2 × 2 #>   group_id     p_response #>   <chr>             <dbl> #> 1 control           0.258 #> 2 intervention      0.498  # crude approximation of the median jump times from \"stable\" tbl_prior_predictive %>%     filter(from == \"stable\") %>%    group_by(group_id, from, to) %>%    summarize(t_jump_approx = median(t_min + t_max)/2, .groups = \"drop\")  #> # A tibble: 4 × 4 #>   group_id     from   to          t_jump_approx #>   <chr>        <chr>  <chr>               <dbl> #> 1 control      stable progression           1.8 #> 2 control      stable response              3   #> 3 intervention stable progression           7.8 #> 4 intervention stable response              1.8 # TODO: improve sorting plot_mstate(mdl, tbl_prior_predictive %>% filter(iter == 1))"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"analyzing-progression-free-survival","dir":"Articles","previous_headings":"Example","what":"Analyzing progression-free-survival","title":"Multi-State Models for Oncology","text":"Often, rate progression free survival (PFS) particular time point interest. quantity direct function model parameters. Since simplified model distinguish progression death, denote combined endpoint “progression”. \\[ \\begin{align} \\operatorname{PFS}(t) :&= \\operatorname{Pr}\\big[\\,\\text{progression } t\\,\\big] \\\\   &= 1 - \\operatorname{Pr}\\big[\\,\\text{progression } t\\,] \\\\   &= 1 - \\operatorname{Pr}\\big[\\,\\text{progression } t\\,|\\, \\text{response}\\,]\\cdot\\operatorname{Pr}\\big[\\,\\text{response}\\,] \\\\   &\\qquad- \\operatorname{Pr}\\big[\\,\\text{progression } t\\,|\\, \\text{response}\\,]\\cdot\\operatorname{Pr}\\big[\\,\\text{response}\\,] \\\\   &= 1 - p\\cdot\\int_0^t f_1(u) \\cdot F_2(t - u) \\operatorname{d}u - (1 - p)\\cdot F_3(t) \\ . \\end{align} \\] , integral arises need reflect uncertainty state change “stable” “response” way “progression”. parameter sample thus also induces sample PFS rate given time point. , PFS rates 3, 6, 12 months computed.  distribution PFS time might also interest. Currently, best way obtain , via prior predictive sample. might make sense reduce visit_spacing get precise measurements transition times though.","code":"tbl_pfs_rates <- sample_pfs_rate(mdl, c(3, 6, 12), sample = smpl_prior) %>%    mutate(t = factor(t))    ggplot(tbl_pfs_rates) +   geom_boxplot(aes(x = t, y = pfs, color = group_id)) +   scale_color_discrete(\"\") +   labs(x = \"t\", y = \"Pr[no death or progression before t]\") # copy model object mdl_tmp <- mdl # adjust visit spacing attr(mdl_tmp, \"visit_spacing\") <- c(1/30, 1/30)  tbl_prior_predictive_2 <- sample_predictive(   mdl_tmp,    sample = smpl_prior,   n_per_group = c(1L, 1L), # we only need one per arm here   nsim = 1000,    seed = 3423423 )  rm(mdl_tmp) # clean up  # compute PFS  tbl_pfs_times <- tbl_prior_predictive_2 %>%    # interval censoring can be ignored her, average to exact time   mutate(     t = (t_min + t_max) / 2   ) %>%    # no need to group by subject since only one per iteration and group   group_by(iter, group_id) %>%    summarize(     t = max(t[to == \"progression\"]), .groups = \"drop\"   )  ggplot(tbl_pfs_times) +   stat_ecdf(aes(t, color = group_id), geom = \"line\") +   coord_cartesian(xlim = c(0, 36)) +    scale_color_discrete(\"\") +    labs(y = \"Pr[no progression or death before t]\") +   theme(     panel.grid.minor = element_blank()   )"},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"building-a-visit-data-set","dir":"Articles","previous_headings":"Inference","what":"Building a visit data set","title":"Multi-State Models for Oncology","text":"Usually, data come form individual visits, yet form interval censored transitions. can mimic sake example converting one prior predictive samples visit data. Note conversion exact since mstate format contain information potential visits interval boundaries. Next, add recruitment times.","code":"tbl_visits <- tbl_prior_predictive %>%    filter(iter == 1) %>%    mstate_to_visits(mdl, .) #> 'mstate_to_visits.srp_model' is experimental  print(tbl_visits) #> # A tibble: 505 × 4 #>    subject_id group_id     t state       #>    <chr>      <chr>    <dbl> <chr>       #>  1 1          control    0   stable      #>  2 1          control    1.2 stable      #>  3 1          control    2.4 progression #>  4 10         control    0   stable      #>  5 10         control    1.2 stable      #>  6 10         control    2.4 stable      #>  7 10         control    3.6 stable      #>  8 10         control    4.8 stable      #>  9 10         control    6   stable      #> 10 10         control    7.2 stable      #> # … with 495 more rows #> # ℹ Use `print(n = ...)` to see more rows recruitment_rate_overall <- 3 # sample from poisson process set.seed(31532) tbl_sot <- tbl_visits %>%    select(     subject_id,      group_id   ) %>%    distinct() %>%    arrange(runif(n())) %>% # permute groups   mutate(     t_sot = cumsum(rexp(n = n(), rate = recruitment_rate_overall)) # poisson recruitment process   )  # add to visit times tbl_visits <- tbl_visits %>%    left_join(tbl_sot, by = c(\"subject_id\", \"group_id\")) %>%    mutate(t = t + t_sot) %>%    select(-t_sot)  # convert back to mstate format and plot tbl_visits %>%    visits_to_mstate(start_state = \"stable\", absorbing_states = \"progression\") %>%    plot_mstate(mdl, ., relative_to_sot = FALSE)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"a-hypothetical-interim-analysis","dir":"Articles","previous_headings":"Inference","what":"A hypothetical interim analysis","title":"Multi-State Models for Oncology","text":"now cut data 15 months first SoT, can imitate hypothetical interim analysis.  can check observed response rates. Careful, due different time--event biased. can now inference drawing sample posterior distribution. Clearly, extreme sample prior shift posterior compared prior expected.  Bayesian approach specifies full generative model. can used draw samples posterior predictive distribution individuals still risk ones yet recruited. process sampling prior predictive - just replacing prior distribution posterior distribution obtained conditioning available data. 15 months trial, still individuals recruited (final sample size set 30 per group). now sample recruitment dates randomization probabilities still---recruited individuals. hypothetical future first-visits can now combined interim data trajectories can sampled forward using already fitted posterior distribution.  Repeatedly sampling posterior-predictive distribution allows evaluate decision criterion full trial completed since individual-level data practically imputed using posterior predictive distribution. allows compute Probability Success, see [???].","code":"tbl_visits_interim <- tbl_visits %>%    filter(t <= 15)   # convert to mstate plot tbl_mstate_interim <- visits_to_mstate(   tbl_visits_interim,    start_state = \"stable\",    absorbing_states = \"progression\",    now = 15 ) plot_mstate(mdl, tbl_mstate_interim, relative_to_sot = FALSE, now = 15) # estimate of the response rates (biased due to missing!) tbl_mstate_interim %>%    filter(from == \"stable\", !is.na(to)) %>%    group_by(group_id) %>%    summarize(p_response = sum(to == \"response\")/n()) #> # A tibble: 2 × 2 #>   group_id     p_response #>   <chr>             <dbl> #> 1 control           0.214 #> 2 intervention      0.545 smpl_posterior <- sample_posterior(   mdl,    tbl_mstate_interim,    refresh = 500, nsim = 5000, warmup = 250, seed = 76947 ) #>  #> SAMPLING FOR MODEL 'srp_model' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 9.8e-05 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.98 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: Iteration:    1 / 5250 [  0%]  (Warmup) #> Chain 1: Iteration:  251 / 5250 [  4%]  (Sampling) #> Chain 1: Iteration:  750 / 5250 [ 14%]  (Sampling) #> Chain 1: Iteration: 1250 / 5250 [ 23%]  (Sampling) #> Chain 1: Iteration: 1750 / 5250 [ 33%]  (Sampling) #> Chain 1: Iteration: 2250 / 5250 [ 42%]  (Sampling) #> Chain 1: Iteration: 2750 / 5250 [ 52%]  (Sampling) #> Chain 1: Iteration: 3250 / 5250 [ 61%]  (Sampling) #> Chain 1: Iteration: 3750 / 5250 [ 71%]  (Sampling) #> Chain 1: Iteration: 4250 / 5250 [ 80%]  (Sampling) #> Chain 1: Iteration: 4750 / 5250 [ 90%]  (Sampling) #> Chain 1: Iteration: 5250 / 5250 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.934582 seconds (Warm-up) #> Chain 1:                10.2428 seconds (Sampling) #> Chain 1:                11.1773 seconds (Total) #> Chain 1:  plot(mdl, dt = c(0, 36), sample = smpl_posterior) smpl_posterior %>%    parameter_sample_to_tibble(mdl, .) %>%    filter(parameter == \"p\") %>%    group_by(group_id) %>%    summarize(     p_posterior_mean = median(value),      q25 = quantile(value, probs = .25),      q75 = quantile(value, probs = .75)   ) #> # A tibble: 2 × 4 #>   group_id     p_posterior_mean   q25   q75 #>   <chr>                   <dbl> <dbl> <dbl> #> 1 control                 0.227 0.176 0.285 #> 2 intervention            0.529 0.451 0.606 tbl_interim_sample_sizes <- tbl_mstate_interim %>%    select(group_id, subject_id) %>%    distinct() %>%    group_by(group_id) %>%    summarize(n = n())  print(tbl_interim_sample_sizes) #> # A tibble: 2 × 2 #>   group_id         n #>   <chr>        <int> #> 1 control         20 #> 2 intervention    20 tbl_to_be_recruited <- tibble(     group_id = tbl_interim_sample_sizes$group_id,     n_to_be_recruited = 30 - tbl_interim_sample_sizes$n     ) %>%    mutate(     tmp = purrr::map(       n_to_be_recruited,        ~tibble(         # use unique identifiers to avoid clashing between groups         subject_id = uuid::UUIDgenerate(n = .),         # sample recruitment times per group using half the overall          # recruitment rate         t_sot = cumsum(rexp(n = ., rate = recruitment_rate_overall/2))       )     )   ) %>%    select(-n_to_be_recruited) %>%    tidyr::unnest(tmp) %>%    # add information on starting state etc to expand to full mstate table   mutate(     from = \"stable\",     to = NA_character_,     t_min = t_sot + 1/30, # preclude events on the day of recruitment     t_max = Inf # right censored   )  tbl_to_be_recruited #> # A tibble: 20 × 7 #>    group_id     subject_id                        t_sot from  to     t_min t_max #>    <chr>        <chr>                             <dbl> <chr> <chr>  <dbl> <dbl> #>  1 control      382fec8f-ff08-47cb-8a87-18138b4…  0.151 stab… NA     0.184   Inf #>  2 control      96b43f50-8727-403a-8ca1-5542496…  1.33  stab… NA     1.36    Inf #>  3 control      a850c3f4-483a-4317-a63a-92120c0…  2.76  stab… NA     2.79    Inf #>  4 control      8f69af5f-187b-49ce-a636-50ba77e…  3.88  stab… NA     3.91    Inf #>  5 control      2af50606-5497-4728-9dcf-880c3ba…  4.79  stab… NA     4.82    Inf #>  6 control      607fddef-86b9-42a1-ab30-62e79d1…  6.10  stab… NA     6.13    Inf #>  7 control      fc3f564a-dea5-4e2e-b9c3-f223faa…  7.78  stab… NA     7.82    Inf #>  8 control      524e52fc-ed32-4985-b7d6-402b70d…  8.16  stab… NA     8.20    Inf #>  9 control      88e6369b-8265-4ef6-ba61-820533a… 10.0   stab… NA    10.1     Inf #> 10 control      0f54de33-8f36-4321-a9ad-94432d6… 13.9   stab… NA    13.9     Inf #> 11 intervention b02be37c-b0cc-4306-a67f-8f65fec…  0.554 stab… NA     0.587   Inf #> 12 intervention 3f0ecbfd-78af-46cb-8fc4-6301625…  0.724 stab… NA     0.758   Inf #> 13 intervention c2176ede-645f-4ef5-88aa-909ce90…  2.31  stab… NA     2.34    Inf #> 14 intervention c6324793-ddfb-48c6-a43f-f8ca5ee…  2.35  stab… NA     2.38    Inf #> 15 intervention 976fb7e1-c5bd-46e5-9e59-8ee3ebc…  2.88  stab… NA     2.92    Inf #> 16 intervention ca657d3e-60a9-4fd7-82a1-06906ff…  3.04  stab… NA     3.07    Inf #> 17 intervention 3df7ed11-4029-46b8-944e-5f92de1…  4.32  stab… NA     4.35    Inf #> 18 intervention bb4c18ca-7ec5-4957-9e9d-a6090e9…  5.15  stab… NA     5.18    Inf #> 19 intervention 90dfdf23-0909-4907-8bf7-f97734f…  6.29  stab… NA     6.33    Inf #> 20 intervention 44ae3292-d39c-4602-8b08-c92c08f…  6.52  stab… NA     6.55    Inf tbl_mstate_interim_forward <- bind_rows(tbl_mstate_interim, tbl_to_be_recruited)  tbl_posterior_predictive <- impute_predictive(     mdl,     data = tbl_mstate_interim_forward,      sample = smpl_posterior,     nsim = 1   )  plot_mstate(mdl, tbl_posterior_predictive, relative_to_sot = FALSE)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/multi-state-model-for-early-oncology.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Multi-State Models for Oncology","text":"","code":"sessionInfo() #> R version 4.2.1 (2022-06-23) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 20.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 #> LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_3.3.6      dplyr_1.0.9        oncomsm_0.1.0.9000 #>  #> loaded via a namespace (and not attached): #>  [1] Rcpp_1.0.9           tidyr_1.2.0          prettyunits_1.1.1    #>  [4] ps_1.7.1             visNetwork_2.1.0     rprojroot_2.0.3      #>  [7] digest_0.6.29        utf8_1.2.2           R6_2.5.1             #> [10] stats4_4.2.1         evaluate_0.16        highr_0.9            #> [13] pillar_1.8.0         rlang_1.0.4          uuid_1.1-0           #> [16] callr_3.7.1          jquerylib_0.1.4      rmarkdown_2.14       #> [19] DiagrammeR_1.0.9     pkgdown_2.0.6        labeling_0.4.2       #> [22] textshaping_0.3.6    desc_1.4.1           stringr_1.4.0        #> [25] htmlwidgets_1.5.4    loo_2.5.1            munsell_0.5.0        #> [28] compiler_4.2.1       xfun_0.32            rstan_2.21.5         #> [31] pkgconfig_2.0.3      systemfonts_1.0.4    pkgbuild_1.3.1       #> [34] htmltools_0.5.3      tidyselect_1.1.2     tibble_3.1.8         #> [37] gridExtra_2.3        codetools_0.2-18     matrixStats_0.62.0   #> [40] fansi_1.0.3          crayon_1.5.1         withr_2.5.0          #> [43] grid_4.2.1           jsonlite_1.8.0       gtable_0.3.0         #> [46] lifecycle_1.0.1      magrittr_2.0.3       StanHeaders_2.21.0-7 #> [49] scales_1.2.0         RcppParallel_5.1.5   cli_3.3.0            #> [52] stringi_1.7.8        cachem_1.0.6         farver_2.1.1         #> [55] fs_1.5.2             bslib_0.4.0          ellipsis_0.3.2       #> [58] ragg_1.2.2           generics_0.1.3       vctrs_0.4.1          #> [61] RColorBrewer_1.1-3   tools_4.2.1          glue_1.6.2           #> [64] purrr_0.3.4          processx_3.7.0       parallel_4.2.1       #> [67] fastmap_1.1.0        yaml_2.3.5           inline_0.3.19        #> [70] colorspace_2.0-3     memoise_2.0.1        knitr_1.39           #> [73] patchwork_1.1.1      sass_0.4.2"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kevin Kunzmann. Author, maintainer.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kunzmann K (2022). oncomsm: Bayesian Multi-State Models Early Oncology. https://boehringer-ingelheim.github.io/oncomsm/, https://github.com/Boehringer-Ingelheim/oncomsm.","code":"@Manual{,   title = {oncomsm: Bayesian Multi-State Models for Early Oncology},   author = {Kevin Kunzmann},   year = {2022},   note = {https://boehringer-ingelheim.github.io/oncomsm/, https://github.com/Boehringer-Ingelheim/oncomsm}, }"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"bayesian-multi-state-models-for-oncology","dir":"","previous_headings":"","what":"Bayesian Multi-State Models for Early Oncology","title":"Bayesian Multi-State Models for Early Oncology","text":"Tl;dr: package implements methods dynamically predict response progression individuals early oncology trials using parametric multi-state models Bayesian inference. allows dynamic computation “probability success” wide range success criteria.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bayesian Multi-State Models for Early Oncology","text":"","code":"# install.packages(\"remotes\") remotes::install_github(\"https://github.com/Boehringer-Ingelheim/oncomsm\")"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Bayesian Multi-State Models for Early Oncology","text":"package documentation hosted .","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"giving-feedback","dir":"","previous_headings":"Contributing","what":"Giving feedback","title":"Bayesian Multi-State Models for Early Oncology","text":"Even feel comfortable opening issue repository even pull request, feedback error reports highly valued. Just get touch maintainer directly try specific describing potential problem. Feature suggestions etc. better suited issue GitHub though ;)","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"updating-stan-models","dir":"","previous_headings":"Contributing","what":"Updating stan models","title":"Bayesian Multi-State Models for Early Oncology","text":"stan models contained inst/stan automatically updated avoid taking dependency rstantools package. modifying adding new models, run silence R/stanmodels.R via capture.output().","code":"rstantools::rstan_config()"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/Model.html","id":null,"dir":"Reference","previous_headings":"","what":"An abstract multi-state model class — Model","title":"An abstract multi-state model class — Model","text":"abstract class defining standard set methods implemented multi-state model. Objects class 'Model' instantiated directly. objects respective sub-classes can.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/Model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An abstract multi-state model class — Model","text":"","code":"# S3 method for Model sample_prior(   model,   warmup = 500L,   nsim = 2000L,   seed = NULL,   rstan_output = TRUE,   pars = attr(model, \"parameter_names\"),   ... )  # S3 method for Model sample_posterior(   model,   data,   warmup = 500L,   nsim = 2000L,   seed = NULL,   rstan_output = TRUE,   pars = attr(model, \"parameter_names\"),   ... )  # S3 method for Model sample_predictive(   model,   n_per_group,   sample = NULL,   nsim = 100L,   nsim_parameters = 1000L,   warmup_parameters = 250,   seed = NULL,   ... )  # S3 method for Model impute_predictive(   model,   data,   sample = NULL,   nsim = 1000L,   nsim_parameters = 1000L,   warmup_parameters = 250L,   seed = NULL,   ... )  # S3 method for Model parameter_sample_to_tibble(model, sample, ...)  # S3 method for Model plot_mstate(model, data, now, relative_to_sot, ...)  # S3 method for Model generate_visit_data(model, n_per_group, seed = NULL, ...)  # S3 method for Model sample_pfs_rate(   model,   t,   sample = NULL,   warmup = 500L,   nsim = 2000L,   seed = NULL,   ... )  # S3 method for Model mstate_to_visits(model, tbl_mstate, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/Model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"An abstract multi-state model class — Model","text":"model model class \"Model\" warmup integer, number warmup samples rstan sampler retaining samples; used tune hyperparameters MCMC algorithm. nsim number samples draw seed integer, fixed random seed; NULL fixed seed rstan_output logical, function returns raw rstan sample object set TRUE pars character vector parameter names sample; resorting model defaults NULL ... arguments passed method implementations data (multi-state) data frame impute trajectories . n_per_group integer vector number individuals per group. sample stanfit object containing samples. parameter samples represent parameter distribution predictive distribution averages. Technically, parameters resampled replacement sample match desired number imputations. nsim_parameters integer, number parameter samples warmup_parameters integer, number warmup samples rstan sampler retaining samples parameters. now current time relative start trial (sot) relative_to_sot Boolean, timeline relative start trial start treatment individual t vector time-points PFS rate computed tbl_mstate data table multi-state format. TODO: explain","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/generate_visit_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Visit data from a multi-state model — generate_visit_data","title":"Generate Visit data from a multi-state model — generate_visit_data","text":"Generate Visit data multi-state model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/generate_visit_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Visit data from a multi-state model — generate_visit_data","text":"","code":"generate_visit_data(model, n_per_group, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/generate_visit_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Visit data from a multi-state model — generate_visit_data","text":"model model class \"Model\" n_per_group integer vector number individuals per group. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute_predictive.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute data from predictive distribution — impute_predictive","title":"Impute data from predictive distribution — impute_predictive","text":"parameter sample provided, sample posterior predictive","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute_predictive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute data from predictive distribution — impute_predictive","text":"","code":"impute_predictive(   model,   data,   sample,   nsim,   nsim_parameters,   warmup_parameters,   seed,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute_predictive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute data from predictive distribution — impute_predictive","text":"model model class \"Model\" data (multi-state) data frame impute trajectories . sample stanfit object containing samples. parameter samples represent parameter distribution predictive distribution averages. Technically, parameters resampled replacement sample match desired number imputations. nsim number samples draw nsim_parameters integer, number parameter samples warmup_parameters integer, number warmup samples rstan sampler retaining samples parameters. seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute_predictive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute data from predictive distribution — impute_predictive","text":"data frame imputed version input data.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/logodds.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-odds function — logodds","title":"Log-odds function — logodds","text":"computed log odds probability.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/logodds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-odds function — logodds","text":"","code":"logodds(p)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/logodds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-odds function — logodds","text":"p numeric probabilities","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/logodds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-odds function — logodds","text":"log(p/(1-p))","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/mstate_to_visits.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert data from multi-state to visit format — mstate_to_visits","title":"Convert data from multi-state to visit format — mstate_to_visits","text":"still experimental since conversion 1:1. multi-state representation drops non-changing visits, hence exact visit data recovered form multi-state representation.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/mstate_to_visits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert data from multi-state to visit format — mstate_to_visits","text":"","code":"mstate_to_visits(model, tbl_mstate, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/mstate_to_visits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert data from multi-state to visit format — mstate_to_visits","text":"model model class \"Model\" tbl_mstate data table multi-state format. TODO: explain ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/mstate_to_visits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert data from multi-state to visit format — mstate_to_visits","text":"data frame (tibble) visit format, line corresponds individual visits.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/mstate_to_visits.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert data from multi-state to visit format — mstate_to_visits","text":"intermediate visits reconstructed using visit spacing information stored model.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/oncomsm-package.html","id":null,"dir":"Reference","previous_headings":"","what":"The oncomsm package. — oncomsm-package","title":"The oncomsm package. — oncomsm-package","text":"package implements methods dynamically predict response progression individuals early oncology trials using parametric multi-state models Bayesian inference. allows dynamic computation Probability Success wide range success criteria. inference implemented using stan.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/oncomsm-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The oncomsm package. — oncomsm-package","text":"Stan Development Team (2021). RStan: R interface Stan. R package version 2.21.3. https://mc-stan.org","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert stanfit sample to data table — parameter_sample_to_tibble","title":"Convert stanfit sample to data table — parameter_sample_to_tibble","text":"Convert stanfit sample data table","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert stanfit sample to data table — parameter_sample_to_tibble","text":"","code":"parameter_sample_to_tibble(model, sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert stanfit sample to data table — parameter_sample_to_tibble","text":"model model class \"Model\" sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert stanfit sample to data table — parameter_sample_to_tibble","text":"tibble sampled parameters long format","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":null,"dir":"Reference","previous_headings":"","what":"Swimmer-like plot of multi-state data — plot_mstate","title":"Swimmer-like plot of multi-state data — plot_mstate","text":"Swimmer-like plot multi-state data","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swimmer-like plot of multi-state data — plot_mstate","text":"","code":"plot_mstate(model, data, now, relative_to_sot, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Swimmer-like plot of multi-state data — plot_mstate","text":"model model class \"Model\" data data table multi-state data now current time relative start trial (sot) relative_to_sot Boolean, timeline relative start trial start treatment individual ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_pfs_rate.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from the progression-free-survival rate — sample_pfs_rate","title":"Sample from the progression-free-survival rate — sample_pfs_rate","text":"Progression-free-survival rate time t (PFS-t rate) function parameters given multi-state model. Hence prior posterior sample model gives rise sample corresponding PFS t rate.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_pfs_rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from the progression-free-survival rate — sample_pfs_rate","text":"","code":"sample_pfs_rate(model, t, sample, warmup, nsim, seed, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_pfs_rate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from the progression-free-survival rate — sample_pfs_rate","text":"model model class \"Model\" t vector time-points PFS rate computed sample stanfit object samples respective model. warmup integer, number warmup samples rstan sampler retaining samples; used tune hyperparameters MCMC algorithm. nsim number samples draw seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_pfs_rate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from the progression-free-survival rate — sample_pfs_rate","text":"data frame samples PFS rates time points vector t.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample model posterior parameters — sample_posterior","title":"Sample model posterior parameters — sample_posterior","text":"Posterior sample model parameters conditional data set.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample model posterior parameters — sample_posterior","text":"","code":"sample_posterior(model, data, warmup, nsim, seed, rstan_output, pars, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample model posterior parameters — sample_posterior","text":"model model class \"Model\" data data frame variables \"subject_id\", \"group_id\", \"t_recruitment\", \"dt1\" \"dt2\" dt1 minimal dt2 maximal time event question. Inf, individual never experience event. dt1 < Inf dt2 == Inf individual still risk. \"t_recruitment\", \"dt1\" \"dt2\" can also missing individual yet recruited. warmup integer, number warmup samples rstan sampler retaining samples; used tune hyperparameters MCMC algorithm. nsim number samples draw seed integer, fixed random seed; NULL fixed seed rstan_output logical, function returns raw rstan sample object set TRUE pars character vector parameter names sample; resorting model defaults NULL ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample model posterior parameters — sample_posterior","text":"tibble columns iter (integer), parameter (character), group_id (character), value (numeric) parameter samples long format (rstan_output == TRUE) rstanfit object.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data from predictive distribution of a model — sample_predictive","title":"Sample data from predictive distribution of a model — sample_predictive","text":"Sample data predictive distribution model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data from predictive distribution of a model — sample_predictive","text":"","code":"sample_predictive(   model,   n_per_group,   sample,   nsim,   nsim_parameters,   warmup_parameters,   seed,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample data from predictive distribution of a model — sample_predictive","text":"model model class \"Model\" n_per_group integer vector number individuals per group. sample stanfit object samples respective model. nsim number samples draw nsim_parameters integer, number parameter samples warmup_parameters integer, number warmup samples rstan sampler retaining samples parameters. seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample data from predictive distribution of a model — sample_predictive","text":"TODO:","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample model prior parameters — sample_prior","title":"Sample model prior parameters — sample_prior","text":"Sample model parameters model prior distribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample model prior parameters — sample_prior","text":"","code":"sample_prior(model, warmup, nsim, seed, rstan_output, pars, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample model prior parameters — sample_prior","text":"model model class \"Model\" warmup integer, number warmup samples rstan sampler retaining samples; used tune hyperparameters MCMC algorithm. nsim number samples draw seed integer, fixed random seed; NULL fixed seed rstan_output logical, function returns raw rstan sample object set TRUE pars character vector parameter names sample; resorting model defaults NULL ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample model prior parameters — sample_prior","text":"tibble columns iter (integer), parameter (character), group_id (character), value (numeric) parameter samples long format (rstan_output == TRUE) rstanfit object.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":null,"dir":"Reference","previous_headings":"","what":"A Stable-Response-Progression Model — mstate_to_visits.srp_model","title":"A Stable-Response-Progression Model — mstate_to_visits.srp_model","text":"Create new instance SRP model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Stable-Response-Progression Model — mstate_to_visits.srp_model","text":"","code":"# S3 method for srp_model mstate_to_visits(model, tbl_mstate, ...)  create_srp_model(   group_id,   logodds_mean,   logodds_sd,   median_time_to_next_event_mean,   median_time_to_next_event_sd,   visit_spacing,   logodds_min = rep(logodds(0.001), length(group_id)),   logodds_max = rep(logodds(0.999), length(group_id)),   shape_min = matrix(0.99, nrow = length(group_id), ncol = 3),   shape_max = matrix(1.01, nrow = length(group_id), ncol = 3) )  # S3 method for srp_model plot_mstate(   model,   data,   now = max(tbl_mstate$t_max),   relative_to_sot = TRUE,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Stable-Response-Progression Model — mstate_to_visits.srp_model","text":"model model class \"Model\" tbl_mstate data table multi-state format. TODO: explain ... arguments passed method implementations group_id character vector group ids, used check compatibility data later logodds_mean vector means (truncated) normal priors log-odds response probability logodds_sd vector standard deviations (truncated) normal priors log-odds response probability median_time_to_next_event_mean matrix means (truncated) normal priors median time next event Weibull transition probabilities, (,j)-th entry -th group median time next event transition j (1=stable-response, 2=stable-progression, 3=response-progression) median_time_to_next_event_sd matrix standard deviations (truncated) normal priors median time next event Weibull transition probabilities, (,j)-th entry -th group median time next event transition j (1=stable-response, 2=stable-progression, 3=response-progression) visit_spacing vector time differences visits per group logodds_min lower boundary log-odds per group logodds_max upper boundary log-odds per group shape_min matrix lower boundaries uniform prior Weibull distribution per group/transition shape_max matrix upper boundaries uniform prior Weibull distribution per group/transition data data table multi-state data now current time relative start trial (sot) relative_to_sot Boolean, timeline relative start trial start treatment individual","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A Stable-Response-Progression Model — mstate_to_visits.srp_model","text":"TODO","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert longitudinal visit data to time-to-event data — visits_to_mstate","title":"Convert longitudinal visit data to time-to-event data — visits_to_mstate","text":"Convert longitudinal visit data time--event data","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert longitudinal visit data to time-to-event data — visits_to_mstate","text":"","code":"visits_to_mstate(   tbl_visits,   start_state,   absorbing_states,   now = max(tbl_visits$t),   eof_indicator = \"EOF\" )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert longitudinal visit data to time-to-event data — visits_to_mstate","text":"tbl_visits visit data long format start_state staring state absorbing_states character vector absorbing states now time point since start trial (might later last recorded visit) eof_indicator state name indicating (exactly observed) eond follow .","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert longitudinal visit data to time-to-event data — visits_to_mstate","text":"data frame","code":""}]
