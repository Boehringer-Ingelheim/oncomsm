[{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contribution Guidelines","title":"Contribution Guidelines","text":"üôè Thank taking time contribute! input deeply valued, whether issue, pull request, even feedback, regardless size, content scope.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"table-of-contents","dir":"","previous_headings":"","what":"Table of contents","title":"Contribution Guidelines","text":"üóÉ License üìú Issues üö© Pull requests üëó Style guide üèÜ Recognition model ‚ùì Questions","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Contribution Guidelines","text":"contributions covered project‚Äôs license.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"Contribution Guidelines","text":"use GitHub track issues, feature requests, bugs. submitting new issue, please check issue already reported. issue already exists, please upvote existing issue üëç. reporting bug, please try specific possible describing provide minimal reproducible example (possible). new feature requests, please elaborate context benefit feature users, developers, relevant personas.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"proposing-changes-to-the-code","dir":"","previous_headings":"","what":"Proposing changes to the code","title":"Contribution Guidelines","text":"repository uses Github flow model collaboration. submit pull request: Create branch. Please see branch naming convention . don‚Äôt write access repository, please fork . Make changes. Make sure code: passes checks imposed GitHub Actions well documented well tested unit tests sufficiently covering changes introduced Create pull request (PR). pull request description, please link relevant issue (), provide detailed description change, include assumptions. Address review comments, (let reviewer know). Receive approval. Merge PR write access. Otherwise, reviewer merge PR behalf. Pat back. Congratulations! üéâ now official contributor project! grateful contribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"style-guide","dir":"","previous_headings":"","what":"Style guide","title":"Contribution Guidelines","text":"repository follows standard tidyverse style guide uses lintr lint checks. Customized lint configurations available repository‚Äôs .lintr file.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"updating-stan-models","dir":"","previous_headings":"","what":"Updating stan models","title":"Contribution Guidelines","text":"stan models contained inst/stan automatically updated avoid taking dependency rstantools package. modifying adding new models, run silence R/stanmodels.R via capture.output().","code":"rstantools::rstan_config()"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"recognition-model","dir":"","previous_headings":"","what":"Recognition model","title":"Contribution Guidelines","text":"currently formal recognition model place. expect recognition certain kind contribution, make sure clarify package maintainer advance.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/CONTRIBUTING.html","id":"questions","dir":"","previous_headings":"","what":"Questions","title":"Contribution Guidelines","text":"questions regarding contribution guidelines, please contact package/repository maintainer.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/bhmbasket-integration.html","id":"defining-go-decision","dir":"Articles","previous_headings":"","what":"Defining ‚Äògo‚Äô decision","title":"Integration with bhmbasket","text":"bhmbasket package implements dynamic borrowing arms basket trials via Bayesian hierarchical models (BHMs). , demonstrate oncomsm prior specified mdl can used derive probability ‚Äògo‚Äô based bhmbasket analysis. use ‚ÄúBerry‚Äù type model analysis response data use posterior \\(0.25\\) quantile response probability \\(0.3\\) declare ‚Äògo‚Äô. means individual arm developed \\(0.75\\) posterior probability according BHM response rate larger \\(0.3\\).","code":"go <- function(data, nsim = 250) {   set.seed(2340239L)   # convert data to bhmbasket format (multi-state to binary counts)   data <- data %>%     group_by(group_id, subject_id) %>%     summarize(       responder = any(state == \"response\"),       .groups = \"drop_last\"     ) %>%     summarize(       r = sum(responder),       n = n(),     ) %>%     {       bhmbasket::createTrial(.$n, .$r)     }   # define Berry model in bhmbasket   prms_berry <- bhmbasket::setPriorParametersBerry(     mu_mean   = bhmbasket::logit(0.25),     mu_sd     = 1,     tau_scale = 1   )   # perform analysis in bhmbasket   res <- suppressMessages(bhmbasket::performAnalyses(     scenario_list         = data,     method_names          = \"berry\",     evidence_levels       = 1 - 0.25,     prior_parameters_list = prms_berry,     target_rates          = c(.2, .3, .3),     n_mcmc_iterations     = nsim,     verbose               = FALSE   ))   # 'go' if posterior quantile of response rate is sufficiently large   return(tibble(     group_id = attr(mdl, \"group_id\"),     go = res$scenario_1$quantiles_list$berry[[1]][5, 2:4] >= .3   )) }"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/bhmbasket-integration.html","id":"sample-from-the-prior-predictive","dir":"Articles","previous_headings":"","what":"Sample from the prior predictive","title":"Integration with bhmbasket","text":"probability ‚Äògo‚Äô planning stage can computed sampling prior-predictive distribution applying defined ‚Äògo‚Äô criterion. Next, data can nested iteration (resample) fo facilitate processing per-dataset basis.","code":"tbl_prior_predictive <- sample_predictive(     mdl,     n_per_group = rep(40L, 3),     nsim = 250L,     seed = 34930L   )  tbl_prior_predictive #> # A tibble: 466,848 √ó 5 #>    subject_id group_id     t state     iter #>    <chr>      <chr>    <dbl> <chr>    <int> #>  1 ID00153525 C         26.9 stable       1 #>  2 ID00153525 C         28.1 stable       1 #>  3 ID00153525 C         29.3 stable       1 #>  4 ID00153525 C         30.5 stable       1 #>  5 ID00153525 C         31.7 stable       1 #>  6 ID00153525 C         32.9 stable       1 #>  7 ID00153525 C         34.1 stable       1 #>  8 ID00153525 C         35.3 stable       1 #>  9 ID00153525 C         36.5 stable       1 #> 10 ID00153525 C         37.7 response     1 #> # ‚Ä¶ with 466,838 more rows tbl_prior_predictive <- tbl_prior_predictive %>%   group_by(iter) %>%   tidyr::nest() %>%   ungroup()  tbl_prior_predictive #> # A tibble: 250 √ó 2 #>     iter data                 #>    <int> <list>               #>  1     1 <tibble [1,790 √ó 4]> #>  2     2 <tibble [1,838 √ó 4]> #>  3     3 <tibble [1,513 √ó 4]> #>  4     4 <tibble [1,731 √ó 4]> #>  5     5 <tibble [1,743 √ó 4]> #>  6     6 <tibble [1,882 √ó 4]> #>  7     7 <tibble [1,482 √ó 4]> #>  8     8 <tibble [1,775 √ó 4]> #>  9     9 <tibble [1,977 √ó 4]> #> 10    10 <tibble [2,082 √ó 4]> #> # ‚Ä¶ with 240 more rows"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/bhmbasket-integration.html","id":"calculate-probability-of-go","dir":"Articles","previous_headings":"","what":"Calculate probability of ‚Äògo‚Äô","title":"Integration with bhmbasket","text":"‚Äògo‚Äô criterion can applied resampled data sets. Finally, probability ‚Äògo‚Äô can computed average ‚Äògo‚Äô rate.","code":"tbl_results <- tbl_prior_predictive %>%   mutate(     res = furrr::future_map(       data, go,       .options = furrr::furrr_options(seed = TRUE)     )   ) %>%   select(-data) %>%   tidyr::unnest(res)  tbl_results #> # A tibble: 750 √ó 3 #>     iter group_id go    #>    <int> <chr>    <lgl> #>  1     1 A        TRUE  #>  2     1 B        FALSE #>  3     1 C        TRUE  #>  4     2 A        FALSE #>  5     2 B        FALSE #>  6     2 C        TRUE  #>  7     3 A        FALSE #>  8     3 B        TRUE  #>  9     3 C        TRUE  #> 10     4 A        FALSE #> # ‚Ä¶ with 740 more rows tbl_results %>%   group_by(group_id) %>%   summarize(     `Pr[go]` = mean(go)   ) #> # A tibble: 3 √ó 2 #>   group_id `Pr[go]` #>   <chr>       <dbl> #> 1 A           0.224 #> 2 B           0.604 #> 3 C           0.864"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"specifying-the-model","dir":"Articles","previous_headings":"","what":"Specifying the model","title":"Multi-State Models for Oncology","text":"following code defined prior assumptions two-group trial visit-spacing 1.2 months, .e., 6 weeks. model assumptions can visualized sampling prior.","code":"mdl <- create_srp_model(   # names of the arms/groups   group_id = c(\"A\", \"B\"),   # per-group logodds of response|stable   logodds_mean = c(logodds(.4), logodds(.6)),   logodds_sd = c(1, 1),   # m[i,j] is the median time to next event for group i and transition j   median_time_to_next_event = matrix(c(     3, 2, 6,     2, 8, 12   ), byrow = TRUE, nrow = 2, ncol = 3),   # fixed standard deviation of the prior for all median times   median_time_to_next_event_sd = matrix(     1,     byrow = TRUE, nrow = 2, ncol = 3   ),   # the visit interval   visit_spacing = c(1.2, 1.2) )  print(mdl) #> srp_model<A,B>"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"prior-checks","dir":"Articles","previous_headings":"","what":"Prior checks","title":"Multi-State Models for Oncology","text":"First, plot cumulative distribution functions (CDF) time--next-event first 36 (months) CDF response probabilities per group. based sample drawn prior distribution model. can re-use parameter sample sampling prior-predictive distribution separating sampling plotting steps. Often, rate progression free survival (PFS) particular time point interest. quantity direct function model parameters. Since simplified model distinguish progression death, denote combined endpoint ‚Äúprogression‚Äù. \\[ \\begin{align} \\operatorname{PFS}(t) :&= \\operatorname{Pr}\\big[\\,\\text{progression } t\\,\\big] \\\\   &= 1 - \\operatorname{Pr}\\big[\\,\\text{progression } t\\,] \\\\   &= 1 - \\Big(\\ \\operatorname{Pr}\\big[\\,\\text{progression } t\\,|\\, \\text{response}\\,]\\cdot\\operatorname{Pr}\\big[\\,\\text{response}\\,] \\\\   &\\qquad+ \\operatorname{Pr}\\big[\\,\\text{progression } t\\,|\\, \\text{response}\\,]\\cdot\\operatorname{Pr}\\big[\\,\\text{response}\\,] \\ \\Big)\\\\   &= 1 - p\\cdot\\int_0^t f_1(u) \\cdot F_3(t - u) \\operatorname{d}u - (1 - p)\\cdot F_2(t) \\ . \\end{align} \\] integral arises need reflect uncertainty state change ‚Äústable‚Äù ‚Äúresponse‚Äù way ‚Äúprogression‚Äù. parameter sample thus also induces sample PFS rate given time point curve PFS rate time corresponds survival function ‚Äúprogression death‚Äù event.","code":"smpl_prior <- sample_prior(mdl, seed = 36L)  # plot(mdl) also works but need to resample prior further below plot(mdl, parameter_sample = smpl_prior)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"sampling-from-the-prior-predictive-distribution","dir":"Articles","previous_headings":"","what":"Sampling from the prior-predictive distribution","title":"Multi-State Models for Oncology","text":"Next, draw samples prior-predictive distribution model. sample 100 trials 30 individuals per arm. , can re-use sample prior sample already used plotting. can run quick checks sampled data, e.g., observed response rates. crude approximation median transition times can compared prior means. default, prior predictive distribution given terms panel visit data. data can transformed interval-censored multi-state representation, (first sampled trial). multi-state data can visualized swimmer plots.  also possible simulate prior predictive distribution fixing parameter values. Fixing parameter values can interpreted conditioning parameters. instance one set response probabilities fixed values \\(0.1\\) \\(0.9\\):","code":"tbl_prior_predictive <- sample_predictive(   mdl,   sample = smpl_prior,   n_per_group = c(30L, 30L),   nsim = 100,   seed = 342 )  print(tbl_prior_predictive, n = 25) #> # A tibble: 67,938 √ó 5 #>    subject_id group_id     t state     iter #>    <chr>      <chr>    <dbl> <chr>    <int> #>  1 ID00010865 B         11.2 stable       1 #>  2 ID00010865 B         12.4 stable       1 #>  3 ID00010865 B         13.6 stable       1 #>  4 ID00010865 B         14.8 response     1 #>  5 ID00010865 B         16.0 response     1 #>  6 ID00010865 B         17.2 response     1 #>  7 ID00010865 B         18.4 response     1 #>  8 ID00010865 B         19.6 response     1 #>  9 ID00010865 B         20.8 response     1 #> 10 ID00010865 B         22.0 response     1 #> 11 ID00010865 B         23.2 response     1 #> 12 ID00010865 B         24.4 response     1 #> 13 ID00010865 B         25.6 response     1 #> 14 ID00010865 B         26.8 response     1 #> 15 ID00010865 B         28.0 response     1 #> 16 ID00010865 B         29.2 response     1 #> 17 ID00010865 B         30.4 response     1 #> 18 ID00010865 B         31.6 response     1 #> 19 ID00010865 B         32.8 response     1 #> 20 ID00010865 B         34.0 response     1 #> 21 ID00010865 B         35.2 response     1 #> 22 ID00010865 B         36.4 response     1 #> 23 ID00010865 B         37.6 response     1 #> 24 ID00010865 B         38.8 response     1 #> 25 ID00010865 B         40.0 response     1 #> # ‚Ä¶ with 67,913 more rows tbl_prior_predictive %>%   group_by(group_id, iter, subject_id) %>%   summarize(     responder = any(state == \"response\"),     .groups = \"drop\"   ) %>%   group_by(group_id) %>%   summarize(     p_response = mean(responder),     se = sd(responder) / sqrt(n())   ) #> # A tibble: 2 √ó 3 #>   group_id p_response      se #>   <chr>         <dbl>   <dbl> #> 1 A             0.367 0.00880 #> 2 B             0.559 0.00907 tbl_prior_predictive %>%   distinct(subject_id, iter, state, .keep_all = TRUE) %>%   group_by(iter, group_id, subject_id) %>%   summarize(     dt = t - lag(t),     from = lag(state),     to = state,     .groups = \"drop\"   ) %>%   filter(to != \"stable\") %>%   group_by(group_id, from, to) %>%   summarize(     `median transition time` = median(dt),     .groups = \"drop\"   ) #> # A tibble: 6 √ó 4 #>   group_id from     to          `median transition time` #>   <chr>    <chr>    <chr>                          <dbl> #> 1 A        response progression                     6    #> 2 A        stable   progression                     2.4  #> 3 A        stable   response                        3.60 #> 4 B        response progression                    12    #> 5 B        stable   progression                     8.4  #> 6 B        stable   response                        2.4 tbl_mstate <- tbl_prior_predictive %>%   filter(iter == 1) %>%   visits_to_mstate(mdl)  tbl_mstate #> # A tibble: 92 √ó 7 #>    subject_id group_id from     to          t_min t_max t_sot #>    <chr>      <chr>    <chr>    <chr>       <dbl> <dbl> <dbl> #>  1 ID00010865 B        stable   response    13.6  14.8  11.2  #>  2 ID00010865 B        response progression 55.6  56.8  11.2  #>  3 ID00019694 B        stable   progression 33.8  35.0  18.2  #>  4 ID00294641 B        stable   progression 28.6  29.8  23.8  #>  5 ID00559801 B        stable   response    22.9  24.1  22.9  #>  6 ID00559801 B        response progression 43.3  44.5  22.9  #>  7 ID00827488 A        stable   progression 13.2  14.4   7.19 #>  8 ID01007254 A        stable   response    24.6  25.8  23.4  #>  9 ID01007254 A        response progression 34.2  35.4  23.4  #> 10 ID01039842 A        stable   response     1.45  2.65  1.45 #> # ‚Ä¶ with 82 more rows plot_mstate(tbl_mstate, mdl) sample_predictive(     mdl,     sample = smpl_prior,     p = c(0.1, 0.9),     n_per_group = c(30L, 30L),     nsim = 100,     seed = 3423423   ) %>%   group_by(group_id, iter, subject_id) %>%   summarize(     responder = any(state == \"response\"),     .groups = \"drop\"   ) %>%   group_by(group_id) %>%   summarize(     p_response = mean(responder),     se = sd(responder) / sqrt(n())   ) #> # A tibble: 2 √ó 3 #>   group_id p_response      se #>   <chr>         <dbl>   <dbl> #> 1 A             0.093 0.00530 #> 2 B             0.863 0.00628"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"a-hypothetical-interim-analysis","dir":"Articles","previous_headings":"","what":"A hypothetical interim analysis","title":"Multi-State Models for Oncology","text":"First, sample single data set extreme response probabilities deviate chosen prior. data can curtailed hypothetical interim time-point simply filtering visit time-points. censoring interim data can visualized swimmer plot .  can check observed response rates . Due censoring interim time point, response rate estimate biased. Instead, one can now inference drawing sample posterior distribution account censoring. Since data conflicts prior, posterior mass move direction observed response rates.","code":"tbl_data_interim <- sample_predictive(     mdl,     sample = smpl_prior,     p = c(0.2, 0.8),     n_per_group = c(30L, 30L),     nsim = 1,     seed = 42L   ) %>%   filter(     t <= 15   ) tbl_data_interim %>%   visits_to_mstate(mdl, now = 15) %>%   plot_mstate(mdl, relative_to_sot = FALSE, now = 15) tbl_data_interim %>%   group_by(group_id, iter, subject_id) %>%   summarize(     responder = any(state == \"response\"),     .groups = \"drop\"   ) %>%   group_by(group_id) %>%   summarize(     p_response = mean(responder),     se = sd(responder) / sqrt(n())   ) #> # A tibble: 2 √ó 3 #>   group_id p_response    se #>   <chr>         <dbl> <dbl> #> 1 A             0.143 0.143 #> 2 B             0.7   0.153 smpl_posterior <- sample_posterior(mdl, tbl_data_interim, seed = 43L)  plot(mdl, parameter_sample = smpl_posterior) # plot under posterior # calculate posterior quantiles of response probability smpl_posterior %>%   parameter_sample_to_tibble(mdl, .) %>%   filter(parameter == \"p\") %>%   group_by(group_id) %>%   summarize(     p_posterior_mean = median(value),     q25 = quantile(value, probs = .25),     q75 = quantile(value, probs = .75)   ) #> # A tibble: 2 √ó 4 #>   group_id p_posterior_mean   q25   q75 #>   <chr>               <dbl> <dbl> <dbl> #> 1 A                   0.287 0.203 0.395 #> 2 B                   0.838 0.763 0.894"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/oncomsm.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Multi-State Models for Oncology","text":"","code":"sessionInfo() #> R version 4.2.2 (2022-10-31) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 22.04.1 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_3.4.0      dplyr_1.0.10       oncomsm_0.1.1.9000 #>  #> loaded via a namespace (and not attached): #>  [1] Rcpp_1.0.9           tidyr_1.2.1          prettyunits_1.1.1    #>  [4] ps_1.7.2             visNetwork_2.1.2     rprojroot_2.0.3      #>  [7] digest_0.6.30        utf8_1.2.2           R6_2.5.1             #> [10] backports_1.4.1      stats4_4.2.2         evaluate_0.18        #> [13] highr_0.9            pillar_1.8.1         rlang_1.0.6          #> [16] callr_3.7.3          jquerylib_0.1.4      checkmate_2.1.0      #> [19] rmarkdown_2.18       DiagrammeR_1.0.9     pkgdown_2.0.6        #> [22] labeling_0.4.2       textshaping_0.3.6    desc_1.4.2           #> [25] stringr_1.4.1        htmlwidgets_1.5.4    loo_2.5.1            #> [28] munsell_0.5.0        compiler_4.2.2       xfun_0.35            #> [31] rstan_2.21.7         pkgconfig_2.0.3      systemfonts_1.0.4    #> [34] pkgbuild_1.3.1       htmltools_0.5.3      tidyselect_1.2.0     #> [37] tibble_3.1.8         gridExtra_2.3        codetools_0.2-18     #> [40] matrixStats_0.63.0   fansi_1.0.3          crayon_1.5.2         #> [43] withr_2.5.0          grid_4.2.2           jsonlite_1.8.3       #> [46] gtable_0.3.1         lifecycle_1.0.3      magrittr_2.0.3       #> [49] StanHeaders_2.21.0-7 scales_1.2.1         RcppParallel_5.1.5   #> [52] cli_3.4.1            stringi_1.7.8        cachem_1.0.6         #> [55] farver_2.1.1         fs_1.5.2             bslib_0.4.1          #> [58] ellipsis_0.3.2       ragg_1.2.4           generics_0.1.3       #> [61] vctrs_0.5.1          RColorBrewer_1.1-3   tools_4.2.2          #> [64] glue_1.6.2           purrr_0.3.5          processx_3.8.0       #> [67] parallel_4.2.2       fastmap_1.1.0        yaml_2.3.6           #> [70] RcppNumerical_0.4-0  inline_0.3.19        colorspace_2.0-3     #> [73] memoise_2.0.1        knitr_1.41           patchwork_1.1.2      #> [76] sass_0.4.4"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/application-to-probability-of-success.html","id":"decision-criteria-and-probability-of-go","dir":"Articles > Web_only","previous_headings":"","what":"Decision criteria and probability of ‚Äògo‚Äô","title":"Application to Probability of 'go'","text":"Let \\(D_t \\\\mathbb{D}\\) observed (visit) data time point \\(t\\) start trial. Let \\(\\tau\\) stopping time trial, e.g., time point \\(n\\) individuals recruited reached minimal follow-. final decision ‚Äògo‚Äô can modeled function \\(\\phi: \\mathbb{D} \\\\{0,1\\}\\) \\[\\phi(D_\\tau)=1 :\\Leftrightarrow D_\\tau\\ \\ \\text{leads 'go'}\\ . \\] Let \\(\\theta\\) vector parameters generative model allows sample data \\(D_\\tau|\\theta\\). Probability ‚Äògo‚Äô can calculated expected value decision rule prior distribution (density) \\(f(\\theta)\\) parameter space: \\[ \\operatorname{Pr}\\big[\\,go\\,\\big] = \\int \\phi(D_\\tau\\,|\\,\\theta) \\cdot f(\\theta) \\operatorname{d}\\theta \\ . \\] practice, integral can approximated sampling generative model calculating average ‚Äògo‚Äô rate. data \\(D_t=d_t\\) observed, probability ‚Äògo‚Äô can updated using Bayes Theorem \\[ \\operatorname{Pr}\\big[\\,go\\,|\\, D_t=d_t \\,\\big] = \\int \\phi(D_\\tau\\,|\\,D_t=d_t,\\theta) \\cdot f(\\theta\\,|\\,D_t=d_t) \\operatorname{d}\\theta \\] \\(f(\\theta\\,|\\,D_t=d_t)\\) posterior density given data \\(d_t\\) observed time \\(t\\). Examples decision rules quantile posterior distribution response rate certain relevance threshold, quantile posterior distribution PFS6 rate certain relevance threshold, quantile posterior distribution PFS certain threshold, combination . Consider situation trial including two different arms ‚Äú‚Äù ‚ÄúB‚Äù. Assume following prior Weibull SRP multi-state model three arms/groups given. One can now sample prior visualize prior assumptions.","code":"mdl <- create_srp_model(   group_id = c(\"A\", \"B\"),   logodds_mean = logodds(c(0.1, 0.9)),   logodds_sd = rep(3, 2L),   median_time_to_next_event = matrix(c(     2, 6, 24,     2, 6, 24   ), byrow = TRUE, nrow = 2, ncol = 3),   median_time_to_next_event_sd = matrix(3, byrow = TRUE, nrow = 2, ncol = 3),   visit_spacing = rep(1.2, 2),   recruitment_rate = c(40 / 24, 40 / 24) ) smpl_prior <- sample_prior(mdl, seed = 6835L)  plot(mdl, parameter_sample = smpl_prior)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/application-to-probability-of-success.html","id":"a-composite-orr-and-pfs12-go-criterion","dir":"Articles > Web_only","previous_headings":"","what":"A composite ORR and PFS12 ‚Äògo‚Äô criterion","title":"Application to Probability of 'go'","text":"Assume ‚Äògo‚Äô defined combination sufficiently high response rate sufficiently high progression-free-survival rate 12 months: \\[\\phi(D_\\tau) := \\begin{cases}   1 \\quad \\text{} \\quad \\operatorname{Pr}\\big[\\,\\text{ORR} \\geq 0.3\\ \\&\\ \\text{PFS}_{t=12} \\geq 0.4 \\, | \\, D_\\tau\\,\\big] \\geq 0.8 \\\\   0 \\quad \\text{else.}   \\end{cases}\\] decision criterion can implemented following function: example apply criterion sample prior predictive distribution given : Next, can create table multiple prior-predictive samples. Grouping iteration nesting data frames results data frame data frames, tbl_prior_predictive$data[[]] corresponds data \\(\\)-th resample. Applying decision criterion averaging iterations MCMC approximation probability ‚Äògo‚Äô.","code":"go <- function(data, nsim = 200L) {   set.seed(3819308) # fix the seed for reproducibility   smpl <- suppressWarnings( # low sample size leads to stan warnings on ESS                             # can be ignored, errors average out                             # can also be avoided by increasing nsim     sample_posterior(mdl, data = data, warmup = 200L, nsim = nsim)   )   tbl_pfs_orr <- bind_cols(       compute_pfs(mdl, 12, smpl), # PFS 12       parameter_sample_to_tibble(mdl, smpl) %>% # ORR         filter(parameter == \"p\") %>%         transmute(orr = value)     )   res <- tbl_pfs_orr %>% # apply decision criterion     group_by(group_id) %>%     summarize(       go = mean(pfs >= 0.5 & orr >= 0.3) >= 0.8     )   return(res) } tbl_prior_predictive <- sample_predictive(     mdl,     n_per_group = rep(40L, 2),     sample = smpl_prior,     nsim = 1L,     seed = 34930L   )  go(tbl_prior_predictive) #> # A tibble: 2 √ó 2 #>   group_id go    #>   <chr>    <lgl> #> 1 A        FALSE #> 2 B        FALSE tbl_prior_predictive <- sample_predictive(     mdl,     n_per_group = rep(40L, 2),     sample = smpl_prior,     nsim = 100L, # same, here, only for demonstration purposes     seed = 34930L   ) %>%   group_by(iter) %>%   tidyr::nest() %>%   ungroup()  print(tbl_prior_predictive) #> # A tibble: 100 √ó 2 #>     iter data                 #>    <int> <list>               #>  1     1 <tibble [1,443 √ó 4]> #>  2     2 <tibble [1,637 √ó 4]> #>  3     3 <tibble [1,152 √ó 4]> #>  4     4 <tibble [2,335 √ó 4]> #>  5     5 <tibble [1,704 √ó 4]> #>  6     6 <tibble [1,743 √ó 4]> #>  7     7 <tibble [1,715 √ó 4]> #>  8     8 <tibble [938 √ó 4]>   #>  9     9 <tibble [1,795 √ó 4]> #> 10    10 <tibble [1,964 √ó 4]> #> # ‚Ä¶ with 90 more rows # compute results in parallel res <- foreach(i = seq_len(nrow(tbl_prior_predictive))) %dorng% {   go(tbl_prior_predictive$data[[i]]) }  # bind results together and aggregate to probability of 'go' tbl_pr_go <- bind_rows(res, .id = \"iter\") %>%   group_by(group_id) %>%   summarize(     `Pr[go]` = mean(go),     se  = sd(go) / sqrt(n())   )  print(tbl_pr_go) #> # A tibble: 2 √ó 3 #>   group_id `Pr[go]`     se #>   <chr>       <dbl>  <dbl> #> 1 A            0.15 0.0359 #> 2 B            0.19 0.0394"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/application-to-probability-of-success.html","id":"updating-the-probability-of-go-during-a-trial","dir":"Articles > Web_only","previous_headings":"","what":"Updating the probability of ‚Äògo‚Äô during a trial","title":"Application to Probability of 'go'","text":"Bayesian generative model allows calculating posterior distribution time point given data observed point. future course trial can sampled posterior predictive distribution. illustrate shift ‚Äògo‚Äô probability time, single trial realization set fixed response probabilities conflict prior mean sampled hypothetical data. data accrues, evidence lead shift posterior probability thus probability ‚Äògo‚Äô. Next, interim views full data set sequence time points can created. data subsets correspond data available potential interim analyses. interim data set, remainder trial can imputed sampling form posterior-predictive distribution given data observed point. probability ‚Äògo‚Äô average ‚Äògo‚Äô rate posterior predictive sample applying decision criterion. First, calculation probability ‚Äògo‚Äô wrapped function accepts dataset (tbl) number resamples (nsim). Next, function mapped interim time points respective interim data. number simulations main factor determining runtime program besides number samples drawn posterior distribution evaluate decision criterion. change ‚Äògo‚Äô probability time shown error bars corresponding standard error simulation.  can compared number available responses, progressions, stable individuals time point.","code":"tbl_data <- sample_predictive(     mdl,     p = c(0.65, 0.45), ## conflicting prior expectation     n_per_group = c(40L, 40L),     nsim = 1,     seed = 23849   )  print(tbl_data) #> # A tibble: 1,875 √ó 5 #>    subject_id group_id     t state   iter #>    <chr>      <chr>    <dbl> <chr>  <int> #>  1 ID00326638 A         4.84 stable     1 #>  2 ID00326638 A         6.04 stable     1 #>  3 ID00326638 A         7.24 stable     1 #>  4 ID00326638 A         8.44 stable     1 #>  5 ID00326638 A         9.64 stable     1 #>  6 ID00326638 A        10.8  stable     1 #>  7 ID00326638 A        12.0  stable     1 #>  8 ID00326638 A        13.2  stable     1 #>  9 ID00326638 A        14.4  stable     1 #> 10 ID00326638 A        15.6  stable     1 #> # ‚Ä¶ with 1,865 more rows tbl_data_interims <- tibble(     t_interim = c(1, 3, 6, 9, 12, 18, 24, 36) # interim time point (months)   ) %>%   mutate(     data = purrr::map(t_interim, ~filter(tbl_data, t <= .))   )  print(tbl_data_interims) #> # A tibble: 8 √ó 2 #>   t_interim data                 #>       <dbl> <list>               #> 1         1 <tibble [6 √ó 5]>     #> 2         3 <tibble [26 √ó 5]>    #> 3         6 <tibble [74 √ó 5]>    #> 4         9 <tibble [135 √ó 5]>   #> 5        12 <tibble [221 √ó 5]>   #> 6        18 <tibble [435 √ó 5]>   #> 7        24 <tibble [724 √ó 5]>   #> 8        36 <tibble [1,149 √ó 5]> pr_go <- function(tbl, nsim) {   # sample forward from the posterior predictive distribution given data in tbl   tbl_posterior_predictive <- impute(       mdl, tbl, n_per_group = rep(40L, 2), nsim = nsim     ) %>%     group_by(iter) %>%     tidyr::nest()   # determine for each sampled trial whether it ends in a 'go'   res <- foreach(i = 1:nsim) %dorng% {     go(tbl_posterior_predictive$data[[i]])   }   tbl_pr_go <- bind_rows(res, .id = \"iter\") %>%     group_by(group_id) %>%     summarize(       `Pr[go]` = mean(go),       se  = sd(go) / sqrt(n())     )   return(tbl_pr_go) } tbl_pr_go_over_time <- tbl_data_interims %>%   mutate(     res = purrr::map(data, pr_go, nsim = 100L)   ) %>%   tidyr::unnest(res) #> Warning: The largest R-hat is 1.07, indicating chains have not mixed. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#r-hat #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess #> Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess #> Warning: The largest R-hat is 1.06, indicating chains have not mixed. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#r-hat #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess #> Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess #> Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess  tbl_pr_go_over_time #> # A tibble: 16 √ó 5 #>    t_interim data                 group_id `Pr[go]`     se #>        <dbl> <list>               <chr>       <dbl>  <dbl> #>  1         1 <tibble [6 √ó 5]>     A            0.21 0.0409 #>  2         1 <tibble [6 √ó 5]>     B            0.28 0.0451 #>  3         3 <tibble [26 √ó 5]>    A            0.16 0.0368 #>  4         3 <tibble [26 √ó 5]>    B            0.27 0.0446 #>  5         6 <tibble [74 √ó 5]>    A            0.7  0.0461 #>  6         6 <tibble [74 √ó 5]>    B            0.88 0.0327 #>  7         9 <tibble [135 √ó 5]>   A            0.83 0.0378 #>  8         9 <tibble [135 √ó 5]>   B            0.93 0.0256 #>  9        12 <tibble [221 √ó 5]>   A            0.75 0.0435 #> 10        12 <tibble [221 √ó 5]>   B            0.87 0.0338 #> 11        18 <tibble [435 √ó 5]>   A            0.68 0.0469 #> 12        18 <tibble [435 √ó 5]>   B            0.91 0.0288 #> 13        24 <tibble [724 √ó 5]>   A            0.6  0.0492 #> 14        24 <tibble [724 √ó 5]>   B            0.27 0.0446 #> 15        36 <tibble [1,149 √ó 5]> A            0.58 0.0496 #> 16        36 <tibble [1,149 √ó 5]> B            0.01 0.01 ggplot(tbl_pr_go_over_time) +   aes(t_interim) +   geom_errorbar(aes(ymin = `Pr[go]` - se, ymax = `Pr[go]` + se,                     color = group_id), width = 1) +   geom_line(aes(y = `Pr[go]`, color = group_id), alpha = 0.33) +   scale_x_continuous(\"t [months]\", breaks = seq(0, 36, by = 6)) +   scale_y_continuous(breaks = seq(0, 1, by = 0.1), limits = c(0, 1)) f <- function(tbl) {   tbl %>%   group_by(group_id, subject_id) %>%   summarize(     responder = any(state == \"response\") && all(state != \"progression\"),     progressor = any(state == \"progression\"),     stable = all(state == \"stable\"),     .groups = \"drop_last\"   ) %>%   summarize(     response = sum(responder),     progression = sum(progressor),     stable = sum(stable)   ) }  tbl <- tibble(     t_interim = tbl_data_interims$t_interim,     summary = purrr::map(tbl_data_interims$data, f)   ) %>%   unnest(summary)  pivot_longer(tbl, c(response, progression, stable), names_to = \"event\") %>%   ggplot() +     aes(t_interim, value, color = event, linetype = group_id) +     geom_line() +     scale_x_continuous(\"t [months]\", breaks = seq(0, 36, by = 6)) +     scale_y_continuous(\"\", breaks = seq(0, 30, by = 5))"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/articles/web_only/application-to-probability-of-success.html","id":"session-info","dir":"Articles > Web_only","previous_headings":"","what":"Session info","title":"Application to Probability of 'go'","text":"","code":"sessionInfo() #> R version 4.2.2 (2022-10-31) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 22.04.1 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] doRNG_1.8.2        rngtools_1.5.2     doFuture_0.12.2    foreach_1.5.2      #> [5] future_1.29.0      tidyr_1.2.1        dplyr_1.0.10       ggplot2_3.4.0      #> [9] oncomsm_0.1.1.9000 #>  #> loaded via a namespace (and not attached): #>  [1] Rcpp_1.0.9           listenv_0.8.0        prettyunits_1.1.1    #>  [4] ps_1.7.2             rprojroot_2.0.3      digest_0.6.30        #>  [7] utf8_1.2.2           parallelly_1.32.1    R6_2.5.1             #> [10] backports_1.4.1      stats4_4.2.2         evaluate_0.18        #> [13] highr_0.9            pillar_1.8.1         rlang_1.0.6          #> [16] callr_3.7.3          jquerylib_0.1.4      checkmate_2.1.0      #> [19] rmarkdown_2.18       pkgdown_2.0.6        labeling_0.4.2       #> [22] textshaping_0.3.6    desc_1.4.2           stringr_1.4.1        #> [25] loo_2.5.1            munsell_0.5.0        compiler_4.2.2       #> [28] xfun_0.35            rstan_2.21.7         pkgconfig_2.0.3      #> [31] systemfonts_1.0.4    pkgbuild_1.3.1       globals_0.16.2       #> [34] htmltools_0.5.3      tidyselect_1.2.0     tibble_3.1.8         #> [37] gridExtra_2.3        codetools_0.2-18     matrixStats_0.63.0   #> [40] fansi_1.0.3          crayon_1.5.2         withr_2.5.0          #> [43] grid_4.2.2           jsonlite_1.8.3       gtable_0.3.1         #> [46] lifecycle_1.0.3      magrittr_2.0.3       StanHeaders_2.21.0-7 #> [49] scales_1.2.1         RcppParallel_5.1.5   cli_3.4.1            #> [52] stringi_1.7.8        cachem_1.0.6         farver_2.1.1         #> [55] fs_1.5.2             bslib_0.4.1          ellipsis_0.3.2       #> [58] ragg_1.2.4           generics_0.1.3       vctrs_0.5.1          #> [61] iterators_1.0.14     tools_4.2.2          glue_1.6.2           #> [64] purrr_0.3.5          processx_3.8.0       parallel_4.2.2       #> [67] fastmap_1.1.0        yaml_2.3.6           RcppNumerical_0.4-0  #> [70] inline_0.3.19        colorspace_2.0-3     memoise_2.0.1        #> [73] knitr_1.41           patchwork_1.1.2      sass_0.4.4"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kevin Kunzmann. Author, maintainer. Karhtik Ananthakrishnan. Contributor. Boehringer Ingelheim Ltd.. Copyright holder, funder.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kunzmann K (2022). oncomsm: Bayesian Multi-State Models Early Oncology. https://boehringer-ingelheim.github.io/oncomsm/, https://github.com/Boehringer-Ingelheim/oncomsm.","code":"@Manual{,   title = {oncomsm: Bayesian Multi-State Models for Early Oncology},   author = {Kevin Kunzmann},   year = {2022},   note = {https://boehringer-ingelheim.github.io/oncomsm/, https://github.com/Boehringer-Ingelheim/oncomsm}, }"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"bayesian-multi-state-models-for-early-oncology","dir":"","previous_headings":"","what":"Bayesian Multi-State Models for Early Oncology","title":"Bayesian Multi-State Models for Early Oncology","text":"R package oncomsm implements methods dynamically predict response progression individuals early oncology trials using parametric multi-state models Bayesian inference. allows dynamic computation ‚Äúprobability success‚Äù wide range success (‚Äúgo‚Äù) criteria. instance, bhmbasket R package can used define study success based Bayesian hierarchical models.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bayesian Multi-State Models for Early Oncology","text":"","code":"# install.packages(\"remotes\") remotes::install_github(\"https://github.com/Boehringer-Ingelheim/oncomsm\")"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Bayesian Multi-State Models for Early Oncology","text":"package documentation hosted .","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Bayesian Multi-State Models for Early Oncology","text":"See contributing guidelines.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/Model.html","id":null,"dir":"Reference","previous_headings":"","what":"An abstract multi-state model class ‚Äî Model","title":"An abstract multi-state model class ‚Äî Model","text":"abstract class defining standard set methods implemented multi-state model. Objects class 'Model' instantiated directly, objects respective sub-classes can .","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/Model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An abstract multi-state model class ‚Äî Model","text":"","code":"# S3 method for Model format(x, ...)  # S3 method for Model print(x, ...)  # S3 method for Model sample_prior(   model,   nsim = 2000L,   seed = NULL,   warmup = 500L,   pars = attr(model, \"parameter_names\"),   nuts_control = list(),   ... )  # S3 method for Model sample_posterior(   model,   data,   nsim = 2000L,   seed = NULL,   warmup = 500L,   nuts_control = list(),   pars = attr(model, \"parameter_names\"),   ... )  # S3 method for Model sample_predictive(   model,   n_per_group,   sample = NULL,   nsim = 100L,   seed = NULL,   nsim_parameters = 1000L,   warmup_parameters = 250,   as_mstate = FALSE,   nuts_control = list(),   ... )  # S3 method for Model impute(   model,   data,   nsim,   n_per_group = NULL,   now = NULL,   seed = NULL,   recruitment_rates = attr(model, \"recruitment_rate\"),   sample = NULL,   nsim_parameters = 1000L,   warmup_parameters = 250L,   nuts_control = list(),   ... )  # S3 method for Model parameter_sample_to_tibble(model, sample, ...)  # S3 method for Model plot_transition_times(model, parameter_sample, ...)  # S3 method for Model plot_response_probability(model, parameter_sample, ...)  # S3 method for Model plot_pfs(model, parameter_sample, ...)  # S3 method for Model plot_mstate(data, model, now, relative_to_sot, ...)  # S3 method for Model compute_pfs(model, t, parameter_sample, ...)  # S3 method for Model visits_to_mstate(   tbl_visits,   model,   now = max(tbl_visits$t),   eof_indicator = \"EOF\" )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/Model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"An abstract multi-state model class ‚Äî Model","text":"x Model print ... arguments passed method implementations model model class \"Model\" nsim number samples draw seed integer, fixed random seed; NULL fixed seed warmup integer, number warmup samples rstan sampler retaining samples; used tune hyperparameters MCMC algorithm. pars character vector parameter names sample; resorting model defaults NULL nuts_control control parameters NUTS algorithm see rstan::stan() data data frame variables \"subject_id\", \"group_id\", \"t_recruitment\", \"dt1\" \"dt2\" dt1 minimal dt2 maximal time event question. Inf, individual never experience event. dt1 < Inf dt2 == Inf individual still risk. \"t_recruitment\", \"dt1\" \"dt2\" can also missing individual yet recruited. n_per_group integer vector number individuals per group. sample stanfit object containing samples. parameter samples represent parameter distribution predictive distribution averages. Technically, parameters resampled replacement sample match desired number imputations. nsim_parameters integer, number parameter samples warmup_parameters integer, number warmup samples rstan sampler retaining samples parameters. as_mstate return data multi-state forma, see visits_to_mstate() now exact time point relative start trial recruitment_rates vector recruitment rates parameter_sample stanfit object samples respective model. relative_to_sot Boolean, timeline relative start trial start treatment individual t vector time-points PFS rate computed tbl_visits visit data long format eof_indicator state name indicating (exactly observed) end follow .","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from the progression-free-survival rate ‚Äî compute_pfs","title":"Sample from the progression-free-survival rate ‚Äî compute_pfs","text":"Progression-free-survival rate time t (PFS-t rate) function parameters given multi-state model. Hence prior posterior sample model gives rise sample corresponding PFS t rate.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from the progression-free-survival rate ‚Äî compute_pfs","text":"","code":"compute_pfs(model, t, parameter_sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from the progression-free-survival rate ‚Äî compute_pfs","text":"model model class \"Model\" t vector time-points PFS rate computed parameter_sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/compute_pfs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from the progression-free-survival rate ‚Äî compute_pfs","text":"data frame samples PFS rates time points vector t.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute.html","id":null,"dir":"Reference","previous_headings":"","what":"Impute data from predictive distribution ‚Äî impute","title":"Impute data from predictive distribution ‚Äî impute","text":"parameter sample provided, sample posterior predictive","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Impute data from predictive distribution ‚Äî impute","text":"","code":"impute(model, data, nsim, n_per_group, now, seed, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Impute data from predictive distribution ‚Äî impute","text":"model model class \"Model\" data (multi-state) data frame impute trajectories . nsim number samples draw n_per_group number individuals per group recruited. now exact time point relative start trial seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/impute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Impute data from predictive distribution ‚Äî impute","text":"data frame imputed version input data.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/logodds.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-odds function ‚Äî logodds","title":"Log-odds function ‚Äî logodds","text":"computed log odds probability.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/logodds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-odds function ‚Äî logodds","text":"","code":"logodds(p)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/logodds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-odds function ‚Äî logodds","text":"p numeric probabilities","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/logodds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-odds function ‚Äî logodds","text":"log(p/(1-p))","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/oncomsm-package.html","id":null,"dir":"Reference","previous_headings":"","what":"The oncomsm package. ‚Äî oncomsm-package","title":"The oncomsm package. ‚Äî oncomsm-package","text":"package implements methods dynamically predict response progression individuals early oncology trials using parametric multi-state models Bayesian inference. allows dynamic computation Probability Success wide range success criteria. inference implemented using stan.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/oncomsm-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The oncomsm package. ‚Äî oncomsm-package","text":"Stan Development Team (2021). RStan: R interface Stan. R package version 2.21.3. https://mc-stan.org","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","title":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","text":"Convert stanfit sample data table","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","text":"","code":"parameter_sample_to_tibble(model, sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","text":"model model class \"Model\" sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/parameter_sample_to_tibble.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert stanfit sample to data table ‚Äî parameter_sample_to_tibble","text":"tibble sampled parameters long format","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":null,"dir":"Reference","previous_headings":"","what":"Swimmer-like plot of multi-state data ‚Äî plot_mstate","title":"Swimmer-like plot of multi-state data ‚Äî plot_mstate","text":"Swimmer-like plot multi-state data","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swimmer-like plot of multi-state data ‚Äî plot_mstate","text":"","code":"plot_mstate(data, model, now, relative_to_sot, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_mstate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Swimmer-like plot of multi-state data ‚Äî plot_mstate","text":"data data table multi-state data model model class \"Model\" now current time relative start trial (sot) relative_to_sot Boolean, timeline relative start trial start treatment individual ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_pfs.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the progression-free-survival function of a model ‚Äî plot_pfs","title":"Plot the progression-free-survival function of a model ‚Äî plot_pfs","text":"Plot progression-free-survival function model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_pfs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the progression-free-survival function of a model ‚Äî plot_pfs","text":"","code":"plot_pfs(model, parameter_sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_pfs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the progression-free-survival function of a model ‚Äî plot_pfs","text":"model model class \"Model\" parameter_sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_response_probability.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the response probability distributions of a model ‚Äî plot_response_probability","title":"Plot the response probability distributions of a model ‚Äî plot_response_probability","text":"Plot response probability distributions model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_response_probability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the response probability distributions of a model ‚Äî plot_response_probability","text":"","code":"plot_response_probability(model, parameter_sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_response_probability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the response probability distributions of a model ‚Äî plot_response_probability","text":"model model class \"Model\" parameter_sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_transition_times.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the transition time distributions of a model ‚Äî plot_transition_times","title":"Plot the transition time distributions of a model ‚Äî plot_transition_times","text":"Plot transition time distributions model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_transition_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the transition time distributions of a model ‚Äî plot_transition_times","text":"","code":"plot_transition_times(model, parameter_sample, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/plot_transition_times.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the transition time distributions of a model ‚Äî plot_transition_times","text":"model model class \"Model\" parameter_sample stanfit object samples respective model. ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample model posterior parameters ‚Äî sample_posterior","title":"Sample model posterior parameters ‚Äî sample_posterior","text":"Posterior sample model parameters conditional data set.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample model posterior parameters ‚Äî sample_posterior","text":"","code":"sample_posterior(model, data, nsim, seed, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample model posterior parameters ‚Äî sample_posterior","text":"model model class \"Model\" data data frame variables \"subject_id\", \"group_id\", \"t_recruitment\", \"dt1\" \"dt2\" dt1 minimal dt2 maximal time event question. Inf, individual never experience event. dt1 < Inf dt2 == Inf individual still risk. \"t_recruitment\", \"dt1\" \"dt2\" can also missing individual yet recruited. nsim number samples draw seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample model posterior parameters ‚Äî sample_posterior","text":"rstanfit object posterior samples.","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data from predictive distribution of a model ‚Äî sample_predictive","title":"Sample data from predictive distribution of a model ‚Äî sample_predictive","text":"Sample data predictive distribution model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data from predictive distribution of a model ‚Äî sample_predictive","text":"","code":"sample_predictive(model, n_per_group, sample, nsim, seed, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample data from predictive distribution of a model ‚Äî sample_predictive","text":"model model class \"Model\" n_per_group integer vector number individuals per group. sample stanfit object samples respective model. nsim number samples draw seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_predictive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample data from predictive distribution of a model ‚Äî sample_predictive","text":"TODO:","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample model prior parameters ‚Äî sample_prior","title":"Sample model prior parameters ‚Äî sample_prior","text":"Sample model parameters model prior distribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample model prior parameters ‚Äî sample_prior","text":"","code":"sample_prior(model, nsim, seed, ...)"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample model prior parameters ‚Äî sample_prior","text":"model model class \"Model\" nsim number samples draw seed integer, fixed random seed; NULL fixed seed ... arguments passed method implementations","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/sample_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample model prior parameters ‚Äî sample_prior","text":"rstanfit object sampled prior parameters","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":null,"dir":"Reference","previous_headings":"","what":"A Stable-Response-Progression Model ‚Äî srp_model","title":"A Stable-Response-Progression Model ‚Äî srp_model","text":"Create new instance SRP model","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Stable-Response-Progression Model ‚Äî srp_model","text":"","code":"create_srp_model(   group_id,   logodds_mean,   logodds_sd = rep(0.01, length(group_id)),   median_time_to_next_event_mean,   median_time_to_next_event_sd = matrix(0.1, nrow = length(group_id), ncol = 3),   visit_spacing,   recruitment_rate = rep(1, length(group_id)),   max_time = 10 * 12,   logodds_min = rep(logodds(0.001), length(group_id)),   logodds_max = rep(logodds(0.999), length(group_id)),   shape_min = matrix(0.99, nrow = length(group_id), ncol = 3),   shape_max = matrix(1.01, nrow = length(group_id), ncol = 3) )  # S3 method for srp_model format(x, ...)  # S3 method for srp_model visits_to_mstate(   tbl_visits,   model,   now = max(tbl_visits$t),   eof_indicator = \"EOF\" )  # S3 method for srp_model compute_pfs(   model,   t,   parameter_sample = NULL,   warmup = 500L,   nsim = 1000L,   seed = NULL,   ... )  # S3 method for srp_model plot_mstate(   data,   model,   now = max(tbl_mstate$t_max),   relative_to_sot = TRUE,   ... )  # S3 method for srp_model plot_transition_times(   model,   parameter_sample = NULL,   seed = 42L,   nsim = 500L,   warmup = 250,   nuts_control = list(),   dt_interval = NULL,   dt_n_grid = 25,   dt_expand = 1.1,   dt_grid = NULL,   ... )  # S3 method for srp_model plot_response_probability(   model,   parameter_sample = NULL,   seed = 42L,   nsim = 500L,   warmup = 250,   nuts_control = list(),   ... )  # S3 method for srp_model plot_pfs(   model,   parameter_sample = NULL,   seed = 42L,   nsim = 500L,   warmup = 250,   nuts_control = list(),   dt_interval = NULL,   dt_n_grid = 25,   dt_expand = 1.1,   dt_grid = NULL,   ... )  # S3 method for srp_model plot(   x,   parameter_sample = NULL,   seed = 42L,   nsim = 500L,   warmup = 250,   nuts_control = list(),   dt_interval = NULL,   dt_n_grid = 25,   dt_expand = 1.1,   dt_grid = NULL,   ... )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Stable-Response-Progression Model ‚Äî srp_model","text":"group_id character vector group ids, used check compatibility data later logodds_mean vector means (truncated) normal priors log-odds response probability logodds_sd vector standard deviations (truncated) normal priors log-odds response probability median_time_to_next_event_mean matrix means (truncated) normal priors median time next event Weibull transition probabilities, (,j)-th entry -th group median time next event transition j (1=stable-response, 2=stable-progression, 3=response-progression) median_time_to_next_event_sd matrix standard deviations (truncated) normal priors median time next event Weibull transition probabilities, (,j)-th entry -th group median time next event transition j (1=stable-response, 2=stable-progression, 3=response-progression) visit_spacing vector time differences visits per group, relevant sampling predictive distribution recruitment_rate vector per-group recruitment rates, relevant sampling predictive distribution max_time maximal overall runtime first visit, relevant sampling predictive distribution logodds_min lower boundary log-odds per group logodds_max upper boundary log-odds per group shape_min matrix lower boundaries uniform prior Weibull distribution per group/transition shape_max matrix upper boundaries uniform prior Weibull distribution per group/transition x model plot ... arguments passed method implementations tbl_visits visit data long format model multi-state model object now time point since start trial (might later last recorded visit) eof_indicator state name indicating (exactly observed) end follow . t vector time-points PFS rate computed parameter_sample stanfit object samples respective model. warmup integer, number warmup samples rstan sampler retaining samples; used tune hyperparameters MCMC algorithm. nsim number samples draw seed integer, fixed random seed; NULL fixed seed data data table multi-state data relative_to_sot Boolean, timeline relative start trial start treatment individual nuts_control control parameters NUTS algorithm see rstan::stan() dt_interval numeric vector length two minimal maximal time (relative individual first visit) use plotting dt_n_grid number grid points use automatically choosing plotting interval dt_expand expansion factor upper plotting limit using automatic interval detection dt_grid numeric vector time points use plotting","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/srp_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A Stable-Response-Progression Model ‚Äî srp_model","text":"TODO","code":""},{"path":[]},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert cross sectional visit data to time-to-event data ‚Äî visits_to_mstate","title":"Convert cross sectional visit data to time-to-event data ‚Äî visits_to_mstate","text":"function assumes visit density high enough miss transient state jumps.","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert cross sectional visit data to time-to-event data ‚Äî visits_to_mstate","text":"","code":"visits_to_mstate(   tbl_visits,   model,   now = max(tbl_visits$t),   eof_indicator = \"EOF\" )"},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert cross sectional visit data to time-to-event data ‚Äî visits_to_mstate","text":"tbl_visits visit data long format model multi-state model object now time point since start trial (might later last recorded visit) eof_indicator state name indicating (exactly observed) end follow .","code":""},{"path":"https://boehringer-ingelheim.github.io/oncomsm/reference/visits_to_mstate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert cross sectional visit data to time-to-event data ‚Äî visits_to_mstate","text":"data frame","code":""}]
