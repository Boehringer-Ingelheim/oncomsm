---
title: "Multi-State Models for Oncology"
author: "Kevin Kunzmann"
bibliography: references.bib
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{multi-state-model-for-early-oncology}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitr-options, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 7 / 1.61,
  fig.align = "center"
)
```

```{r setup}
library(oncomsm)
library(dplyr, warn.conflicts = FALSE)
library(ggplot2)
```



# Background

**tl;dr:** *Tumor response data is often treated as binary endpoint in early
oncology trials (objective response or progression free survival at x months). 
This ignores the fact that these are time-to-event endpoints. 
Instead, the multi-state characteristics of the data can be exploited to 
reduce bias at interim analyses and drive event prediction for probability of 
success calculations.*

In early oncology trials, (objective tumor) response based on the RECIST
criteria is often used as primary endpoint to establish the activity of
a treatment. Response is often treated as binary variable although it is
a delayed event endpoint. At the final analysis, this simplification is
of little concern since all individuals tend to be followed up long
enough to justify the assumption that non-responders are unlikely to
still become responders. This approach is often plausible since
individuals with tumors not responding to treatment ultimately progress.
However, when continuously monitoring such a trial, the assumption of
sufficient follow-up is no longer fulfilled and a simple binary analysis
may be biased.

In this vignette, the problem is addressed by extending the statistic
binary response model to a three-state model for "stable", "response", and
"progression or death".
The respective transition numbers are given in the graph below.

```{r msm-1, eval=TRUE, echo=FALSE}
DiagrammeR::mermaid("
graph LR
  stable -- 1 --> response
  response -- 3 --> progression[progression or death]
  stable -- 2 --> progression[progression or death]
", height = 200)
```

Once someone becomes a responder, this model only allows a transition to
the combined progression or death state.
This means that progression and death are not modeled as competing events and
simplifies analysis greatly over a model like the one below:

```{r msm-2, eval=TRUE, echo=FALSE}
DiagrammeR::mermaid("
graph LR
  stable -- 1 --> response
  response -- 3a --> progression
  response -- 3b --> death
  progression -- 4 --> death
  stable -- 2a --> progression
  stable -- 2b --> death
", height = 200)
```

Coming back to the simpler model, there is still a competing event issue when
starting from 'stable'.
Often, the convenient hazard-based approach is used to model multi-state 
situations like this. The hazard-based approach is intuitive, especially when 
considering non-parametric estimation, and co variate inclusion is 
well-understood. However, a hazard-based approach has several disadvantages:

1. The hazard scale is difficult to interpret since it is a momentary risk, 
not a probability. 
This leads to problems with prior specification in a Bayesian setting.
The Bayesian approach is, however, particularly useful in the early development 
process since it allows to augment data with prior opinion or evidence and thus 
improve accuracy.

2. A hazard based, non-Markov multi-state model leads to intractable expressions 
for the implicitly given transition probabilities. Hence they need to be 
calculated by simulation which makes the model less convenient to work with if
transition probabilities a or of primary interest. Since the (objective) response 
rate often plays an important role in the analysis of early oncology trials,
this is a disadvantage. 

An alternative framework to model multi-state data are mixture models.
For details, see @jackson_comparison_2022 and @jackson_flexible_2022.
Here, we describe the concrete application to he simplified "stable", 
"response", "progression" model.
The approach is similar to @aubel_bayesian_2021.

Assuming that the transition process can be described as a semi-Markov process
is one way of rendering modeling tractable. 
This means that the time to the next transition only depends on the time
already spent in a state, not on prior jumps. 
Additionally, it is assumed that the transition times between states conditional
on both originating and target state can be described by Weibull distributions. 
This parametric family encompasses the exponential distribution with constant
transition rates as special cases but also allows increasing or decreasing 
hazards over time. 

Let $\tau_{S}$ be the transition time from the "stable" state and
$\tau_{R}$ the transition tome from the "response" state (also "sojourn" times).
Let further $R$ be a binary random variable with $R=1$ if a response occurs, 
then the model can be specified as:

$$
\begin{align}
R &\sim \operatorname{Bernoulli}(p) \\
\tau_{S} \,|\, R = 1 &\sim \operatorname{Weibull}(k[1], \lambda[1]) \\
\tau_{S} \,|\, R = 0 &\sim \operatorname{Weibull}(k[2], \lambda[2]) \\
\tau_{R}             &\sim \operatorname{Weibull}(k[3], \lambda[3])
\end{align}
$$
where $k$ is the vector of shape- and $\lambda$ the vector of scale parameters.
Let further $f_i(t)$ be the PDF of the Weibull distribution of transition 
$i\in\{1,2,3\}$ as indicated in the above figure and let $F_i(t)$ the 
corresponding CDF.
This model implies that 
$$
\operatorname{Pr}\big[\,\tau_{S} > t \,\big]  = p\cdot(1 - F_1(t))  + (1 - p)\cdot(1 - F_2(t))\\
$$
hence, it can be seen as a mixture model. 

The median of a Weibull-distributed random variable is directly related to 
shape and scale parameters.
Since the former is more convenient to interpret, the Weibull distributions are
parameterized directly via their shape and median.
The scale parameter can then be recovered via the relationship 

$$
\operatorname{scale} = \frac{\operatorname{median}}{\log(2)^{1/\operatorname{shape}}} . 
$$

The following priors are used:

1. a normal prior for the log-odds of response $\operatorname{logit}(p) \sim \mathcal{N}(\mu_p,\sigma_p^2)$
2. a truncated normal prior for the median of each transition $\operatorname{median}_{\,i} \sim \mathcal{N}(\mu_i,\sigma_i^2)[\,0,\infty)$
3. a flat prior on the shape of each transition $\operatorname{shape}_{\,i} \sim \operatorname{Uniform}(a_i, b_i)$
4. it is assumed that the observation process (visit spacing) is fixed, e.g. every 6 weeks. This is irrelevant for inference, but important for sampling forward from the model since it cannot be assumed that transition times are observed exactly but only at the regular visits. 

We treat recruitment times as independent of outcome. 
They can be modeled separately if required.


# Example 

## Specifying the model

We assume a time-scale of months.

```{r specify-model}
mdl <- create_srp_model(
  # names of the arms/groups
  group_id = c("control", "intervention"),
  # per-group logodds of response|stable
  logodds_mean = c(logodds(.25), logodds(.5)),
  logodds_sd = c(.75, .75),
  # m[i,j] is the median time to next event for group i and transition j
  median_time_to_next_event = matrix(c(
    3, 2, 6,
    2, 8, 12
  ), byrow = TRUE, nrow = 2, ncol = 3),
  # fixed standard deviation of the prior for all median times
  median_time_to_next_event_sd = matrix(
    1,
    byrow = TRUE, nrow = 2, ncol = 3
  ),
  # uniform prior over the shape parameter, difficult to identify,
  # better keep it tight to avoid issues with the sampler
  shape_min = matrix(
    .75,
    byrow = TRUE, nrow = 2, ncol = 3
  ),
  shape_max = matrix(
    2,
    byrow = TRUE, nrow = 2, ncol = 3
  ),
  # the visit interval
  visit_spacing = c(1.2, 1.2)
)
# TODO: implement a nice summary / print function here
```


## Prior checks

First, we plot the cumulative distribution functions (CDF) of the 
time-to-next-event over the first 36 (months) and the CDF of the 
response probabilities per group.
These are based on a sample drawn from the prior distribution of the model.
We can re-use the same parameter sample for sampling from the prior-predictive
distribution by separating the sampling from the plotting steps.
If no parameter sample is provided to the plotting function it samples 
automatically.

Often, the rate of progression free survival (PFS) at a particular time point 
is of interest.
This quantity is a direct function of the model parameters.
Since the simplified model does not distinguish between progression or 
death, we denote the combined endpoint as "progression".
$$
\begin{align}
\operatorname{PFS}(t) :&= \operatorname{Pr}\big[\,\text{no progression before } t\,\big] \\
  &= 1 - \operatorname{Pr}\big[\,\text{progression before } t\,] \\
  &= 1 - \operatorname{Pr}\big[\,\text{progression before } t\,|\, \text{response}\,]\cdot\operatorname{Pr}\big[\,\text{response}\,] \\
  &\qquad- \operatorname{Pr}\big[\,\text{progression before } t\,|\, \text{no response}\,]\cdot\operatorname{Pr}\big[\,\text{no response}\,] \\
  &= 1 - p\cdot\int_0^t f_1(u) \cdot F_2(t - u) \operatorname{d}u - (1 - p)\cdot F_3(t) \ .
\end{align}
$$
The integral arises from the need to reflect the uncertainty over the 
state change from "stable" to "response" on the way to "progression".
Any parameter sample thus also induces a sample of the PFS rate at any given 
time point and the curve of PFS rate over time corresponds to the survival
function of the "progression or death" event.

```{r plotting-the-prior}
smpl_prior <- sample_prior(mdl, warmup = 500, nsim = 2000, seed = 36L)

plot(mdl, dt = c(0, 36), sample = smpl_prior)
```


### Sampling from the prior-predictive distribution

Next, we draw samples from the prior-predictive distribution of the model.
We sample 100 trials with 30 individuals per arm.
Here, we can re-use the sample prior sample already used for plotting.

```{r prior-predictive}
tbl_prior_predictive <- sample_predictive(
  mdl,
  sample = smpl_prior,
  n_per_group = c(30L, 30L),
  nsim = 100,
  seed = 3423423,
  DEBUG = TRUE
)

# estimate of the response rates
tbl_prior_predictive %>%
  filter(from == "stable") %>%
  group_by(group_id) %>%
  summarize(p_response = sum(to == "response") / n())

# crude approximation of the median jump times from "stable"
tbl_prior_predictive %>%
  filter(from == "stable") %>%
  group_by(group_id, from, to) %>%
  summarize(t_jump_approx = median(t_min + t_max) / 2, .groups = "drop")
```

The generated data can also be visualized in swimmer plots

```{r plot-preior-predictive, fig.height=6}
# TODO: improve sorting
plot_mstate(mdl, tbl_prior_predictive %>% filter(iter == 1))
```



# Inference

## Building a visit data set

Usually, data will come in the form of individual visits, not yet in the
form of interval censored transitions.
We can mimic this for the sake of example by converting one of our
prior predictive samples to visit data.
Note that the conversion is not exact since the mstate format does not contain
information about potential visits between the interval boundaries.

```{r}
tbl_visits <- tbl_prior_predictive %>%
  filter(iter == 1) %>%
  mstate_to_visits(mdl, .)

print(tbl_visits)
```

Next, we add recruitment times.

```{r, fig.height=6}
recruitment_rate_overall <- 3
# sample from poisson process
set.seed(31532)
tbl_sot <- tbl_visits %>%
  select(
    subject_id,
    group_id
  ) %>%
  distinct() %>%
  arrange(runif(n())) %>% # permute groups
  mutate(
    # poisson recruitment process
    t_sot = cumsum(rexp(n = n(), rate = recruitment_rate_overall))
  )

# add to visit times
tbl_visits <- tbl_visits %>%
  left_join(tbl_sot, by = c("subject_id", "group_id")) %>%
  mutate(t = t + t_sot) %>%
  select(-t_sot)

# convert back to mstate format and plot
tbl_visits %>%
  visits_to_mstate(start_state = "stable", absorbing_states = "progression") %>%
  plot_mstate(mdl, ., relative_to_sot = FALSE)
```



## A hypothetical interim analysis

If we now cut the data at 15 months after the first SoT, we can imitate a
hypothetical interim analysis.

```{r, fig.height=6}
tbl_visits_interim <- tbl_visits %>%
  filter(t <= 15)

# convert to mstate plot
tbl_mstate_interim <- visits_to_mstate(
  tbl_visits_interim,
  start_state = "stable",
  absorbing_states = "progression",
  now = 15
)
plot_mstate(mdl, tbl_mstate_interim, relative_to_sot = FALSE, now = 15)
```

We can check the observed response rates. 
Careful, due to the different time-to-event these will be biased.

```{r}
# estimate of the response rates (biased due to missing!)
tbl_mstate_interim %>%
  filter(from == "stable", !is.na(to)) %>%
  group_by(group_id) %>%
  summarize(p_response = sum(to == "response") / n())
```

We can now do inference by drawing sample from the posterior distribution.
Clearly, this is a very extreme sample from the prior and a shift of the
posterior as compared to the prior is to be expected.

```{r}
smpl_posterior <- sample_posterior(
  mdl,
  tbl_mstate_interim,
  refresh = 500, nsim = 5000, warmup = 250, seed = 76947
)

plot(mdl, dt = c(0, 36), sample = smpl_posterior)

smpl_posterior %>%
  parameter_sample_to_tibble(mdl, .) %>%
  filter(parameter == "p") %>%
  group_by(group_id) %>%
  summarize(
    p_posterior_mean = median(value),
    q25 = quantile(value, probs = .25),
    q75 = quantile(value, probs = .75)
  )
```

The Bayesian approach specifies a full generative model.
This can be used to draw samples from the posterior
predictive distribution for the individuals still at risk and the ones not
yet recruited.
The process is the same as for sampling from the prior predictive - just with
replacing the prior distribution with the posterior distribution obtained
from conditioning on any available data. 

At 15 months into the trial, there are still individuals who have not been 
recruited (the final sample size was set to 30 per group). 

```{r}
tbl_interim_sample_sizes <- tbl_mstate_interim %>%
  select(group_id, subject_id) %>%
  distinct() %>%
  group_by(group_id) %>%
  summarize(n = n())

print(tbl_interim_sample_sizes)
```

We now sample recruitment dates and randomization probabilities for the 
still-to-be-recruited individuals.

```{r}
tbl_to_be_recruited <- tibble(
  group_id = tbl_interim_sample_sizes$group_id,
  n_to_be_recruited = 30 - tbl_interim_sample_sizes$n
) %>%
  mutate(
    tmp = purrr::map(
      n_to_be_recruited,
      ~ tibble(
        # use unique identifiers to avoid clashing between groups
        subject_id = uuid::UUIDgenerate(n = .),
        # sample recruitment times per group using half the overall
        # recruitment rate
        t_sot = cumsum(rexp(n = ., rate = recruitment_rate_overall / 2))
      )
    )
  ) %>%
  select(-n_to_be_recruited) %>%
  tidyr::unnest(tmp) %>%
  # add information on starting state etc to expand to full mstate table
  mutate(
    from = "stable",
    to = NA_character_,
    t_min = t_sot + 1 / 30, # preclude events on the day of recruitment
    t_max = Inf # right censored
  )

tbl_to_be_recruited
```

The hypothetical future first-visits can now be combined with the interim data
and the trajectories can be sampled forward using the already fitted
posterior distribution.

```{r, fig.height=6}
tbl_mstate_interim_forward <- bind_rows(tbl_mstate_interim, tbl_to_be_recruited)

tbl_posterior_predictive <- impute_predictive(
  mdl,
  data = tbl_mstate_interim_forward,
  sample = smpl_posterior,
  nsim = 1
)

plot_mstate(mdl, tbl_posterior_predictive, relative_to_sot = FALSE)
```

Repeatedly sampling from the posterior-predictive distribution allows to evaluate
any decision criterion as if the full trial were completed since the 
individual-level data is practically imputed using the posterior predictive 
distribution.
This allows to compute the Probability of Success, see [???].



# Session info

```{r session-info}
sessionInfo()
```
