---
title: "Application to Probability of Success"
author: "Kevin Kunzmann"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{application-to-probability-of-success}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitr-setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 7 / 1.61,
  fig.align = "center"
)
```

```{r setup}
library(oncomsm)
library(ggplot2)
library(dplyr, warn.conflicts = FALSE)
library(future) # parallel processing
plan(multisession) # instruct future how to run in parallel
library(doFuture)
registerDoFuture()
```


**tl;dr:** *A multi-state model allows sampling individual-level 
data. This can be used to sample future trial data from the 
prior-predictive distribution at the planning stage.
This generated trial data can then be used to evaluate quantitative
decision criteria to determine whether the sampled data would lead to a success.
The average success rate over multiple such data sets is the 
Probability of Success.
A similar approach can be taken at any interim time point by sampling from 
the posterior predictive distribution conditioning on any observed data.
This then leads to an updated (or conditional) Probability of Success.*

For a general introduction to the multi-state approach used throughout this
package, see the vignette *Multi-state Models for Early Oncology*.



## Decision criteria and Probability of Success

Let $D_t \in \mathbb{D}$ be the observed (visit) data at time point 
$t$ after the start of the trial.
Let $\tau$ be the stopping time of the trial, 
e.g. the time point when all $n$ individuals have been recruited and 
have reached their minimal follow-up.
The final decision whether or not the trial is considered a success can then
be modeled as a function $\phi: \mathbb{D} \to \{0,1\}$ with 

$$\phi(D_\tau)=1 :\Leftrightarrow D_\tau\ \text{is considered a success}\ . $$

Let $\theta$ be a vector of parameters for a generative model that allows to
sample data $D_\tau|\theta$.
Probability of Success can the be calculated as expected value of the 
decision rule under a prior distribution $f(\cdot)$ over the parameter space:
$$
\operatorname{PoS} = \int \phi(D_\tau) \cdot f(\theta) \operatorname{d}\theta \ .
$$
In practice this integral can be approximated by sampling from the generative
model and calculating the average success rate.

If data $D_t=d_t$ is observed for $t\leq\tau$, one can update the Probability
of Success using Bayes Theorem
$$
\operatorname{PoS}\,|\, (D_t=d_t \ ) = \int \phi(D_\tau\,|\,D_t=d_t) \cdot f(\theta\,|\,D_t=d_t) \operatorname{d}\theta \ .
$$

Examples for such decision rules could be

1. a quantile of the posterior distribution of the response rate being above a
certain relevance threshold,
2. a quantile of the posterior distribution of the PFS6 rate being above a
certain relevance threshold,
3. a quantile of the posterior distribution of PFS being above a certain threshold,
4. or a combination of the above.



We consider a situation with a trial including three different arms 
"A", "B", and "C".

Assume that the following prior for the Weibull SRP multi-state model with 
three arms/groups is given.

```{r prior-specification}
mdl <- create_srp_model(
  # names of the arms/groups
  group_id = c("A", "B", "C"),
  # per-group logodds of response|stable
  logodds_mean = c(logodds(.3), logodds(.4), logodds(.5)),
  logodds_sd = c(.5, .5, .5),
  # m[i,j] is the median time to next event for group i and transition j
  median_time_to_next_event = matrix(c(
    3, 2, 6,
    2.5, 8, 18,
    2, 12, 24
  ), byrow = TRUE, nrow = 3, ncol = 3),
  # fixed standard deviation of the prior for all median times
  median_time_to_next_event_sd = matrix(
    3,
    byrow = TRUE, nrow = 3, ncol = 3
  ),
  # the visit interval
  visit_spacing = c(1.2, 1.2, 1.2)
)
```

We can now sample from the prior and visualize the prior assumptions.

```{r sample-from-prios}
smpl_prior <- sample_prior(mdl, seed = 6835L)

plot(mdl, dt = c(0, 36), sample = smpl_prior, n_grid = 25)
```


## A composite ORR and PFS12 success criterion

Assume that success is defined as a combination of a sufficiently high
response rate and a sufficiently high progression-free-survival rate at 12
months:

$$\phi(D_\tau) := \operatorname{Pr}\big[\,\text{ORR} \geq 0.3\ \&\ \text{no progression or death before 12 months} \geq 0.5 \, | \, D_\tau\,\big] \geq 0.75$$

The decision criterion can be implemented as follows.

```{r}
is_success <- function(data, prob = 0.75, nsim = 250) {
  smpl <- sample_posterior(mdl,
    data = data, seed = 38497, warmup = 150L,
    nsim = nsim
  )
  tbl_pfs_orr <- bind_cols(
      sample_pfs_rate(mdl, 12, smpl),
      parameter_sample_to_tibble(mdl, smpl) %>% 
        filter(parameter == "p") %>% 
        transmute(orr = value)
    )
  res <- tbl_pfs_orr %>% 
    group_by(group_id) %>% 
    summarize(
      success = mean(pfs >= 0.5 & orr >= 0.3) >= 0.75
    )
  return(res)
}
```

An example of how to apply the criterion to a sample from the prior predictive 
distribution is given below.
Here we use a low number of posterior samples to speed up computation.

```{r}
tbl_prior_predictive <- sample_predictive(
    mdl,
    n_per_group = rep(40L, 3),
    sample = smpl_prior,
    nsim = 1L,
    seed = 34930L
  )

is_success(tbl_prior_predictive)
```

Next, we can create a table of multiple prior-predictive samples.

```{r sample-prior-predictive}
tbl_prior_predictive <- sample_predictive(
    mdl,
    n_per_group = rep(40L, 3),
    sample = smpl_prior,
    nsim = 50L, # same, here, only for demonstration purposes
    seed = 34930L
  ) %>%
  group_by(iter) %>%
  tidyr::nest() %>% 
  ungroup()

tbl_prior_predictive
```

Applying the decision criterion to each of them and averaging over all iterations
is an MCMC approximation of the expected Probability of Success.

```{r, warning=FALSE}
# compute results in parallel (also consider the furrr package)
res <- foreach(i = seq_len(nrow(tbl_prior_predictive))) %dopar% {
  is_success(tbl_prior_predictive$data[[i]])
}

pos <- c(
  A = mean(purrr::map_lgl(tmp, ~.$success[1])),
  B = mean(purrr::map_lgl(tmp, ~.$success[2])),
  C = mean(purrr::map_lgl(tmp, ~.$success[3]))
)

pos
```



## Computing Probability of Success During an Ongoing Trial

Since we use a Bayesian generative model, the posterior distribution can
be calculated at any time point given the data observed so far.
This then allows to sample the future course of the trial from the posterior
predictive distribution.

```{r, warning=FALSE}
# use generate_visit_data?
generate_visit_data(mdl, c(40, 40, 40))
recruitment_rate_overall <- 3
tbl_example <- sample_predictive(
    mdl,
    sample = smpl_prior,
    n_per_group = c(40L, 40L, 40L),
    nsim = 1,
    seed = 3423423
  ) %>% 
  select(-t_sot)
# sample recruitment times
tbl_recruitment_times <- select(tbl_example, subject_id) %>%
  distinct() %>%
  arrange(runif(n())) %>% # permute groups
  mutate(
    # poisson recruitment process
    t_sot = cumsum(rexp(n = n(), rate = recruitment_rate_overall)),
  )
# join and shift transition times accordingly
tbl_example <- left_join(tbl_example, tbl_recruitment_times, by = "subject_id") %>% 
  mutate(
    t_min = t_min + t_sot,
    t_max = t_max + t_sot
  )
# convert to visits
tbl_example <- mstate_to_visits(mdl, tbl_example) %>%
  filter(t <= 18) %>% # keep only visits before 18 months
  visits_to_mstate( # convert back to multi state data frame
    start_state = "stable",
    absorbing_states = "progression",
    now = 18
  )
```

Calculate number of individuals at interim analysis.
Next we sample recruitment dates for the remaining individuals.
Since the decision rule is not adaptive 
(we always finish the planned 30 individuals per group),
the future recruitment times are irrelevant and can be set to 0
Next, we can impute the "missing" data by sampling form the posterior-predictive 
distribution.

```{r}
tbl_mi <- impute_trial(
    mdl, tbl_example, c(40L, 40L, 40L), c(1, 1, 1), nsim = 100L
  ) %>%
  group_by(iter) %>%
  tidyr::nest() %>% 
  ungroup()
```

```{r}
tmp <- furrr::future_map(
    tbl_mi$data, function(x) tryCatch({is_success(x)}, error = function(e) NA), 
    .options = furrr::furrr_options(seed = TRUE)
  )

mean(purrr::map_lgl(tmp, ~.$success[1]))
mean(purrr::map_lgl(tmp, ~.$success[2]))
mean(purrr::map_lgl(tmp, ~.$success[3]))
```


## Session info

```{r session-info}
sessionInfo()
```
