---
title: "Integration with bhmbasket"
author: "Kevin Kunzmann"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{integration-with-bhmbasket}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitr-setup, include=FALSE}
# see whether jags can be found, if not deactivate execution
jags_found <- tryCatch(
  {
    rjags::jags.version()
    TRUE
  },
  error = function(e) FALSE
)

knitr::opts_chunk$set(
  collapse = TRUE,
  eval = jags_found,
  comment = "#>",
  fig.width = 7,
  fig.height = 7 / 1.61,
  fig.align = "center",
  cache = TRUE
)
```

```{r setup}
library(oncomsm)
library(ggplot2)
library(dplyr, warn.conflicts = FALSE)
library(future) # parallel processing

plan(multisession) # instruct future how to run in parallel
```


**tl;dr:** *The [`bhmbasket`](https://cran.r-project.org/web/packages/bhmbasket/index.html) 
package implements Bayesian hierarchical methods for basket trials with binary endpoints.
Although `oncomsm` does not support hierarchical modelling, `bhmbasket` can be 
used to define success criteria.*

Start by defining a prior specification for a multi-group trial.

```{r prior-specification}
mdl <- create_srp_model(
  group_id = c("A", "B", "C"),
  logodds_mean = c(logodds(.3), logodds(.4), logodds(.5)),
  logodds_sd = c(.5, .5, .5),
  median_time_to_next_event = matrix(c(
    3, 2, 6,
    2.5, 8, 18,
    2, 12, 24
  ), byrow = TRUE, nrow = 3, ncol = 3),
  median_time_to_next_event_sd = matrix(1, byrow = TRUE, nrow = 3, ncol = 3),
  visit_spacing = c(1.2, 1.2, 1.2)
)
```

The `bhmbasket` package implements dynamic borrowing between arms in
basket trials via Bayesian hierarchical models (BHMs).
Here, we demonstrate how `oncomsm` and the prior specified in `mdl` can be used
to derive probability of success based on a `bhmbasket` analysis. 
We use the "Berry" type model for analysis of the response data and use a
posterior $0.25$ quantile of the response rate above $0.3$ to declare success.
This means that an individual arm is considered successful if there is a $0.75$
posterior probability according to the BHM that the response rate is larger 
than $0.3$.

```{r}
is_success <- function(data, nsim = 250) {
  set.seed(2340239L)
  # convert data to bhmbasket format (multi-state to binary counts)
  data <- data %>%
    group_by(group_id, subject_id) %>%
    summarize(responder = any(to == "response"), .groups = "drop_last") %>%
    summarize(r = sum(responder), n = n(), .groups = "drop") %>%
    {
      bhmbasket::createTrial(.$n, .$r)
    }
  # define Berry model in bhmbasket
  prms_berry <- bhmbasket::setPriorParametersBerry(
    mu_mean   = bhmbasket::logit(0.25),
    mu_sd     = 1,
    tau_scale = 1
  )
  # perform analysis in bhmbasket
  res <- suppressMessages(bhmbasket::performAnalyses(
    scenario_list         = data,
    method_names          = "berry",
    evidence_levels       = 1 - 0.25,
    prior_parameters_list = prms_berry,
    target_rates          = c(.2, .3, .3),
    n_mcmc_iterations     = nsim,
    verbose               = FALSE
  ))
  # success if posterior quantile of response rate is sufficiently large
  return(tibble(
    group_id = attr(mdl, "group_id"),
    success = res$scenario_1$quantiles_list$berry[[1]][5, 2:4] >= .3
  ))
}
```

The Probability of Success at the planning stage can be computed by sampling from
the prior-predictive distribution an then applying the defined success criterion.

```{r, warning=FALSE}
tbl_prior_predictive <- sample_predictive(
    mdl,
    n_per_group = rep(40L, 3),
    nsim = 250L,
    seed = 34930L
  )

tbl_prior_predictive
```

Next, the data can be nested by iteration (resample) fo facilitate further
processing on a per-dataset basis.

```{r}
tbl_prior_predictive <- tbl_prior_predictive %>%
  group_by(iter) %>%
  tidyr::nest() %>%
  ungroup()

tbl_prior_predictive
```

The success criterion can then be applied to each of the resampled data sets.

```{r}
tbl_results <- tbl_prior_predictive %>%
  mutate(
    res = furrr::future_map(
      data, is_success,
      .options = furrr::furrr_options(seed = TRUE)
    )
  ) %>%
  select(-data) %>%
  tidyr::unnest(res)

tbl_results
```

Finally, Probability of Success can be computed as the average success rate.

```{r}
tbl_results %>%
  group_by(group_id) %>%
  summarize(
    PoS = mean(success)
  )
```
